{"0": {
    "doc": "pages.advanced_cli_usage",
    "title": "Advanced CLI Usage",
    "content": " ",
    "url": "/firefly/contributors/advanced_cli_usage.html#advanced-cli-usage",
    "relUrl": "/contributors/advanced_cli_usage.html#advanced-cli-usage"
  },"1": {
    "doc": "pages.advanced_cli_usage",
    "title": "Table of contents",
    "content": ". | Advanced CLI Usage . | Understanding how the CLI uses FireFly releases | The manifest.json file | Default CLI behavior for releases | Running a specific release of FireFly | Running an unreleased version of one or more services . | Build a new image of fabconnect locally | Edit your manifest.json file | Initialize the stack with the custom manifest.json file | . | Running a locally built FireFly Core image . | Build a new image of FireFly locally | . | Edit your manifest.json file . | Initialize the stack with the custom manifest.json file | . | . | . This page details some of the more advanced options of the FireFly CLI . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#table-of-contents",
    "relUrl": "/contributors/advanced_cli_usage.html#table-of-contents"
  },"2": {
    "doc": "pages.advanced_cli_usage",
    "title": "Understanding how the CLI uses FireFly releases",
    "content": " ",
    "url": "/firefly/contributors/advanced_cli_usage.html#understanding-how-the-cli-uses-firefly-releases",
    "relUrl": "/contributors/advanced_cli_usage.html#understanding-how-the-cli-uses-firefly-releases"
  },"3": {
    "doc": "pages.advanced_cli_usage",
    "title": "The manifest.json file",
    "content": "FireFly has a manifest.json file in the root of the repo. This file contains a list of versions (both tag and sha) for each of the microservices that should be used with this specific commit. Here is an example of what the manifest.json looks like: . { \"ethconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-ethconnect\", \"tag\": \"v3.0.4\", \"sha\": \"0b7ce0fb175b5910f401ff576ced809fe6f0b83894277c1cc86a73a2d61c6f41\" }, \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"tag\": \"v0.9.0\", \"sha\": \"a79a4c66b0a2551d5122d019c15c6426e8cdadd6566ce3cbcb36e008fb7861ca\" }, \"dataexchange-https\": { \"image\": \"ghcr.io/hyperledger/firefly-dataexchange-https\", \"tag\": \"v0.9.0\", \"sha\": \"0de5b1db891a02871505ba5e0507821416d9fa93c96ccb4b1ba2fac45eb37214\" }, \"tokens-erc1155\": { \"image\": \"ghcr.io/hyperledger/firefly-tokens-erc1155\", \"tag\": \"v0.9.0-20211019-01\", \"sha\": \"aabc6c483db408896838329dab5f4b9e3c16d1e9fa9fffdb7e1ff05b7b2bbdd4\" } } . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#the-manifestjson-file",
    "relUrl": "/contributors/advanced_cli_usage.html#the-manifestjson-file"
  },"4": {
    "doc": "pages.advanced_cli_usage",
    "title": "Default CLI behavior for releases",
    "content": "When creating a new stack, the CLI will by default, check the latest non-pre-release version of FireFly and look at its manifest.json file that was part of that commit. It will then use the Docker images referenced in that file to determine which images it should pull for the new stack. The specific image tag and sha is written to the docker-compose.yml file for that stack, so restarting or resetting a stack will never pull a newer image. ",
    "url": "/firefly/contributors/advanced_cli_usage.html#default-cli-behavior-for-releases",
    "relUrl": "/contributors/advanced_cli_usage.html#default-cli-behavior-for-releases"
  },"5": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running a specific release of FireFly",
    "content": "If you need to run some other version that is not the latest release of FireFly, you can tell the FireFly CLI which release to use by using the --release or -r flag. For example, to explicitly use v0.9.0 run this command to initialize the stack: . ff init -r v0.9.0 . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#running-a-specific-release-of-firefly",
    "relUrl": "/contributors/advanced_cli_usage.html#running-a-specific-release-of-firefly"
  },"6": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running an unreleased version of one or more services",
    "content": "If you need to run an unreleased version of FireFly or one of its microservices, you can point the CLI to a specific manifest.json on your local disk. To do this, use the --manifest or -m flag. For example, if you have a file at ~/firefly/manifest.json: . ff init -m ~/firefly/manifest.json . If you need to test a locally built docker image of a specific service, you’ll want to edit the manifest.json before running ff init. Let’s look at an example where we want to run a locally built version of fabconnect. The same steps apply to any of FireFly’s microservices. Build a new image of fabconnect locally . From the fabconnect project directory, build and tag a new Docker image: . docker build -t ghcr.io/hyperledger/firefly-fabconnect . Edit your manifest.json file . Next, edit the fabconnect section of the manifest.json file. You’ll want to remove the tag and sha and a \"local\": true field, so it looks like this: ... \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"local\": true }, ... Initialize the stack with the custom manifest.json file . ff init local-test -b fabric -m ~/Code/hyperledger/firefly/manifest.json ff start local-test . If you are iterating on changes locally, you can get the CLI to use an updated image by doing the following: . | Whenever the CLI does its first time setup, it will use your newly built local docker image | If you’ve already run the stack, you can run ff reset &lt;stack_name&gt; and ff start &lt;stack_name&gt; to reset the data, and use the newer image | . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#running-an-unreleased-version-of-one-or-more-services",
    "relUrl": "/contributors/advanced_cli_usage.html#running-an-unreleased-version-of-one-or-more-services"
  },"7": {
    "doc": "pages.advanced_cli_usage",
    "title": "Running a locally built FireFly Core image",
    "content": "You may have noticed that FireFly core is actually not listed in the manifest.json file. If you want to run a locally built image of FireFly Core, you can follow the same steps above, but instead of editing an existing section in the file, we’ll add a new one for FireFly. Build a new image of FireFly locally . From the firefly project directory, build and tag a new Docker image: . docker build -t ghcr.io/hyperledger/firefly . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#running-a-locally-built-firefly-core-image",
    "relUrl": "/contributors/advanced_cli_usage.html#running-a-locally-built-firefly-core-image"
  },"8": {
    "doc": "pages.advanced_cli_usage",
    "title": "Edit your manifest.json file",
    "content": "Next, edit the fabconnect section of the manifest.json file and add the following section: ... \"firefly\": { \"image\": \"ghcr.io/hyperledger/firefly\", \"local\": true }, ... Initialize the stack with the custom manifest.json file . ff init local-test -m ~/Code/hyperledger/firefly/manifest.json ff start local-test . ",
    "url": "/firefly/contributors/advanced_cli_usage.html#edit-your-manifestjson-file-1",
    "relUrl": "/contributors/advanced_cli_usage.html#edit-your-manifestjson-file-1"
  },"9": {
    "doc": "pages.advanced_cli_usage",
    "title": "pages.advanced_cli_usage",
    "content": " ",
    "url": "/firefly/contributors/advanced_cli_usage.html",
    "relUrl": "/contributors/advanced_cli_usage.html"
  },"10": {
    "doc": "pages.api_post_syntax",
    "title": "API POST Syntax",
    "content": " ",
    "url": "/firefly/reference/api_post_syntax.html#api-post-syntax",
    "relUrl": "/reference/api_post_syntax.html#api-post-syntax"
  },"11": {
    "doc": "pages.api_post_syntax",
    "title": "Table of contents",
    "content": ". | Syntax Overview | Example API Call | . ",
    "url": "/firefly/reference/api_post_syntax.html#table-of-contents",
    "relUrl": "/reference/api_post_syntax.html#table-of-contents"
  },"12": {
    "doc": "pages.api_post_syntax",
    "title": "Syntax Overview",
    "content": "Endpoints that allow submitting a transaction allow an optional query parameter called confirm. When confirm=true is set in the query string, FireFly will wait to send an HTTP response until the message has been confirmed. This means, where a blockchain transaction is involved, the HTTP request will not return until the blockchain transaction is complete. This is useful for endpoints such as registration, where the client app cannot proceed until the transaction is complete and the member/node is registered. Rather than making a request to register a member/node and then repeatedly polling the API to check to see if it succeeded, an HTTP client can use this query parameter and block until registration is complete. NOTE: This does not mean that any other member of the network has received, processed, or responded to the message. It just means that the transaction is complete from the perspective of the FireFly node to which the transaction was submitted. ",
    "url": "/firefly/reference/api_post_syntax.html#syntax-overview",
    "relUrl": "/reference/api_post_syntax.html#syntax-overview"
  },"13": {
    "doc": "pages.api_post_syntax",
    "title": "Example API Call",
    "content": "POST /api/v1/messages/broadcast?confirm=true . This will broadcast a message and wait for the message to be confirmed before returning. ",
    "url": "/firefly/reference/api_post_syntax.html#example-api-call",
    "relUrl": "/reference/api_post_syntax.html#example-api-call"
  },"14": {
    "doc": "pages.api_post_syntax",
    "title": "pages.api_post_syntax",
    "content": " ",
    "url": "/firefly/reference/api_post_syntax.html",
    "relUrl": "/reference/api_post_syntax.html"
  },"15": {
    "doc": "pages.api_query_syntax",
    "title": "API Query Syntax",
    "content": " ",
    "url": "/firefly/reference/api_query_syntax.html#api-query-syntax",
    "relUrl": "/reference/api_query_syntax.html#api-query-syntax"
  },"16": {
    "doc": "pages.api_query_syntax",
    "title": "Table of contents",
    "content": ". | Syntax Overview | Example API Call . | Operators | Modifiers | . | Detailed examples | . ",
    "url": "/firefly/reference/api_query_syntax.html#table-of-contents",
    "relUrl": "/reference/api_query_syntax.html#table-of-contents"
  },"17": {
    "doc": "pages.api_query_syntax",
    "title": "Syntax Overview",
    "content": "REST collections provide filter, skip, limit and sort support. | The field in the message is used as the query parameter . | Syntax: field=[modifiers][operator]match-string | . | When multiple query parameters are supplied these are combined with AND | When the same query parameter is supplied multiple times, these are combined with OR | . ",
    "url": "/firefly/reference/api_query_syntax.html#syntax-overview",
    "relUrl": "/reference/api_query_syntax.html#syntax-overview"
  },"18": {
    "doc": "pages.api_query_syntax",
    "title": "Example API Call",
    "content": "GET /api/v1/messages?confirmed=&gt;0&amp;type=broadcast&amp;topic=t1&amp;topic=t2&amp;context=@someprefix&amp;sort=sequence&amp;descending&amp;skip=100&amp;limit=50 . This states: . | Filter on confirmed greater than 0 | Filter on type exactly equal to broadcast | Filter on topic exactly equal to t1 or t2 | Filter on context containing the case-sensitive string someprefix | Sort on sequence in descending order | Paginate with limit of 50 and skip of 100 (e.g. get page 3, with 50/page) | . Table of filter operations, which must be the first character of the query string (after the = in the above URL path example) . Operators . Operators are a type of comparison operation to perform against the match string. | Operator | Description | . | = | Equal | . | (none) | Equal (shortcut) | . | @ | Containing | . | ^ | Starts with | . | $ | Ends with | . | &lt;&lt; | Less than | . | &lt; | Less than (shortcut) | . | &lt;= | Less than or equal | . | &gt;&gt; | Greater than | . | &gt; | Greater than (shortcut) | . | &gt;= | Greater than or equal | . Shortcuts are only safe to use when your match string starts with a-z, A-Z, 0-9, - or _. Modifiers . Modifiers can appear before the operator, to change its behavior. | Modifier | Description | . | ! | Not - negates the match | . | : | Case insensitive | . | ? | Treat empty match string as null | . ",
    "url": "/firefly/reference/api_query_syntax.html#example-api-call",
    "relUrl": "/reference/api_query_syntax.html#example-api-call"
  },"19": {
    "doc": "pages.api_query_syntax",
    "title": "Detailed examples",
    "content": "| Example | Description | . | cat | Equals “cat” | . | =cat | Equals “cat” (same) | . | !=cat | Not equal to “cat” | . | :=cat | Equal to “CAT”, “cat”, “CaT etc. | . | !:cat | Not equal to “CAT”, “cat”, “CaT etc. | . | =!cat | Equal to “!cat” (! is after operator) | . | ^cats/ | Starts with “cats/” | . | $_cat | Ends with with “_cat” | . | !:^cats/ | Does not start with “cats/”, “CATs/” etc. | . | !$-cat | Does not end with “-cat” | . | ?= | Is null | . | !?= | Is not null | . ",
    "url": "/firefly/reference/api_query_syntax.html#detailed-examples",
    "relUrl": "/reference/api_query_syntax.html#detailed-examples"
  },"20": {
    "doc": "pages.api_query_syntax",
    "title": "pages.api_query_syntax",
    "content": " ",
    "url": "/firefly/reference/api_query_syntax.html",
    "relUrl": "/reference/api_query_syntax.html"
  },"21": {
    "doc": "pages.blockchain_protocols",
    "title": "Blockchain protocols",
    "content": " ",
    "url": "/firefly/overview/blockchain_protocols.html#blockchain-protocols",
    "relUrl": "/overview/blockchain_protocols.html#blockchain-protocols"
  },"22": {
    "doc": "pages.blockchain_protocols",
    "title": "Table of contents",
    "content": ". | Supporting multiple blockchain protocols | Core constructs and custom on-chain logic | Blockchain interface plugins | Need help choosing the right blockchain ledger technology? | . ",
    "url": "/firefly/overview/blockchain_protocols.html#table-of-contents",
    "relUrl": "/overview/blockchain_protocols.html#table-of-contents"
  },"23": {
    "doc": "pages.blockchain_protocols",
    "title": "Supporting multiple blockchain protocols",
    "content": "A blockchain DLT technology is usually the beating heart of a multi-party system, critical to the new trust and privacy models being established. The FireFly API provides an interface for the blockchain tier that is fully pluggable. So you can choose the blockchain ecosystem that best meets the functional and non-functional requirements of your business network, and still benefit from the developer friendly APIs, event-driven programming model, and on-chain/off-chain coordination provided by FireFly. ",
    "url": "/firefly/overview/blockchain_protocols.html#supporting-multiple-blockchain-protocols",
    "relUrl": "/overview/blockchain_protocols.html#supporting-multiple-blockchain-protocols"
  },"24": {
    "doc": "pages.blockchain_protocols",
    "title": "Core constructs and custom on-chain logic",
    "content": "Core blockchain programming patterns like pinning proofs to the chain, fungible tokens, and non-fungible tokens are abstracted into a common API, so that higher level services can be provided on top of those - such as transaction history for tokens, or on-chain/off-chain pinning of data. You can think of these a little like the core CRUD interfaces of a traditional database technology. They are the foundation actions that any developer needs to build a multi-party system, without necessarily being a blockchain specialist. Wherever possible, reference implementations of the on-chain logic should be used, that have been peer reviewed through open source collaboration and/or wide production adoption. For fully custom smart contract logic outside of these foundation constructs, FireFly provides a passthrough mechanism. This means your applications can use the FireFly API and reliable events for simple access to the blockchain technology, while interacting with rich on-chain logic. So application developers get REST APIs that still abstract away the mechanics of how transaction submission and events work in the low level RPC interfaces of the blockchain technologies. However, the on-chain logic can be anything supported by the blockchain itself. You can think of these a little like the stored procedures of a traditional database technology. These allow execution of an exact piece of logic to be performed with a deterministic outcome, using only data stored inside of the blockchain itself. One well established way of assuring mutual agreement on an outcome in a multi-party system. Development of custom smart contracts is usually done by a specialist team that understands the technology in detail. They are often subject to additional specialist scrutiny such as multi-party review, and external code audit. FireFly is deliberately one step detached from the deployment, upgrade, and maintenance of this on-chain logic. This approach applies to both the foundational constructs, and the fully custom on-chain logic. We leave the best practice on this specialist activity to the the individual blockchain communities. However, the CLI for developers does automate deployment of a reference set of contracts to get you started. A popular approach to innovation in enterprise use cases, is to make small internal customizations to the operation of standardized peer-reviewed logic (such as token contracts), without updating the interface. This can allow you to still give the full FireFly API experience to Web/API use case developers (such as a cached transaction history API for tokens), while allowing the kinds of innovation only possible by updating the logic on-chain. ",
    "url": "/firefly/overview/blockchain_protocols.html#core-constructs-and-custom-on-chain-logic",
    "relUrl": "/overview/blockchain_protocols.html#core-constructs-and-custom-on-chain-logic"
  },"25": {
    "doc": "pages.blockchain_protocols",
    "title": "Blockchain interface plugins",
    "content": "Different blockchains provide different features, such as multiple separate ledgers (Fabric channels etc.) or private transaction execution (Tessera etc.). These are mapped to high-level core constructs in the FireFly model, but with protocol specific configuration that can be passed through from the FireFly API to the blockchain interface. There are sub-communities building the blockchain interfaces for each of the “big 3”: . | Ethereum (Hyperledger Besu, Quorum, Go-ethereum) . | Status: Mature | Repo: hyperledger/firefly-ethconnect | . | Hyperledger Fabric . | Status: Mature | Repo: hyperledger/firefly-fabconnect | . | Corda . | Status: Core model proven. Requires bespoke customization to each CorDapp | Repo: hyperledger/firefly-cordaconnect | . | . ",
    "url": "/firefly/overview/blockchain_protocols.html#blockchain-interface-plugins",
    "relUrl": "/overview/blockchain_protocols.html#blockchain-interface-plugins"
  },"26": {
    "doc": "pages.blockchain_protocols",
    "title": "Need help choosing the right blockchain ledger technology?",
    "content": "The following article might help you compare and contrast: . | Enterprise Blockchain Protocols: A Technical Analysis of Ethereum vs Fabric vs Corda | . ",
    "url": "/firefly/overview/blockchain_protocols.html#need-help-choosing-the-right-blockchain-ledger-technology",
    "relUrl": "/overview/blockchain_protocols.html#need-help-choosing-the-right-blockchain-ledger-technology"
  },"27": {
    "doc": "pages.blockchain_protocols",
    "title": "pages.blockchain_protocols",
    "content": " ",
    "url": "/firefly/overview/blockchain_protocols.html",
    "relUrl": "/overview/blockchain_protocols.html"
  },"28": {
    "doc": "pages.broadcast_shared_data",
    "title": "Broadcast / shared data",
    "content": " ",
    "url": "/firefly/overview/broadcast.html#broadcast--shared-data",
    "relUrl": "/overview/broadcast.html#broadcast--shared-data"
  },"29": {
    "doc": "pages.broadcast_shared_data",
    "title": "Table of contents",
    "content": ". | Introduction | Blockchain backed broadcast | Shared data | FireFly built-in broadcasts | Network Registry | . ",
    "url": "/firefly/overview/broadcast.html#table-of-contents",
    "relUrl": "/overview/broadcast.html#table-of-contents"
  },"30": {
    "doc": "pages.broadcast_shared_data",
    "title": "Introduction",
    "content": "Multi-party systems are about establishing a shared source of truth, and often that needs to include certain reference data that is available to all parties in the network. The data needs to be “broadcast” to all members, and also need to be available to new members that join the network . ",
    "url": "/firefly/overview/broadcast.html#introduction",
    "relUrl": "/overview/broadcast.html#introduction"
  },"31": {
    "doc": "pages.broadcast_shared_data",
    "title": "Blockchain backed broadcast",
    "content": "In order to maintain a complete history of all broadcast data for new members joining the network, FireFly uses the blockchain to sequence the broadcasts with pinning transactions referring to the data itself. Using the blockchain also gives a global order of events for these broadcasts, which allows them to be processed by each member in a way that allows them to derive the same result - even though the processing logic on the events themselves is being performed independently by each member. For more information see Global sequencing. ",
    "url": "/firefly/overview/broadcast.html#blockchain-backed-broadcast",
    "relUrl": "/overview/broadcast.html#blockchain-backed-broadcast"
  },"32": {
    "doc": "pages.broadcast_shared_data",
    "title": "Shared data",
    "content": "The data included in broadcasts is not recorded on the blockchain. Instead a pluggable shared storage mechanism is used to contain the data itself. The on-chain transaction just contains a hash of the data that is stored off-chain. This is because the data itself might be too large to be efficiently stored and transferred via the blockchain itself, or subject to deletion at some point in the future through agreement by the members in the network. While the data should be reliably stored with visibility to all members of the network, the data can still be secured from leakage outside of the network. The InterPlanetary File System (IPFS) is an example of a distributed technology for peer-to-peer storage and distribution of such data in a decentralized multi-party system. It provides secure connectivity between a number of nodes, combined with a decentralized index of data that is available, and native use of hashes within the technology as the way to reference data by content. ",
    "url": "/firefly/overview/broadcast.html#shared-data",
    "relUrl": "/overview/broadcast.html#shared-data"
  },"33": {
    "doc": "pages.broadcast_shared_data",
    "title": "FireFly built-in broadcasts",
    "content": "FireFly uses the broadcast mechanism internally to distribute key information to all parties in the network: . | Network map . | Organizational identities | Nodes | See Identity for more information | . | Datatype definitions . | See Agreed datatypes for more information | . | Namespaces . | See Namespaces for more information | . | . These definitions rely on the same assurances provided by blockchain backed broadcast that FireFly applications do. | Verification of the identity of the party in the network that performed the broadcast | Deterministic assignment of a namespace+name to an unique item of data . | If two parties in the network broadcast the same data at similar times, the same one “wins” for all parties in the network (including the broadcaster) | . | . ",
    "url": "/firefly/overview/broadcast.html#firefly-built-in-broadcasts",
    "relUrl": "/overview/broadcast.html#firefly-built-in-broadcasts"
  },"34": {
    "doc": "pages.broadcast_shared_data",
    "title": "Network Registry",
    "content": "Work in progress . Using a permissioned blockchain and shared data network provides a security mechanism to protect against broadcast data being published from outside of the network. However, some networks might have additional permissioning and security requirements on joining the network. As such FireFly defines a plug-point for a Network Registry that defines a way to establish authorization to perform a broadcast (that is decoupled from the blockchain and shared data tiers themselves). ",
    "url": "/firefly/overview/broadcast.html#network-registry",
    "relUrl": "/overview/broadcast.html#network-registry"
  },"35": {
    "doc": "pages.broadcast_shared_data",
    "title": "pages.broadcast_shared_data",
    "content": " ",
    "url": "/firefly/overview/broadcast.html",
    "relUrl": "/overview/broadcast.html"
  },"36": {
    "doc": "pages.broadcast_data",
    "title": "Broadcast data",
    "content": " ",
    "url": "/firefly/tutorials/broadcast_data.html#broadcast-data",
    "relUrl": "/tutorials/broadcast_data.html#broadcast-data"
  },"37": {
    "doc": "pages.broadcast_data",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | Example 1: Inline string data | Example message response | Example 2: Inline object data to a topic (no datatype verification) | Example 3: Upload a blob with metadata and broadcast . | Multipart form post of a file | Example data response from Blob upload | Broadcast the uploaded data | . | . ",
    "url": "/firefly/tutorials/broadcast_data.html#table-of-contents",
    "relUrl": "/tutorials/broadcast_data.html#table-of-contents"
  },"38": {
    "doc": "pages.broadcast_data",
    "title": "Quick reference",
    "content": ". | Sends a message visible to all parties in the network . | The message describes who sent it, and exactly what data was sent | . | A message has one or more attached pieces of business data . | Can be sent in-line, uploaded in advanced, or received from other parties | Can include smaller JSON payloads suitable for database storage . | These can be verified against a datatype | . | Can include references to large (multi megabyte/gigabyte) Blob data | . | Sequenced via the blockchain . | The blockchain does not contain any data, just a hash pin | . | Batched for efficiency . | One batch can pin hundreds of message broadcasts | The whole batch is written to the shared storage | . | . ",
    "url": "/firefly/tutorials/broadcast_data.html#quick-reference",
    "relUrl": "/tutorials/broadcast_data.html#quick-reference"
  },"39": {
    "doc": "pages.broadcast_data",
    "title": "Additional info",
    "content": ". | Key Concepts: Broadcast / shared data | Swagger: POST /api/v1/namespaces/{ns}/messages/broadcast] | . ",
    "url": "/firefly/tutorials/broadcast_data.html#additional-info",
    "relUrl": "/tutorials/broadcast_data.html#additional-info"
  },"40": {
    "doc": "pages.broadcast_data",
    "title": "Example 1: Inline string data",
    "content": "POST /api/v1/namespaces/default/broadcast/message . { \"data\": [ { \"value\": \"a string\" } ] } . ",
    "url": "/firefly/tutorials/broadcast_data.html#example-1-inline-string-data",
    "relUrl": "/tutorials/broadcast_data.html#example-1-inline-string-data"
  },"41": {
    "doc": "pages.broadcast_data",
    "title": "Example message response",
    "content": "Status: 202 Accepted - the message is on it’s way, but has not yet been confirmed. Issue #112 proposes adding an option to wait for the message to be confirmed by the blockchain before returning, with 200 OK. { \"header\": { \"id\": \"607e22ad-04fa-434a-a073-54f528ca14fb\", // uniquely identifies this broadcast message \"type\": \"broadcast\", // set automatically \"txtype\": \"batch_pin\", // message will be batched, and sequenced via the blockchain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // set automatically in this example to the node org \"created\": \"2021-07-01T18:06:24.5817016Z\", // set automatically \"namespace\": \"default\", // the 'default' namespace was set in the URL \"topics\": [ \"default\" // the default topic that the message is published on, if no topic is set ], // datahash is calculated from the data array below \"datahash\": \"5a7bbc074441fa3231d9c8fc942d68ef9b9b646dd234bb48c57826dc723b26fd\" }, \"hash\": \"81acf8c8f7982dbc49258535561461601cbe769752fecec0f8ce0358664979e6\", // hash of the header \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ // one item of data was stored { \"id\": \"8d8635e2-7c90-4963-99cc-794c98a68b1d\", // can be used to query the data in the future \"hash\": \"c95d6352f524a770a787c16509237baf7eb59967699fb9a6d825270e7ec0eacf\" // sha256 hash of `\"a string\"` } ] } . ",
    "url": "/firefly/tutorials/broadcast_data.html#example-message-response",
    "relUrl": "/tutorials/broadcast_data.html#example-message-response"
  },"42": {
    "doc": "pages.broadcast_data",
    "title": "Example 2: Inline object data to a topic (no datatype verification)",
    "content": "It is very good practice to set a tag and topic in each of your messages: . | tag should tell the apps receiving the broadcast (including the local app), what to do when it receives the message. Its the reason for the broadcast - an application specific type for the message. | topic should be something like a well known identifier that relates to the information you are publishing. It is used as an ordering context, so all broadcasts on a given topic are assured to be processed in order. | . POST /api/v1/namespaces/default/broadcast/message . { \"header\": { \"tag\": \"new_widget_created\", \"topics\": [\"widget_id_12345\"] }, \"data\": [ { \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/tutorials/broadcast_data.html#example-2-inline-object-data-to-a-topic-no-datatype-verification",
    "relUrl": "/tutorials/broadcast_data.html#example-2-inline-object-data-to-a-topic-no-datatype-verification"
  },"43": {
    "doc": "pages.broadcast_data",
    "title": "Example 3: Upload a blob with metadata and broadcast",
    "content": "Here we make two API calls. | Create the data object explicitly, using a multi-party form upload | . | You can also just post JSON to this endpoint | . | Broadcast a message referring to that data | . | The Blob attachment gets published to shared storage . | This happens the first time a broadcast happens on a data attachment | . | A pin goes to the blockchain | The metadata goes into a batch with the message | . Multipart form post of a file . Example curl command (Linux/Mac) to grab an image from the internet, and pipe it into a multi-part form post to FireFly. Note we use autometa to cause FireFly to automatically add the filename, and size, to the JSON part of the data object for us. curl -sLo - https://github.com/hyperledger/firefly/raw/main/docs/firefly_logo.png \\ | curl --form autometa=true --form file=@- \\ http://localhost:5000/api/v1/namespaces/default/data . Example data response from Blob upload . Status: 200 OK - your data is uploaded to your local FireFly node . At this point the data has not be shared with anyone else in the network . { // A uniquely generated ID, we can refer to when sending this data to other parties \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\", \"validator\": \"json\", // the \"value\" part is JSON \"namespace\": \"default\", // from the URL // The hash is a combination of the hash of the \"value\" metadata, and the // hash of the blob \"hash\": \"997af6a9a19f06cc8a46872617b8bf974b106f744b2e407e94cc6959aa8cf0b8\", \"created\": \"2021-07-01T20:20:35.5462306Z\", \"value\": { \"filename\": \"-\", // dash is how curl represents the filename for stdin \"size\": 31185 // the size of the blob data }, \"blob\": { // A hash reference to the blob \"hash\": \"86e6b39b04b605dd1b03f70932976775962509d29ae1ad2628e684faabe48136\" // Note at this point there is no public reference. The only place // this data has been uploaded to is our own private data exchange. // It's ready to be published to everyone (broadcast), or privately // transferred (send) to other parties in the network. But that hasn't // happened yet. } } . Broadcast the uploaded data . Just include a reference to the id returned from the upload. POST /api/v1/namespaces/default/broadcast/message . { \"data\": [ { \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\" } ] } . ",
    "url": "/firefly/tutorials/broadcast_data.html#example-3-upload-a-blob-with-metadata-and-broadcast",
    "relUrl": "/tutorials/broadcast_data.html#example-3-upload-a-blob-with-metadata-and-broadcast"
  },"44": {
    "doc": "pages.broadcast_data",
    "title": "pages.broadcast_data",
    "content": " ",
    "url": "/firefly/tutorials/broadcast_data.html",
    "relUrl": "/tutorials/broadcast_data.html"
  },"45": {
    "doc": "pages.code_hierarchy",
    "title": "Firefly Code Hierarchy",
    "content": " ",
    "url": "/firefly/contributors/code_hierarchy.html#firefly-code-hierarchy",
    "relUrl": "/contributors/code_hierarchy.html#firefly-code-hierarchy"
  },"46": {
    "doc": "pages.code_hierarchy",
    "title": "Table of contents",
    "content": ". Use the following diagram to better understand the hierarchy amongst the core FireFly components, plugins and utility frameworks: . ┌──────────┐ ┌───────────────┐ │ cmd ├──┤ firefly [Ff]│ - CLI entry point └──────────┘ │ │ - Creates parent context │ │ - Signal handling └─────┬─────────┘ │ ┌──────────┐ ┌─────┴─────────┐ - HTTP listener (Gorilla mux) │ internal ├──┤ api [As]│ * TLS (SSL), CORS configuration etc. └──────────┘ │ server │ * WS upgrade on same port │ │ - REST route definitions └─────┬─────────┘ * Simple routing logic only, all processing deferred to orchestrator │ ┌─────┴─────────┐ - REST route definition framework │ openapi [Oa]│ * Standardizes Body, Path, Query, Filter semantics │ spec | - OpenAPI 3.0 (Swagger) generation └─────┬─────────┘ * Including Swagger. UI │ ┌─────┴─────────┐ - WebSocket server │ [Ws]│ * Developer friendly JSON based protocol business app development │ websockets │ * Reliable sequenced delivery └─────┬─────────┘ * _Event interface [Ei] supports lower level integration with other compute frameworks/transports_ │ ┌─────┴─────────┐ - Extension point interface to listen for database change events │ admin [Ae]│ * For building microservice extensions to the core that run externally │ events | * Used by the Transaction Manager component └─────┬─────────┘ * Filtering to specific object types │ ┌─────┴─────────┐ - Core data types │ fftypes [Ft]│ * Used for API and Serialization │ │ * APIs can mask fields on input via router definition └─────┬─────────┘ │ ┌─────┴─────────┐ - Core runtime server. Initializes and owns instances of: │ [Or]│ * Components: Implement features ┌───────┬───┤ orchestrator │ * Plugins: Pluggable infrastructure services │ │ │ │ - Exposes actions to router │ │ └───────────────┘ * Processing starts here for all API calls │ │ │ Components: Components do the heavy lifting within the engine │ │ │ │ ┌───────────────┐ - Integrates with Blockchain Smart Contract logic across blockchain technologies │ ├───┤ contract [Cm]│ * Generates OpenAPI 3 / Swagger definitions for smart contracts, and propagates to network │ │ │ manager │ * Manages listeners for native Blockchain events, and routes those to application events │ │ └───────────────┘ * Convert to/from native Blockchain interfaces (ABI etc.) and FireFly Interface [FFI] format │ │ │ │ ┌───────────────┐ - Maintains a view of the entire network │ ├───┤ network [Nm]│ * Integrates with network permissioning [NP] plugin │ │ │ map │ * Integrates with broadcast plugin │ │ └───────────────┘ * Handles hierarchy of member identity, node identity and signing identity │ │ │ │ ┌───────────────┐ - Broadcast of data to all parties in the network │ ├───┤ broadcast [Bm]│ * Implements dispatcher for batch component │ │ │ manager | * Integrates with shared storage interface [Ss] plugin │ │ └───────────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ ┌───────────────┐ - Send private data to individual parties in the network │ ├───┤ private [Pm]│ * Implements dispatcher for batch component │ │ │ messaging | * Integrates with the data exchange [Dx] plugin │ │ └──────┬────────┘ * Messages can be pinned and sequenced via the blockchain, or just sent │ │ │ │ │ ┌──────┴────────┐ - Groups of parties, with isolated data and/or blockchains │ │ │ group [Gm]│ * Integrates with data exchange [Dx] plugin │ │ │ manager │ * Integrates with blockchain interface [Bi] plugin │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Private data management and validation │ ├───┤ data [Dm]│ * Implements dispatcher for batch component │ │ │ manager │ * Integrates with data exchange [Dx] plugin │ │ └──────┬────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ │ ┌──────┴────────┐ - JSON data schema management and validation (architecture extensible to XML and more) │ │ │ json [Jv]│ * JSON Schema validation logic for outbound and inbound messages │ │ │ validator │ * Schema propagation │ │ └──────┬────────┘ * Integrates with broadcast plugin │ │ │ │ │ ┌──────┴────────┐ - Binary data addressable via ID or Hash │ │ │ blobstore [Bs]│ * Integrates with data exchange [Dx] plugin │ │ │ │ * Hashes data, and maintains mapping to payload references in blob storage │ │ └───────────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ ┌───────────────┐ - Download from shared storage │ ├───┤ shared [Sd]│ * Parallel asynchronous download │ │ │ download │ * Resilient retry and crash recovery │ │ └───────────────┘ * Notification to event aggregator on completion │ │ │ │ ┌───────────────┐ │ ├───┤ identity [Im] │ - Central identity management service across components │ │ │ manager │ * Resolves API input identity + key combos (short names, formatting etc.) │ │ │ │ * Resolves registered on-chain signing keys back to identities │ │ └───────────────┘ * Integrates with Blockchain Interface and pluggable Identity Interface (TBD) │ │ │ │ ┌───────────────┐ - Keeps track of all operations performed against external components via plugins │ ├───┤ operation [Om]│ * Updates database with inputs/outputs │ │ │ manager │ * Provides consistent retry semantics across plugins │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Private data management and validation │ ├───┤ event [Em]│ * Implements dispatcher for batch component │ │ │ manager │ * Integrates with data exchange [Dx] plugin │ │ └──────┬────────┘ * Integrates with blockchain interface [Bi] plugin │ │ │ │ │ ┌──────┴────────┐ - Handles incoming external data │ │ │ [Ag]│ * Integrates with data exchange [Dx] plugin │ │ │ aggregator │ * Integrates with shared storage interface [Ss] plugin │ │ │ │ * Integrates with blockchain interface [Bi] plugin │ │ │ │ - Ensures valid events are dispatched only once all data is available │ │ └──────┬────────┘ * Context aware, to prevent block-the-world scenarios │ │ │ │ │ ┌──────┴────────┐ - Subscription manager │ │ │ [Sm]│ * Creation and management of subscriptions │ │ │ subscription │ * Creation and management of subscriptions │ │ │ manager │ * Message to Event matching logic │ │ └──────┬────────┘ │ │ │ │ │ ┌──────┴────────┐ - Manages delivery of events to connected applications │ │ │ event [Ed]│ * Integrates with data exchange [Dx] plugin │ │ │ dispatcher │ * Integrates with blockchain interface [Bi] plugin │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Token creation/transfer initiation, indexing and coordination │ ├───┤ asset [Am]│ * Fungible tokens: Digitized value/settlement (coins) │ │ │ manager │ * Non-fungible tokens: NFTs / globally uniqueness / digital twins │ │ └───────────────┘ * Full indexing of transaction history │ │ [REST/WebSockets] │ │ ┌─────┴─────────────┐ ┌──────────┐ ┌─ │ │ │ ERC-20 / ERC-721 ├───┤ ERC-1155 ├───┤ Simple framework for building token connectors │ │ └───────────────────┘ └──────────┘ └─ │ │ │ │ ┌───────────────┐ │ ├───┤ sync / [Sa] │ - Sync/Async Bridge │ │ │ async bridge │ * Provides synchronous request/reply APIs │ │ │ │ * Translates to underlying event-driven API │ │ └───────────────┘ │ │ │ │ ┌───────────────┐ - Aggregates messages and data, with rolled up hashes for pinning │ ├───┤ batch [Ba]│ * Pluggable dispatchers │ │ │ manager │ - Database decoupled from main-line API processing │ │ │ │ * See architecture diagrams for more info on active/active sequencing │ │ └──────┬────────┘ - Manages creation of batch processor instances │ │ │ │ │ ┌──────┴────────┐ - Short lived agent spun up to assemble batches on demand │ │ │ batch [Bp]│ * Coupled to an author+type of messages │ │ │ processor │ - Builds batches of 100s messages for efficient pinning │ │ │ │ * Aggregates messages and data, with rolled up hashes for pinning │ │ └───────────────┘ - Shuts down automatically after a configurable inactivity period │ ... more TBD │ Plugins: Each plugin comprises a Go shim, plus a remote agent microservice runtime (if required) │ │ ┌───────────────┐ - Blockchain Interface ├───────────┤ [Bi]│ * Transaction submission - including signing key management │ │ blockchain │ * Event listening │ │ interface │ * Standardized operations, and custom on-chain coupling │ └─────┬─────────┘ │ │ │ ├─────────────────────┬───────────────────┐ │ ┌─────┴─────────┐ ┌───────┴───────┐ ┌───────┴────────┐ │ │ ethereum │ │ fabric │ │ corda/cordapps │ │ └─────┬─────────┘ └───────────────┘ └────────────────┘ │ [REST/WebSockets] │ ┌─────┴────────────────────┐ ┌────────────────────────┐ ┌─ │ │ transaction manager [Tm] ├───┤ Connector API [ffcapi] ├───┤ Simple framework for building blockchain connectors │ └──────────────────────────┘ └────────────────────────┘ └─ │ │ ┌───────────────┐ - Token interface ├───────────┤ tokens [Ti]│ * Standardizes core concepts: token pools, transfers, approvals │ │ interface │ * Pluggable across token standards │ └───────────────┘ * Supports simple implementation of custom token standards via microservice connector │ [REST/WebSockets] │ ┌─────┴─────────────┐ ┌──────────┐ ┌─ │ │ ERC-20 / ERC-721 ├───┤ ERC-1155 ├───┤ Simple framework for building token connectors │ └───────────────────┘ └──────────┘ └─ │ │ ┌───────────────┐ - P2P Content Addresssed Filesystem ├───────────┤ shared [Si]│ * Payload upload / download │ │ storage │ * Payload reference management │ │ interface │ │ └─────┬─────────┘ │ │ │ ├───────── ... extensible to any shared storage sytem, accessible to all members │ ┌─────┴─────────┐ │ │ ipfs │ │ └───────────────┘ │ │ ┌───────────────┐ - Private Data Exchange ├───────────┤ data [Dx]│ * Blob storage │ │ exchange │ * Private secure messaging │ └─────┬─────────┘ * Secure file transfer │ │ │ ├─────────────────────┬────────── ... extensible to any private data exchange tech │ ┌─────┴─────────┐ ┌───────┴───────┐ │ │ https / MTLS │ │ Kaleido │ │ └───────────────┘ └───────────────┘ │ │ ┌───────────────┐ - API Authentication and Authorization Interface ├───────────┤ api auth [Aa]│ * Authenticates security credentials (OpenID Connect id token JWTs etc.) │ │ │ * Extracts API/user identity (for identity interface to map) │ └─────┬─────────┘ * Enforcement point for fine grained API access control │ │ │ ├─────────────────────┬────────── ... extensible other single sign-on technologies │ ┌─────┴─────────┐ ┌───────┴───────┐ │ │ apikey │ │ jwt │ │ └───────────────┘ └───────────────┘ │ │ ┌───────────────┐ - Database Interactions ├───────────┤ database [Di]│ * Create, Read, Update, Delete (CRUD) actions │ │ interace │ * Filtering and update definition interace │ └─────┬─────────┘ * Migrations and Indexes │ │ │ ├───────── ... extensible to NoSQL (CouchDB / MongoDB etc.) │ ┌─────┴─────────┐ │ │ sqlcommon │ │ └─────┬─────────┘ │ ├───────────────────────┬───────── ... extensible other SQL databases │ ┌─────┴─────────┐ ┌───────┴────────┐ │ │ postgres │ │ sqlite3 │ │ └───────────────┘ └────────────────┘ │ │ ┌───────────────┐ - Connects the core event engine to external frameworks and applications ├───────────┤ event [Ei]│ * Supports long-lived (durable) and ephemeral event subscriptions │ │ interface │ * Batching, filtering, all handled in core prior to transport │ └─────┬─────────┘ * Interface supports connect-in (websocket) and connect-out (broker runtime style) plugins │ │ │ ├───────────────────────┬────────── ... extensible to additional event buses (Kafka, NATS, AMQP etc.) │ ┌─────┴─────────┐ ┌───────┴────────┐ │ │ websockets │ │ webhooks │ │ └───────────────┘ └────────────────┘ │ ... more TBD Additional utility framworks ┌───────────────┐ - REST API client │ rest [Re]│ * Provides convenience and logging │ client │ * Standardizes auth, config and retry logic └───────────────┘ * Built on Resty ┌───────────────┐ - WebSocket client │ wsclient [Wc]│ * Provides convenience and logging │ │ * Standardizes auth, config and reconnect logic └───────────────┘ * Built on Gorilla WebSockets ┌───────────────┐ - Translation framework │ i18n [In]│ * Every translations must be added to `en_translations.json` - with an `FF10101` key │ │ * Errors are wrapped, providing extra features from the `errors` package (stack etc.) └───────────────┘ * Description translations also supported, such as OpenAPI description ┌───────────────┐ - Logging framework │ log [Lo]│ * Logging framework (logrus) integrated with context based tagging │ │ * Context is used throughout the code to pass API invocation context, and logging context └───────────────┘ * Example: Every API call has an ID that can be traced, as well as a timeout ┌───────────────┐ - Configuration │ config [Co]│ * File and Environment Variable based logging framework (viper) │ │ * Primary config keys all defined centrally └───────────────┘ * Plugins integrate by returning their config structure for unmarshaling (JSON tags) . ",
    "url": "/firefly/contributors/code_hierarchy.html#table-of-contents",
    "relUrl": "/contributors/code_hierarchy.html#table-of-contents"
  },"47": {
    "doc": "pages.code_hierarchy",
    "title": "pages.code_hierarchy",
    "content": " ",
    "url": "/firefly/contributors/code_hierarchy.html",
    "relUrl": "/contributors/code_hierarchy.html"
  },"48": {
    "doc": "pages.code_overview",
    "title": "Firefly Code Overview",
    "content": " ",
    "url": "/firefly/contributors/code_overview.html#firefly-code-overview",
    "relUrl": "/contributors/code_overview.html#firefly-code-overview"
  },"49": {
    "doc": "pages.code_overview",
    "title": "Table of contents",
    "content": ". | Developer Intro | Directories | . ",
    "url": "/firefly/contributors/code_overview.html#table-of-contents",
    "relUrl": "/contributors/code_overview.html#table-of-contents"
  },"50": {
    "doc": "pages.code_overview",
    "title": "Developer Intro",
    "content": "FireFly is a second generation implementation re-engineered from the ground up to improve developer experience, runtime performance, and extensibility. This means a simplified REST/WebSocket programming model for app development, and a wider range of infrastructure options for deployment. It also means a focus on an architecture and code structure for a vibrant open source community. A few highlights: . | Golang codebase . | Strong coding standards, including unit test coverage, translation support, logging and more | Fast starting, low memory footprint, multi-threaded runtime | . | OpenAPI 3.0 API specification (Swagger) . | Generated from the API router code, to avoid divergence with the implementation | . | Active/active HA architecture for the core runtime . | Deferring to the core database for state high availability | Exploiting leader election where required | . | Fully pluggable architecture . | Everything from Database through to Blockchain, and Compute | Golang plugin infrastructure to decouple the core code from the implementation | Remote Agent model to decouple code languages, and HA designs | . | Updated API resource model . | Asset, Data, Message, Event, Topic, Transaction | . | Added flexibility, with simplified the developer experience: . | Versioning of data definitions | Introducing a first class Context construct link related events into a single sequence | Allow many pieces of data to be attached to a single message, and be automatically re-assembled on arrival | Clearer separation of concerns between the FireFly DB and the Application DB | Better search, filter and query support | . ",
    "url": "/firefly/contributors/code_overview.html#developer-intro",
    "relUrl": "/contributors/code_overview.html#developer-intro"
  },"51": {
    "doc": "pages.code_overview",
    "title": "Directories",
    "content": "| internal: The core Golang implementation code | pkg: Interfaces intended for external project use | cmd: The command line entry point | smart_contracts: smart contract code for FireFly’s onchain logic | . ",
    "url": "/firefly/contributors/code_overview.html#directories",
    "relUrl": "/contributors/code_overview.html#directories"
  },"52": {
    "doc": "pages.code_overview",
    "title": "pages.code_overview",
    "content": " ",
    "url": "/firefly/contributors/code_overview.html",
    "relUrl": "/contributors/code_overview.html"
  },"53": {
    "doc": "pages.code_repositories",
    "title": "Code Repositories",
    "content": " ",
    "url": "/firefly/contributors/code_repositories.html#code-repositories",
    "relUrl": "/contributors/code_repositories.html#code-repositories"
  },"54": {
    "doc": "pages.code_repositories",
    "title": "Table of contents",
    "content": ". FireFly has a plugin based architecture design, with a microservice runtime footprint. As such there are a number of repos, and the list will grow as the community evolves. But not to worry, one of those repos is a CLI designed to get you running with all the components you need in minutes! . | CLI / Developer experience | FireFly Samples | UI Explorer | Core | HTTP Data Exchange | Ethereum (Hyperledger Besu / Quorum) connector | Corda connector | Hyperledger Fabric connector | Token connector reference implementation (ERC1155) | . Note only the projects that are primarily built to support FireFly are listed here, not all of the ecosystem of projects that integrate underneath the plugins. ",
    "url": "/firefly/contributors/code_repositories.html#table-of-contents",
    "relUrl": "/contributors/code_repositories.html#table-of-contents"
  },"55": {
    "doc": "pages.code_repositories",
    "title": "pages.code_repositories",
    "content": " ",
    "url": "/firefly/contributors/code_repositories.html",
    "relUrl": "/contributors/code_repositories.html"
  },"56": {
    "doc": "Configuration Reference",
    "title": "Configuration Reference",
    "content": ". ",
    "url": "/firefly/reference/config.html",
    "relUrl": "/reference/config.html"
  },"57": {
    "doc": "Configuration Reference",
    "title": "admin",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the admin HTTP API should listen | IP Address string | 127.0.0.1 | . | enabled | Enables the admin HTTP API | boolean | &lt;nil&gt; | . | port | The port on which the admin HTTP API should listen | int | 5001 | . | preinit | Enables the pre-init mode. This mode will let the FireFly Core process start, but not initialize any plugins, besides the database to read any configuration overrides. This allows the admin HTTP API to be used to define custom configuration before starting the rest of FireFly Core. | boolean | &lt;nil&gt; | . | publicURL | The fully qualified public URL for the admin API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation. | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/reference/config.html#admin",
    "relUrl": "/reference/config.html#admin"
  },"58": {
    "doc": "Configuration Reference",
    "title": "admin.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#admintls",
    "relUrl": "/reference/config.html#admintls"
  },"59": {
    "doc": "Configuration Reference",
    "title": "admin.ws",
    "content": "| Key | Description | Type | Default Value | . | blockedWarnInterval | How often to log warnings in core, when an admin change event listener falls behind the stream they requested and misses events | time.Duration | &lt;nil&gt; | . | eventQueueLength | Server-side queue length for events waiting for delivery over an admin change event listener websocket | int | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#adminws",
    "relUrl": "/reference/config.html#adminws"
  },"60": {
    "doc": "Configuration Reference",
    "title": "api",
    "content": "| Key | Description | Type | Default Value | . | defaultFilterLimit | The maximum number of rows to return if no limit is specified on an API request | int | &lt;nil&gt; | . | maxFilterLimit | The largest value of limit that an HTTP client can specify in a request | int | &lt;nil&gt; | . | requestMaxTimeout | The maximum amount of time that an HTTP client can specify in a Request-Timeout header to keep a specific request open | time.Duration | &lt;nil&gt; | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#api",
    "relUrl": "/reference/config.html#api"
  },"61": {
    "doc": "Configuration Reference",
    "title": "asset.manager",
    "content": "| Key | Description | Type | Default Value | . | keyNormalization | Mechanism to normalize keys before using them. Valid options are blockchain_plugin - use blockchain plugin (default) or none - do not attempt normalization | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#assetmanager",
    "relUrl": "/reference/config.html#assetmanager"
  },"62": {
    "doc": "Configuration Reference",
    "title": "batch.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#batchcache",
    "relUrl": "/reference/config.html#batchcache"
  },"63": {
    "doc": "Configuration Reference",
    "title": "batch.manager",
    "content": "| Key | Description | Type | Default Value | . | minimumPollDelay | The minimum time the batch manager waits between polls on the DB - to prevent thrashing | time.Duration | &lt;nil&gt; | . | pollTimeout | How long to wait without any notifications of new messages before doing a page query | time.Duration | &lt;nil&gt; | . | readPageSize | The size of each page of messages read from the database into memory when assembling batches | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#batchmanager",
    "relUrl": "/reference/config.html#batchmanager"
  },"64": {
    "doc": "Configuration Reference",
    "title": "batch.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#batchretry",
    "relUrl": "/reference/config.html#batchretry"
  },"65": {
    "doc": "Configuration Reference",
    "title": "blobreceiver.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blobreceiverretry",
    "relUrl": "/reference/config.html#blobreceiverretry"
  },"66": {
    "doc": "Configuration Reference",
    "title": "blobreceiver.worker",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of items the blob receiver worker will insert in a batch | int | &lt;nil&gt; | . | batchTimeout | The maximum amount of the the blob receiver worker will wait | time.Duration | &lt;nil&gt; | . | count | The number of blob receiver workers | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blobreceiverworker",
    "relUrl": "/reference/config.html#blobreceiverworker"
  },"67": {
    "doc": "Configuration Reference",
    "title": "blockchain",
    "content": "| Key | Description | Type | Default Value | . | type | A string defining which type of blockchain plugin to use. This tells FireFly which type of configuration to load for the rest of the blockchain section. | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchain",
    "relUrl": "/reference/config.html#blockchain"
  },"68": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver",
    "content": "| Key | Description | Type | Default Value | . | bodyTemplate | The body go template string to use when making HTTP requests | Go Template string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | method | The HTTP method to use when making requests to the Address Resolver | string | GET | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | responseField | The name of a JSON field that is provided in the response, that contains the ethereum address (default address) | string | address | . | retainOriginal | When true the original pre-resolved string is retained after the lookup, and passed down to Ethconnect as the from address | boolean | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Address Resolver | string | &lt;nil&gt; | . | urlTemplate | The URL Go template string to use when calling the Address Resolver | Go Template string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumaddressresolver",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolver"
  },"69": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumaddressresolverauth",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverauth"
  },"70": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | 1000 | . | ttl | The time to live (TTL) for the cache | time.Duration | 24h | . ",
    "url": "/firefly/reference/config.html#blockchainethereumaddressresolvercache",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolvercache"
  },"71": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Address Resolver | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumaddressresolverproxy",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverproxy"
  },"72": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.addressResolver.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#blockchainethereumaddressresolverretry",
    "relUrl": "/reference/config.html#blockchainethereumaddressresolverretry"
  },"73": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Ethconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream. | int | 50 | . | batchTimeout | How long Ethconnect should wait for new events to arrive and fill a batch, before sending the batch to FireFly core. Only applies when automatically creating a new event stream. | time.Duration | 500 | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | fromBlock | The first event this FireFly instance should listen to from the BatchPin smart contract. Default=0. Only affects initial creation of the event stream | Address string | 0 | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | instance | The Ethereum address of the FireFly BatchPin smart contract that has been deployed to the blockchain | Address string | &lt;nil&gt; | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Ethconnect specific HTTP headers when FireFly makes requests to Ethconnect | string | firefly | . | prefixShort | The prefix that will be used for Ethconnect specific query parameters when FireFly makes requests to Ethconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single ethconnect | string | &lt;nil&gt; | . | url | The URL of the Ethconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumethconnect",
    "relUrl": "/reference/config.html#blockchainethereumethconnect"
  },"74": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumethconnectauth",
    "relUrl": "/reference/config.html#blockchainethereumethconnectauth"
  },"75": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Ethconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumethconnectproxy",
    "relUrl": "/reference/config.html#blockchainethereumethconnectproxy"
  },"76": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#blockchainethereumethconnectretry",
    "relUrl": "/reference/config.html#blockchainethereumethconnectretry"
  },"77": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.ethconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/reference/config.html#blockchainethereumethconnectws",
    "relUrl": "/reference/config.html#blockchainethereumethconnectws"
  },"78": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the FireFly Transaction Manager runtime, if enabled | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumfftm",
    "relUrl": "/reference/config.html#blockchainethereumfftm"
  },"79": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumfftmauth",
    "relUrl": "/reference/config.html#blockchainethereumfftmauth"
  },"80": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Transaction Manager | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainethereumfftmproxy",
    "relUrl": "/reference/config.html#blockchainethereumfftmproxy"
  },"81": {
    "doc": "Configuration Reference",
    "title": "blockchain.ethereum.fftm.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#blockchainethereumfftmretry",
    "relUrl": "/reference/config.html#blockchainethereumfftmretry"
  },"82": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The number of events Fabconnect should batch together for delivery to FireFly core. Only applies when automatically creating a new event stream. | int | 50 | . | batchTimeout | The maximum amount of time to wait for a batch to complete | time.Duration | 500 | . | chaincode | The name of the Fabric chaincode that FireFly will use for BatchPin transactions | string | &lt;nil&gt; | . | channel | The Fabric channel that FireFly will use for BatchPin transactions | string | &lt;nil&gt; | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | prefixLong | The prefix that will be used for Fabconnect specific HTTP headers when FireFly makes requests to Fabconnect | string | firefly | . | prefixShort | The prefix that will be used for Fabconnect specific query parameters when FireFly makes requests to Fabconnect | string | fly | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | signer | The Fabric signing key to use when submitting transactions to Fabconnect | string | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | topic | The websocket listen topic that the node should register on, which is important if there are multiple nodes using a single Fabconnect | string | &lt;nil&gt; | . | url | The URL of the Fabconnect instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainfabricfabconnect",
    "relUrl": "/reference/config.html#blockchainfabricfabconnect"
  },"83": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainfabricfabconnectauth",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectauth"
  },"84": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to Fabconnect | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchainfabricfabconnectproxy",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectproxy"
  },"85": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#blockchainfabricfabconnectretry",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectretry"
  },"86": {
    "doc": "Configuration Reference",
    "title": "blockchain.fabric.fabconnect.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/reference/config.html#blockchainfabricfabconnectws",
    "relUrl": "/reference/config.html#blockchainfabricfabconnectws"
  },"87": {
    "doc": "Configuration Reference",
    "title": "blockchainevent.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#blockchaineventcache",
    "relUrl": "/reference/config.html#blockchaineventcache"
  },"88": {
    "doc": "Configuration Reference",
    "title": "broadcast.batch",
    "content": "| Key | Description | Type | Default Value | . | agentTimeout | How long to keep around a batching agent for a sending identity before disposal | string | &lt;nil&gt; | . | payloadLimit | The maximum payload size of a batch for broadcast messages | BytesSize | &lt;nil&gt; | . | size | The maximum number of messages that can be packed into a batch | int | &lt;nil&gt; | . | timeout | The timeout to wait for a batch to fill, before sending | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#broadcastbatch",
    "relUrl": "/reference/config.html#broadcastbatch"
  },"89": {
    "doc": "Configuration Reference",
    "title": "cors",
    "content": "| Key | Description | Type | Default Value | . | credentials | CORS setting to control whether a browser allows credentials to be sent to this API | boolean | true | . | debug | Whether debug is enabled for the CORS implementation | boolean | false | . | enabled | Whether CORS is enabled | boolean | true | . | headers | CORS setting to control the allowed headers | string | [*] | . | maxAge | The maximum age a browser should rely on CORS checks | time.Duration | 600 | . | methods | CORS setting to control the allowed methods | string | [GET POST PUT PATCH DELETE] | . | origins | CORS setting to control the allowed origins | string | [*] | . ",
    "url": "/firefly/reference/config.html#cors",
    "relUrl": "/reference/config.html#cors"
  },"90": {
    "doc": "Configuration Reference",
    "title": "database",
    "content": "| Key | Description | Type | Default Value | . | type | The type of the database interface plugin to use | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#database",
    "relUrl": "/reference/config.html#database"
  },"91": {
    "doc": "Configuration Reference",
    "title": "database.postgres",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 50 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The PostgreSQL connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#databasepostgres",
    "relUrl": "/reference/config.html#databasepostgres"
  },"92": {
    "doc": "Configuration Reference",
    "title": "database.postgres.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/postgres | . ",
    "url": "/firefly/reference/config.html#databasepostgresmigrations",
    "relUrl": "/reference/config.html#databasepostgresmigrations"
  },"93": {
    "doc": "Configuration Reference",
    "title": "database.sqlite3",
    "content": "| Key | Description | Type | Default Value | . | maxConnIdleTime | The maximum amount of time a database connection can be idle | time.Duration | 1m | . | maxConnLifetime | The maximum amount of time to keep a database connection open | time.Duration | &lt;nil&gt; | . | maxConns | Maximum connections to the database | int | 1 | . | maxIdleConns | The maximum number of idle connections to the database | int | &lt;nil&gt; | . | url | The SQLite connection string for the database | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#databasesqlite3",
    "relUrl": "/reference/config.html#databasesqlite3"
  },"94": {
    "doc": "Configuration Reference",
    "title": "database.sqlite3.migrations",
    "content": "| Key | Description | Type | Default Value | . | auto | Enables automatic database migrations | boolean | false | . | directory | The directory containing the numerically ordered migration DDL files to apply to the database | string | ./db/migrations/sqlite | . ",
    "url": "/firefly/reference/config.html#databasesqlite3migrations",
    "relUrl": "/reference/config.html#databasesqlite3migrations"
  },"95": {
    "doc": "Configuration Reference",
    "title": "dataexchange",
    "content": "| Key | Description | Type | Default Value | . | type | The Data Exchange plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#dataexchange",
    "relUrl": "/reference/config.html#dataexchange"
  },"96": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | initEnabled | Instructs FireFly to always post all current nodes to the /init API before connecting or reconnecting to the connector | boolean | false | . | manifestEnabled | Determines whether to require+validate a manifest from other DX instances in the network. Must be supported by the connector | string | false | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL of the Data Exchange instance | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#dataexchangeffdx",
    "relUrl": "/reference/config.html#dataexchangeffdx"
  },"97": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#dataexchangeffdxauth",
    "relUrl": "/reference/config.html#dataexchangeffdxauth"
  },"98": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Data Exchange | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#dataexchangeffdxproxy",
    "relUrl": "/reference/config.html#dataexchangeffdxproxy"
  },"99": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#dataexchangeffdxretry",
    "relUrl": "/reference/config.html#dataexchangeffdxretry"
  },"100": {
    "doc": "Configuration Reference",
    "title": "dataexchange.ffdx.ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | 30s | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | 5 | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | 16Kb | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | 16Kb | . ",
    "url": "/firefly/reference/config.html#dataexchangeffdxws",
    "relUrl": "/reference/config.html#dataexchangeffdxws"
  },"101": {
    "doc": "Configuration Reference",
    "title": "debug",
    "content": "| Key | Description | Type | Default Value | . | port | An HTTP port on which to enable the go debugger | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#debug",
    "relUrl": "/reference/config.html#debug"
  },"102": {
    "doc": "Configuration Reference",
    "title": "download.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxAttempts | The maximum number attempts | int | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#downloadretry",
    "relUrl": "/reference/config.html#downloadretry"
  },"103": {
    "doc": "Configuration Reference",
    "title": "download.worker",
    "content": "| Key | Description | Type | Default Value | . | count | The number of download workers | int | &lt;nil&gt; | . | queueLength | The length of the work queue in the channel to the workers - defaults to 2x the worker count | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#downloadworker",
    "relUrl": "/reference/config.html#downloadworker"
  },"104": {
    "doc": "Configuration Reference",
    "title": "event.aggregator",
    "content": "| Key | Description | Type | Default Value | . | batchSize | The maximum number of records to read from the DB before performing an aggregation run | BytesSize | &lt;nil&gt; | . | batchTimeout | How long to wait for new events to arrive before performing aggregation on a page of events | time.Duration | &lt;nil&gt; | . | firstEvent | The first event the aggregator should process, if no previous offest is stored in the DB. Valid options are oldest or newest | string | &lt;nil&gt; | . | pollTimeout | The time to wait without a notification of new events, before trying a select on the table | time.Duration | &lt;nil&gt; | . | rewindQueryLimit | Safety limit on the maximum number of records to search when performing queries to search for rewinds | int | &lt;nil&gt; | . | rewindQueueLength | The size of the queue into the rewind dispatcher | int | &lt;nil&gt; | . | rewindTimeout | The minimum time to wait for rewinds to accumulate before resolving them | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventaggregator",
    "relUrl": "/reference/config.html#eventaggregator"
  },"105": {
    "doc": "Configuration Reference",
    "title": "event.aggregator.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventaggregatorretry",
    "relUrl": "/reference/config.html#eventaggregatorretry"
  },"106": {
    "doc": "Configuration Reference",
    "title": "event.dbevents",
    "content": "| Key | Description | Type | Default Value | . | bufferSize | The size of the buffer of change events | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventdbevents",
    "relUrl": "/reference/config.html#eventdbevents"
  },"107": {
    "doc": "Configuration Reference",
    "title": "event.dispatcher",
    "content": "| Key | Description | Type | Default Value | . | batchTimeout | A short time to wait for new events to arrive before re-polling for new events | time.Duration | &lt;nil&gt; | . | bufferLength | The number of events + attachments an individual dispatcher should hold in memory ready for delivery to the subscription | int | &lt;nil&gt; | . | pollTimeout | The time to wait without a notification of new events, before trying a select on the table | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventdispatcher",
    "relUrl": "/reference/config.html#eventdispatcher"
  },"108": {
    "doc": "Configuration Reference",
    "title": "event.dispatcher.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventdispatcherretry",
    "relUrl": "/reference/config.html#eventdispatcherretry"
  },"109": {
    "doc": "Configuration Reference",
    "title": "event.listenerTopic.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventlistenertopiccache",
    "relUrl": "/reference/config.html#eventlistenertopiccache"
  },"110": {
    "doc": "Configuration Reference",
    "title": "event.transports",
    "content": "| Key | Description | Type | Default Value | . | default | The default event transport for new subscriptions | string | &lt;nil&gt; | . | enabled | Which event interface plugins are enabled | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#eventtransports",
    "relUrl": "/reference/config.html#eventtransports"
  },"111": {
    "doc": "Configuration Reference",
    "title": "group.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#groupcache",
    "relUrl": "/reference/config.html#groupcache"
  },"112": {
    "doc": "Configuration Reference",
    "title": "histograms",
    "content": "| Key | Description | Type | Default Value | . | maxChartRows | The maximum rows to fetch for each histogram bucket | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#histograms",
    "relUrl": "/reference/config.html#histograms"
  },"113": {
    "doc": "Configuration Reference",
    "title": "http",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the HTTP API should listen | IP Address string | 127.0.0.1 | . | port | The port on which the HTTP API should listen | int | 5000 | . | publicURL | The fully qualified public URL for the API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation. | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/reference/config.html#http",
    "relUrl": "/reference/config.html#http"
  },"114": {
    "doc": "Configuration Reference",
    "title": "http.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#httptls",
    "relUrl": "/reference/config.html#httptls"
  },"115": {
    "doc": "Configuration Reference",
    "title": "identity",
    "content": "| Key | Description | Type | Default Value | . | type | The Identity plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#identity",
    "relUrl": "/reference/config.html#identity"
  },"116": {
    "doc": "Configuration Reference",
    "title": "identity.manager.cache",
    "content": "| Key | Description | Type | Default Value | . | limit | The identity manager cache limit in count of items | int | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#identitymanagercache",
    "relUrl": "/reference/config.html#identitymanagercache"
  },"117": {
    "doc": "Configuration Reference",
    "title": "log",
    "content": "| Key | Description | Type | Default Value | . | compress | Determines if the rotated log files should be compressed using gzip | boolean | &lt;nil&gt; | . | filename | Filename is the file to write logs to. Backup log files will be retained in the same directory | string | &lt;nil&gt; | . | filesize | MaxSize is the maximum size the log file before it gets rotated | BytesSize | &lt;nil&gt; | . | forceColor | Force color to be enabled, even when a non-TTY output is detected | boolean | &lt;nil&gt; | . | includeCodeInfo | Enables the report caller for including the calling file and line number, and the calling function. If using text logs, it uses the logrus text format rather than the default prefix format. | boolean | &lt;nil&gt; | . | level | The log level - error, warn, info, debug, trace | string | &lt;nil&gt; | . | maxAge | The maximum time to retain old log files based on the timestamp encoded in their filename. | time.Duration | &lt;nil&gt; | . | maxBackups | Maximum number of old log files to retain | int | &lt;nil&gt; | . | noColor | Force color to be disabled, event when TTY output is detected | boolean | &lt;nil&gt; | . | timeFormat | Custom time format for logs | Time format string | &lt;nil&gt; | . | utc | Use UTC timestamps for logs | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#log",
    "relUrl": "/reference/config.html#log"
  },"118": {
    "doc": "Configuration Reference",
    "title": "log.json",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables JSON formatted logs rather than text. All log color settings are ignored when enabled. | boolean | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#logjson",
    "relUrl": "/reference/config.html#logjson"
  },"119": {
    "doc": "Configuration Reference",
    "title": "log.json.fields",
    "content": "| Key | Description | Type | Default Value | . | file | configures the JSON key containing the calling file | string | &lt;nil&gt; | . | func | Configures the JSON key containing the calling function | string | &lt;nil&gt; | . | level | Configures the JSON key containing the log level | string | &lt;nil&gt; | . | message | Configures the JSON key containing the log message | string | &lt;nil&gt; | . | timestamp | Configures the JSON key containing the timestamp of the log | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#logjsonfields",
    "relUrl": "/reference/config.html#logjsonfields"
  },"120": {
    "doc": "Configuration Reference",
    "title": "message.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#messagecache",
    "relUrl": "/reference/config.html#messagecache"
  },"121": {
    "doc": "Configuration Reference",
    "title": "message.writer",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of database inserts to include when writing a single batch of messages + data | int | &lt;nil&gt; | . | batchTimeout | How long to wait for more messages to arrive before flushing the batch | time.Duration | &lt;nil&gt; | . | count | The number of message writer workers | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#messagewriter",
    "relUrl": "/reference/config.html#messagewriter"
  },"122": {
    "doc": "Configuration Reference",
    "title": "metrics",
    "content": "| Key | Description | Type | Default Value | . | address | The IP address on which the metrics HTTP API should listen | int | 127.0.0.1 | . | enabled | Enables the metrics API | boolean | true | . | path | The path from which to serve the Prometheus metrics | string | /metrics | . | port | The port on which the metrics HTTP API should listen | int | 6000 | . | publicURL | The fully qualified public URL for the metrics API. This is used for building URLs in HTTP responses and in OpenAPI Spec generation. | URL string | &lt;nil&gt; | . | readTimeout | The maximum time to wait when reading from an HTTP connection | time.Duration | 15s | . | shutdownTimeout | The maximum amount of time to wait for any open HTTP requests to finish before shutting down the HTTP server | time.Duration | 10s | . | writeTimeout | The maximum time to wait when writing to an HTTP connection | time.Duration | 15s | . ",
    "url": "/firefly/reference/config.html#metrics",
    "relUrl": "/reference/config.html#metrics"
  },"123": {
    "doc": "Configuration Reference",
    "title": "metrics.tls",
    "content": "| Key | Description | Type | Default Value | . | caFile | The path to the CA file for TLS on this API | string | &lt;nil&gt; | . | certFile | The path to the certificate file for TLS on this API | string | &lt;nil&gt; | . | clientAuth | Enables or disables client auth for TLS on this API | string | &lt;nil&gt; | . | enabled | Enables or disables TLS on this API | boolean | false | . | keyFile | The path to the private key file for TLS on this API | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#metricstls",
    "relUrl": "/reference/config.html#metricstls"
  },"124": {
    "doc": "Configuration Reference",
    "title": "namespaces",
    "content": "| Key | Description | Type | Default Value | . | default | The default namespace - must be in the predefined list | string | &lt;nil&gt; | . | predefined | A list of namespaces to ensure exists, without requiring a broadcast from the network | List string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#namespaces",
    "relUrl": "/reference/config.html#namespaces"
  },"125": {
    "doc": "Configuration Reference",
    "title": "namespaces.predefined[]",
    "content": "| Key | Description | Type | Default Value | . | description | A description for the namespace | string | &lt;nil&gt; | . | name | The name of the namespace (must be unique) | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#namespacespredefined",
    "relUrl": "/reference/config.html#namespacespredefined"
  },"126": {
    "doc": "Configuration Reference",
    "title": "node",
    "content": "| Key | Description | Type | Default Value | . | description | The description of this FireFly node | string | &lt;nil&gt; | . | name | The name of this FireFly node | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#node",
    "relUrl": "/reference/config.html#node"
  },"127": {
    "doc": "Configuration Reference",
    "title": "opupdate.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initialDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#opupdateretry",
    "relUrl": "/reference/config.html#opupdateretry"
  },"128": {
    "doc": "Configuration Reference",
    "title": "opupdate.worker",
    "content": "| Key | Description | Type | Default Value | . | batchMaxInserts | The maximum number of database inserts to include when writing a single batch of messages + data | int | &lt;nil&gt; | . | batchTimeout | How long to wait for more messages to arrive before flushing the batch | time.Duration | &lt;nil&gt; | . | count | The number of operation update works | int | &lt;nil&gt; | . | queueLength | The size of the queue for the Operation Update worker | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#opupdateworker",
    "relUrl": "/reference/config.html#opupdateworker"
  },"129": {
    "doc": "Configuration Reference",
    "title": "orchestrator",
    "content": "| Key | Description | Type | Default Value | . | startupAttempts | The number of times to attempt to connect to core infrastructure on startup | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#orchestrator",
    "relUrl": "/reference/config.html#orchestrator"
  },"130": {
    "doc": "Configuration Reference",
    "title": "org",
    "content": "| Key | Description | Type | Default Value | . | description | A description of the organization to which this FireFly node belongs | string | &lt;nil&gt; | . | identity | DEPRECATED Please use org.key instead | string | &lt;nil&gt; | . | key | The signing identity allocated to the organization (can be the same as the nodes) | string | &lt;nil&gt; | . | name | The name of the organization to which this FireFly node belongs | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#org",
    "relUrl": "/reference/config.html#org"
  },"131": {
    "doc": "Configuration Reference",
    "title": "privatemessaging.batch",
    "content": "| Key | Description | Type | Default Value | . | agentTimeout | How long to keep around a batching agent for a sending identity before disposal | time.Duration | &lt;nil&gt; | . | payloadLimit | The maximum payload size of a private message Data Exchange payload | BytesSize | &lt;nil&gt; | . | size | The maximum number of messages in a batch for private messages | int | &lt;nil&gt; | . | timeout | The timeout to wait for a batch to fill, before sending | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#privatemessagingbatch",
    "relUrl": "/reference/config.html#privatemessagingbatch"
  },"132": {
    "doc": "Configuration Reference",
    "title": "privatemessaging.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#privatemessagingretry",
    "relUrl": "/reference/config.html#privatemessagingretry"
  },"133": {
    "doc": "Configuration Reference",
    "title": "publicstorage",
    "content": "| Key | Description | Type | Default Value | . | type | DEPRECATED Please use config.sharedstorage.type instead | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorage",
    "relUrl": "/reference/config.html#publicstorage"
  },"134": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.api",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsapi",
    "relUrl": "/reference/config.html#publicstorageipfsapi"
  },"135": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.api.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsapiauth",
    "relUrl": "/reference/config.html#publicstorageipfsapiauth"
  },"136": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.api.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsapiproxy",
    "relUrl": "/reference/config.html#publicstorageipfsapiproxy"
  },"137": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.api.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsapiretry",
    "relUrl": "/reference/config.html#publicstorageipfsapiretry"
  },"138": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.gateway",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsgateway",
    "relUrl": "/reference/config.html#publicstorageipfsgateway"
  },"139": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.gateway.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsgatewayauth",
    "relUrl": "/reference/config.html#publicstorageipfsgatewayauth"
  },"140": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.gateway.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsgatewayproxy",
    "relUrl": "/reference/config.html#publicstorageipfsgatewayproxy"
  },"141": {
    "doc": "Configuration Reference",
    "title": "publicstorage.ipfs.gateway.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#publicstorageipfsgatewayretry",
    "relUrl": "/reference/config.html#publicstorageipfsgatewayretry"
  },"142": {
    "doc": "Configuration Reference",
    "title": "sharedstorage",
    "content": "| Key | Description | Type | Default Value | . | type | The Shared Storage plugin to use | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorage",
    "relUrl": "/reference/config.html#sharedstorage"
  },"143": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsapi",
    "relUrl": "/reference/config.html#sharedstorageipfsapi"
  },"144": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsapiauth",
    "relUrl": "/reference/config.html#sharedstorageipfsapiauth"
  },"145": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS API | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsapiproxy",
    "relUrl": "/reference/config.html#sharedstorageipfsapiproxy"
  },"146": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.api.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsapiretry",
    "relUrl": "/reference/config.html#sharedstorageipfsapiretry"
  },"147": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | 30s | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | 1s | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | 475ms | . | maxIdleConns | The max number of idle connections to hold pooled | int | 100 | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | 30s | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | 10s | . | url | The URL for the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsgateway",
    "relUrl": "/reference/config.html#sharedstorageipfsgateway"
  },"148": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsgatewayauth",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayauth"
  },"149": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the IPFS Gateway | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsgatewayproxy",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayproxy"
  },"150": {
    "doc": "Configuration Reference",
    "title": "sharedstorage.ipfs.gateway.retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | 5 | . | enabled | Enables retries | boolean | false | . | initWaitTime | The initial retry delay | time.Duration | 250ms | . | maxWaitTime | The maximum retry delay | time.Duration | 30s | . ",
    "url": "/firefly/reference/config.html#sharedstorageipfsgatewayretry",
    "relUrl": "/reference/config.html#sharedstorageipfsgatewayretry"
  },"151": {
    "doc": "Configuration Reference",
    "title": "subscription",
    "content": "| Key | Description | Type | Default Value | . | max | The maximum number of pre-defined subscriptions that can exist (note for high fan-out consider connecting a dedicated pub/sub broker to the dispatcher) | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#subscription",
    "relUrl": "/reference/config.html#subscription"
  },"152": {
    "doc": "Configuration Reference",
    "title": "subscription.defaults",
    "content": "| Key | Description | Type | Default Value | . | batchSize | Default read ahead to enable for subscriptions that do not explicitly configure readahead | int | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#subscriptiondefaults",
    "relUrl": "/reference/config.html#subscriptiondefaults"
  },"153": {
    "doc": "Configuration Reference",
    "title": "subscription.retry",
    "content": "| Key | Description | Type | Default Value | . | factor | The retry backoff factor | boolean | &lt;nil&gt; | . | initDelay | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxDelay | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#subscriptionretry",
    "relUrl": "/reference/config.html#subscriptionretry"
  },"154": {
    "doc": "Configuration Reference",
    "title": "tokens[]",
    "content": "| Key | Description | Type | Default Value | . | connectionTimeout | The maximum amount of time that a connection is allowed to remain with no data transmitted | time.Duration | &lt;nil&gt; | . | connector | The name of the Tokens Connector. This will be used in the FireFly API path to refer to this specific Token Connector | string | &lt;nil&gt; | . | expectContinueTimeout | See ExpectContinueTimeout in the Go docs | time.Duration | &lt;nil&gt; | . | headers | Adds custom headers to HTTP requests | map[string]string | &lt;nil&gt; | . | idleTimeout | The max duration to hold a HTTP keepalive connection between calls | time.Duration | &lt;nil&gt; | . | maxIdleConns | The max number of idle connections to hold pooled | int | &lt;nil&gt; | . | name | The name of the Tokens Connector. This will be used in the FireFly API path to refer to this specific Token Connector | string | &lt;nil&gt; | . | plugin | The name of the Tokens Connector plugin to use | string | &lt;nil&gt; | . | requestTimeout | The maximum amount of time that a request is allowed to remain open | time.Duration | &lt;nil&gt; | . | tlsHandshakeTimeout | The maximum amount of time to wait for a successful TLS handshake | time.Duration | &lt;nil&gt; | . | url | The URL of the Token Connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#tokens",
    "relUrl": "/reference/config.html#tokens"
  },"155": {
    "doc": "Configuration Reference",
    "title": "tokens[].auth",
    "content": "| Key | Description | Type | Default Value | . | password | Password | string | &lt;nil&gt; | . | username | Username | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#tokensauth",
    "relUrl": "/reference/config.html#tokensauth"
  },"156": {
    "doc": "Configuration Reference",
    "title": "tokens[].proxy",
    "content": "| Key | Description | Type | Default Value | . | url | Optional HTTP proxy server to use when connecting to the Token Connector | URL string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#tokensproxy",
    "relUrl": "/reference/config.html#tokensproxy"
  },"157": {
    "doc": "Configuration Reference",
    "title": "tokens[].retry",
    "content": "| Key | Description | Type | Default Value | . | count | The maximum number of times to retry | int | &lt;nil&gt; | . | enabled | Enables retries | boolean | &lt;nil&gt; | . | initWaitTime | The initial retry delay | time.Duration | &lt;nil&gt; | . | maxWaitTime | The maximum retry delay | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#tokensretry",
    "relUrl": "/reference/config.html#tokensretry"
  },"158": {
    "doc": "Configuration Reference",
    "title": "tokens[].ws",
    "content": "| Key | Description | Type | Default Value | . | heartbeatInterval | The amount of time to wait between heartbeat signals on the WebSocket connection | time.Duration | &lt;nil&gt; | . | initialConnectAttempts | The number of attempts FireFly will make to connect to the WebSocket when starting up, before failing | int | &lt;nil&gt; | . | path | The WebSocket sever URL to which FireFly should connect | WebSocket URL string | &lt;nil&gt; | . | readBufferSize | The size in bytes of the read buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . | writeBufferSize | The size in bytes of the write buffer for the WebSocket connection | BytesSize | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#tokensws",
    "relUrl": "/reference/config.html#tokensws"
  },"159": {
    "doc": "Configuration Reference",
    "title": "transaction.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#transactioncache",
    "relUrl": "/reference/config.html#transactioncache"
  },"160": {
    "doc": "Configuration Reference",
    "title": "ui",
    "content": "| Key | Description | Type | Default Value | . | enabled | Enables the web user interface | boolean | &lt;nil&gt; | . | path | The file system path which contains the static HTML, CSS, and JavaScript files for the user interface | string | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#ui",
    "relUrl": "/reference/config.html#ui"
  },"161": {
    "doc": "Configuration Reference",
    "title": "validator.cache",
    "content": "| Key | Description | Type | Default Value | . | size | The size of the cache | BytesSize | &lt;nil&gt; | . | ttl | The time to live (TTL) for the cache | time.Duration | &lt;nil&gt; | . ",
    "url": "/firefly/reference/config.html#validatorcache",
    "relUrl": "/reference/config.html#validatorcache"
  },"162": {
    "doc": "pages.custom_smart_contracts",
    "title": "Work with custom smart contracts",
    "content": "FireFly includes robust support for custom smart contracts with an easy to use API to work with them. FireFly’s unified API creates a consistent application experience regardless of the specific underlying blockchain implementation. It also provides developer-friendly features like automatic OpenAPI Specification generation for smart contracts, plus a Swagger UI built-in. ",
    "url": "/firefly/tutorials/custom_contracts.html#work-with-custom-smart-contracts",
    "relUrl": "/tutorials/custom_contracts.html#work-with-custom-smart-contracts"
  },"163": {
    "doc": "pages.custom_smart_contracts",
    "title": "Table of contents",
    "content": ". | Example smart contract | Contract deployment . | Using Truffle | Using the FireFly CLI | . | The FireFly Interface Format . | Request | Response | . | Broadcast the contract interface . | Request | Response | . | Create an HTTP API for the contract . | Request | Response | . | View OpenAPI spec for the contract | Smart contracts async programming in FireFly | Invoke the smart contract . | Request | Response | . | Query the current value . | Request | Response | . | Create a blockchain event listener . | Request | Response | . | Subscribe to events from our contract . | Request | Response | . | Receive custom smart contract events . | WebSocket event | . | Appendix I: Work with a custom contract without creating a named API . | Request | Response | . | Appendix II: Work directly with contracts with inline requests . | Request | Response | . | . NOTE: This guide assumes that you are running a local FireFly stack with at least 2 members and an Ethereum blockchain created by the FireFly CLI. If you need help getting that set up, please see the Getting Started guide to Start your environment. ",
    "url": "/firefly/tutorials/custom_contracts.html#table-of-contents",
    "relUrl": "/tutorials/custom_contracts.html#table-of-contents"
  },"164": {
    "doc": "pages.custom_smart_contracts",
    "title": "Example smart contract",
    "content": "For this tutorial, we will be using a well known, but slightly modified smart contract called SimpleStorage, and will be using this contract on an Ethereum blockchain. As the name implies, it’s a very simple contract which stores an unsigned 256 bit integer, emits and event when the value is updated, and allows you to retrieve the current value. Here is the source for this contract: . // SPDX-License-Identifier: Apache-2.0 pragma solidity ^0.8.10; // Declares a new contract contract SimpleStorage { // Storage. Persists in between transactions uint256 x; // Allows the unsigned integer stored to be changed function set(uint256 newValue) public { x = newValue; emit Changed(msg.sender, newValue); } // Returns the currently stored unsigned integer function get() public view returns (uint256) { return x; } event Changed(address indexed from, uint256 value); } . ",
    "url": "/firefly/tutorials/custom_contracts.html#example-smart-contract",
    "relUrl": "/tutorials/custom_contracts.html#example-smart-contract"
  },"165": {
    "doc": "pages.custom_smart_contracts",
    "title": "Contract deployment",
    "content": "For the this guide, we will assume that the SimpleStorage contract is deployed at the Ethereum address of: 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1 . Deployment of smart contracts is not currently within the scope of responsibility for FireFly. You can use your standard blockchain specific tools to deploy your contract to whichever blockchain you are using. For Ethereum blockchains you could use Truffle or Hardhat. Using Truffle . If you’re using Truffle, you’ll need to set your truffle-config.js file to point to the locally running blockchain node that the FireFly CLI created. Make sure your networks section looks like this: . networks: { development: { host: \"127.0.0.1\", port: 5100, network_id: \"*\" } } . Using the FireFly CLI . The FireFly CLI also has a function to deploy an already-compiled smart contract to a local FireFly stack. NOTE: The contract deployment function of the FireFly CLI is a convenience function to speed up local development, and not intended for production applications . We will use the solc compiler to compile our smart contract. For details on how to install solc on your system, please see the Solidity Compiler Documentation. If you take the smart contract source code in the example above, and save that to a file called simple_storage.sol, here is the command to compile the contract: . $ solc --combined-json abi,bin simple_storage.sol &gt; simple_storage.json . Next, we’ll tell the FireFly to deploy the compiled contract to a running stack named dev. If your stack name is different, update the command accordingly: . $ ff deploy dev simple_storage.json reading stack config... done deploying simple_storage.sol:SimpleStorage... done contract address: 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1 . The FireFly CLI tells us that it has successfully deployed the contract with an address of 0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1. We will use this contract address for the rest of this guide. ",
    "url": "/firefly/tutorials/custom_contracts.html#contract-deployment",
    "relUrl": "/tutorials/custom_contracts.html#contract-deployment"
  },"166": {
    "doc": "pages.custom_smart_contracts",
    "title": "The FireFly Interface Format",
    "content": "Before we jump into using our contract with FireFly, it’s helpful to understand a couple of key concepts. One of those is the FireFly Interface format. FireFly defines a common, blockchain agnostic way to describe smart contracts. This is referred to as a Contract Interface, and it is written in the FireFly Interface (FFI) format. It is a simple JSON document that has a name, a namespace, a version, a list of methods, and a list of events. For more details, you can also have a look at the Reference page for the FireFly Interface Format. If you have an Ethereum ABI for an existing smart contract, there is an HTTP endpoint on the FireFly API that will take the ABI as input and automatically generate the FireFly Interface for you. Rather than handcrafting our FFI, we’ll let FireFly generate it for us using that endpoint now. Request . Here we will take the JSON ABI generated by truffle or solc and POST that to FireFly to have it automatically generate the FireFly Interface for us. Copy the abi from the compiled JSON file, and put that inside an input object like the example below: . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces/generate . { \"input\": { \"abi\": [ { \"anonymous\": false, \"inputs\": [ { \"indexed\": true, \"internalType\": \"address\", \"name\": \"from\", \"type\": \"address\" }, { \"indexed\": false, \"internalType\": \"uint256\", \"name\": \"value\", \"type\": \"uint256\" } ], \"name\": \"Changed\", \"type\": \"event\" }, { \"inputs\": [], \"name\": \"get\", \"outputs\": [ { \"internalType\": \"uint256\", \"name\": \"\", \"type\": \"uint256\" } ], \"stateMutability\": \"view\", \"type\": \"function\" }, { \"inputs\": [ { \"internalType\": \"uint256\", \"name\": \"newValue\", \"type\": \"uint256\" } ], \"name\": \"set\", \"outputs\": [], \"stateMutability\": \"nonpayable\", \"type\": \"function\" } ] } } . Response . FireFly generates and returns the the full FireFly Interface for the SimpleStorage contract in the response body: . { \"namespace\": \"default\", \"name\": \"\", \"description\": \"\", \"version\": \"\", \"methods\": [ { \"name\": \"get\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"name\": \"set\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . ",
    "url": "/firefly/tutorials/custom_contracts.html#the-firefly-interface-format",
    "relUrl": "/tutorials/custom_contracts.html#the-firefly-interface-format"
  },"167": {
    "doc": "pages.custom_smart_contracts",
    "title": "Broadcast the contract interface",
    "content": "Now that we have a FireFly Interface representation of our smart contract, we want to broadcast that to the entire network. This broadcast will be pinned to the blockchain, so we can always refer to this specific name and version, and everyone in the network will know exactly which contract interface we are talking about. NOTE: Contract interfaces are scoped to a namespace. Within a namespace each contract interface must have a unique name and version combination. The same name and version combination can exist in different namespaces simultaneously. We will take the output from the previous HTTP response above, fill in the name and version and then POST that to the /contracts/interfaces API endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces . { \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"version\": \"v1.0.0\", \"description\": \"\", \"methods\": [ { \"name\": \"get\", \"pathname\": \"\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"name\": \"set\", \"pathname\": \"\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . Response . { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"message\": \"3cd0dde2-1e39-4c9e-a4a1-569e87cca93a\", \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"description\": \"\", \"version\": \"v1.0.0\", \"methods\": [ { \"id\": \"56467890-5713-4463-84b8-4537fcb63d8b\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"name\": \"get\", \"namespace\": \"default\", \"pathname\": \"get\", \"description\": \"\", \"params\": [], \"returns\": [ { \"name\": \"\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"id\": \"6b254d1d-5f5f-491e-bbd2-201e96892e1a\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"name\": \"set\", \"namespace\": \"default\", \"pathname\": \"set\", \"description\": \"\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"id\": \"aa1fe67b-b2ac-41af-a7e7-7ad54a30a78d\", \"contract\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\", \"namespace\": \"default\", \"pathname\": \"Changed\", \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . ",
    "url": "/firefly/tutorials/custom_contracts.html#broadcast-the-contract-interface",
    "relUrl": "/tutorials/custom_contracts.html#broadcast-the-contract-interface"
  },"168": {
    "doc": "pages.custom_smart_contracts",
    "title": "Create an HTTP API for the contract",
    "content": "Now comes the fun part where we see some of the powerful, developer-friendly features of FireFly. The next thing we’re going to to is tell FireFly to build an HTTP API for this smart contract, complete with an OpenAPI Specification and Swagger UI. As part of this, we’ll also tell FireFly where the contract is on the blockchain. Like the interface broadcast above, this will also generate a broadcast which will be pinned to the blockchain so all the members of the network will be aware of and able to interact with this API. We need to copy the id field we got in the response from the previous step to the interface.id field in the request body below. We will also pick a name that will be part of the URL for our HTTP API, so be sure to pick a name that is URL friendly. In this case we’ll call it simple-storage. Lastly, in the location.address field, we’re telling FireFly where an instance of the contract is deployed on-chain. NOTE: The location field is optional here, but if it is omitted, it will be required in every request to invoke or query the contract. This can be useful if you have multiple instances of the same contract deployed to different addresses. Request . POST http://localhost:5000/api/v1/namespaces/default/apis . { \"name\": \"simple-storage\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" } } . Response . { \"id\": \"9a681ec6-1dee-42a0-b91b-61d23a814b0f\", \"namespace\": \"default\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"name\": \"simple-storage\", \"message\": \"d90d0386-8874-43fb-b7d3-485c22f35f47\", \"urls\": { \"openapi\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/simple-storage/api/swagger.json\", \"ui\": \"http://127.0.0.1:5000/api/v1/namespaces/default/apis/simple-storage/api\" } } . ",
    "url": "/firefly/tutorials/custom_contracts.html#create-an-http-api-for-the-contract",
    "relUrl": "/tutorials/custom_contracts.html#create-an-http-api-for-the-contract"
  },"169": {
    "doc": "pages.custom_smart_contracts",
    "title": "View OpenAPI spec for the contract",
    "content": "You’ll notice in the response body that there are a couple of URLs near the bottom. If you navigate to the one labeled ui in your browser, you should see the Swagger UI for your smart contract. ",
    "url": "/firefly/tutorials/custom_contracts.html#view-openapi-spec-for-the-contract",
    "relUrl": "/tutorials/custom_contracts.html#view-openapi-spec-for-the-contract"
  },"170": {
    "doc": "pages.custom_smart_contracts",
    "title": "Smart contracts async programming in FireFly",
    "content": "Before we start using our smart contract, it’s worth taking a moment to understand the programming model when working with smart contracts in FireFly. Like the rest of FireFly, smart contracts are implemented with an asynchronous programming model. The key concepts here are: . | Transactions are submitted to FireFly and an ID is returned. This is the Operation ID. | The transaction itself happens asynchronously from the HTTP request that initiated it | Blockchain events emitted by smart contracts will be stored in FireFly’s database if FireFly has a Listener set up for that specific type of event. FireFly will also emit an event of type blockchain_event_received when this happens. | . ",
    "url": "/firefly/tutorials/custom_contracts.html#smart-contracts-async-programming-in-firefly",
    "relUrl": "/tutorials/custom_contracts.html#smart-contracts-async-programming-in-firefly"
  },"171": {
    "doc": "pages.custom_smart_contracts",
    "title": "Invoke the smart contract",
    "content": "Now that we’ve got everything set up, it’s time to use our smart contract! We’re going to make a POST request to the invoke/set endpoint to set the integer value on-chain. Let’s set it to the value of 3 right now. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/simple-storage/invoke/set . { \"input\": { \"newValue\": 3 } } . Response . { \"id\": \"41c67c63-52cf-47ce-8a59-895fe2ffdc86\" } . You’ll notice that we just get an ID back here, and that’s expected due to the asynchronous programming model of working with smart contracts in FireFly. To see what the value is now, we can query the smart contract. In a little bit, we’ll also subscribe to the events emitted by this contract so we can know when the value is updated in realtime. ",
    "url": "/firefly/tutorials/custom_contracts.html#invoke-the-smart-contract",
    "relUrl": "/tutorials/custom_contracts.html#invoke-the-smart-contract"
  },"172": {
    "doc": "pages.custom_smart_contracts",
    "title": "Query the current value",
    "content": "To make a read-only request to the blockchain to check the current value of the stored integer, we can make a POST to the query/get endpoint. Request . POST http://localhost:5000/api/v1/namespaces/default/apis/simple-storage/query/get . {} . Response . { \"output\": \"3\" } . NOTE: Some contracts may have queries that require input parameters. That’s why the query endpoint is a POST, rather than a GET so that parameters can be passed as JSON in the request body. This particular function does not have any parameters, so we just pass an empty JSON object. ",
    "url": "/firefly/tutorials/custom_contracts.html#query-the-current-value",
    "relUrl": "/tutorials/custom_contracts.html#query-the-current-value"
  },"173": {
    "doc": "pages.custom_smart_contracts",
    "title": "Create a blockchain event listener",
    "content": "Now that we’ve seen how to submit transactions and preform read-only queries to the blockchain, let’s look at how to receive blockchain events so we know when things are happening in realtime. If you look at the source code for the smart contract we’re working with above, you’ll notice that it emits an event when the stored value of the integer is set. In order to receive these events, we first need to instruct FireFly to listen for this specific type of blockchain event. To do this, we create a Listener. The /contracts/listeners endpoint is RESTful so there are POST, GET, and DELETE methods available on it. To create a new listener, we will make a POST request. We are going to tell FireFly to listen to events with name \"Changed\" from the FireFly Interface we defined earlier, referenced by its ID. We will also tell FireFly which contract address we expect to emit these events. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/listeners . { \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"event\": { \"name\": \"Changed\" }, \"options\": { \"firstEvent\": \"oldest\" } } . Response . { \"id\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\", \"interface\": { \"id\": \"8bdd27a5-67c1-4960-8d1e-7aa31b9084d3\" }, \"namespace\": \"default\", \"name\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"protocolId\": \"sb-66209ffc-d355-4ac0-7151-bc82490ca9df\", \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"created\": \"2022-02-17T22:02:36.34549538Z\", \"event\": { \"name\": \"Changed\", \"description\": \"\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, \"options\": { \"firstEvent\": \"oldest\" } } . We can see in the response, that FireFly pulls all the schema information from the FireFly Interface that we broadcasted earlier and creates the listener with that schema. This is useful so that we don’t have to enter all of that data again. ",
    "url": "/firefly/tutorials/custom_contracts.html#create-a-blockchain-event-listener",
    "relUrl": "/tutorials/custom_contracts.html#create-a-blockchain-event-listener"
  },"174": {
    "doc": "pages.custom_smart_contracts",
    "title": "Subscribe to events from our contract",
    "content": "Now that we’ve told FireFly that it should listen for specific events on the blockchain, we can set up a Subscription for FireFly to send events to our app. This is exactly the same as listening for any other events from FireFly. For more details on how Subscriptions work in FireFly you can read the Getting Started guide to Listen for events. To set up our subscription, we will make a POST to the /subscriptions endpoint. We will set a friendly name simple-storage to identify the Subscription when we are connecting to it in the next step. We’re also going to set up a filter to only send events blockchain events from our listener that we created in the previous step. To do that, we’ll copy the listener ID from the step above (1bfa3b0f-3d90-403e-94a4-af978d8c5b14) and set that as the value of the listener field in the example below: . Request . POST http://localhost:5000/api/v1/namespaces/default/subscriptions . { \"namespace\": \"default\", \"name\": \"simple-storage\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"blockchainevent\": { \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\" } }, \"options\": { \"firstEvent\": \"oldest\" } } . Response . { \"id\": \"f826269c-65ed-4634-b24c-4f399ec53a32\", \"namespace\": \"default\", \"name\": \"simple-storage\", \"transport\": \"websockets\", \"filter\": { \"events\": \"blockchain_event_received\", \"message\": {}, \"transaction\": {}, \"blockchainevent\": { \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\" } }, \"options\": { \"firstEvent\": \"-1\", \"withData\": false }, \"created\": \"2022-03-15T17:35:30.131698921Z\", \"updated\": null } . ",
    "url": "/firefly/tutorials/custom_contracts.html#subscribe-to-events-from-our-contract",
    "relUrl": "/tutorials/custom_contracts.html#subscribe-to-events-from-our-contract"
  },"175": {
    "doc": "pages.custom_smart_contracts",
    "title": "Receive custom smart contract events",
    "content": "The last step is to connect a WebSocket client to FireFly to receive the event. You can use any WebSocket client you like, such as Postman or a command line app like websocat. Connect your WebSocket client to ws://localhost:5000 . After connecting the WebSocket client, send a message to tell FireFly to: . | Start sending events | For the Subscription named simple-storage | On the default namespace | Automatically “ack” each event which will let FireFly immediately send the next event when available | . { \"type\": \"start\", \"name\": \"simple-storage\", \"namespace\": \"default\", \"autoack\": true } . WebSocket event . After creating the subscription, you should see an event arrive on the connected WebSocket client that looks something like this: . { \"id\": \"0f4a31d6-9743-4537-82df-5a9c76ccbd1e\", \"sequence\": 24, \"type\": \"blockchain_event_received\", \"namespace\": \"default\", \"reference\": \"dd3e1554-c832-47a8-898e-f1ee406bea41\", \"created\": \"2022-03-15T17:32:27.824417878Z\", \"blockchainevent\": { \"id\": \"dd3e1554-c832-47a8-898e-f1ee406bea41\", \"sequence\": 7, \"source\": \"ethereum\", \"namespace\": \"default\", \"name\": \"Changed\", \"listener\": \"1bfa3b0f-3d90-403e-94a4-af978d8c5b14\", \"protocolId\": \"000000000010/000000/000000\", \"output\": { \"from\": \"0xb7e6a5eb07a75a2c81801a157192a82bcbce0f21\", \"value\": \"3\" }, \"info\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\", \"blockNumber\": \"10\", \"logIndex\": \"0\", \"signature\": \"Changed(address,uint256)\", \"subId\": \"sb-724b8416-786d-4e67-4cd3-5bae4a26eb0e\", \"timestamp\": \"1647365460\", \"transactionHash\": \"0xd5b5c716554097b2868d8705241bb2189bb76d16300f702ad05b0b02fccc4afb\", \"transactionIndex\": \"0x0\" }, \"timestamp\": \"2022-03-15T17:31:00Z\", \"tx\": { \"type\": \"\" } }, \"subscription\": { \"id\": \"f826269c-65ed-4634-b24c-4f399ec53a32\", \"namespace\": \"default\", \"name\": \"simple-storage\" } } . You can see in the event received over the WebSocket connection, the blockchain event that was emitted from our first transaction, which happened in the past. We received this event, because when we set up both the Listener, and the Subscription, we specified the \"firstEvent\" as \"oldest\". This tells FireFly to look for this event from the beginning of the blockchain, and that your app is interested in FireFly events since the beginning of FireFly’s event history. In the event, we can also see the blockchainevent itself, which has an output object. These are the params in our FireFly Interface, and the actual output of the event. Here we can see the value is 3 which is what we set the integer to in our original transaction. You’ve reached the end of the main guide to working with custom smart contracts in FireFly. Hopefully this was helpful and gives you what you need to get up and running with your own contracts. There are several additional ways to invoke or query smart contracts detailed below, so feel free to keep reading if you’re curious. ",
    "url": "/firefly/tutorials/custom_contracts.html#receive-custom-smart-contract-events",
    "relUrl": "/tutorials/custom_contracts.html#receive-custom-smart-contract-events"
  },"176": {
    "doc": "pages.custom_smart_contracts",
    "title": "Appendix I: Work with a custom contract without creating a named API",
    "content": "FireFly aims to offer a developer-friendly and flexible approach to using custom smart contracts. The guide above has detailed the most robust and feature-rich way to use custom contracts with FireFly, but there are several alternative API usage patterns available as well. It is possible to broadcast a contract interface and use a smart contract that implements that interface without also broadcasting a named API as above. There are several key differences (which may or may not be desirable) compared to the method outlined in the full guide above: . | OpenAPI Spec and Swagger UI are not available | Each HTTP request to invoke/query the contract will need to include the contract location | The contract location will not have been broadcasted to all other members of the network | The URL to invoke/query the contract will be different (described below) | . Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/interfaces/8bdd27a5-67c1-4960-8d1e-7aa31b9084d3/invoke/set . { \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"input\": { \"newValue\": 7 } } . Response . { \"id\": \"f310fa4a-73d8-4777-9f9d-dfa5012a052f\" } . All of the same invoke, query, and subscribe endpoints are available on the contract interface itself. ",
    "url": "/firefly/tutorials/custom_contracts.html#appendix-i-work-with-a-custom-contract-without-creating-a-named-api",
    "relUrl": "/tutorials/custom_contracts.html#appendix-i-work-with-a-custom-contract-without-creating-a-named-api"
  },"177": {
    "doc": "pages.custom_smart_contracts",
    "title": "Appendix II: Work directly with contracts with inline requests",
    "content": "The final way of working with custom smart contracts with FireFly is to just put everything FireFly needs all in one request, each time a contract is invoked or queried. This is the most lightweight, but least feature-rich way of using a custom contract. To do this, we will need to put both the contract location, and a subset of the FireFly Interface that describes the method we want to invoke in the request body, in addition to the function input. Request . POST http://localhost:5000/api/v1/namespaces/default/contracts/invoke . { \"location\": { \"address\": \"0xa5ea5d0a6b2eaf194716f0cc73981939dca26da1\" }, \"method\": { \"name\": \"set\", \"params\": [ { \"name\": \"x\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\" } } } ], \"returns\": [] }, \"input\": { \"x\": 42 } } . Response . { \"id\": \"386d3e23-e4bc-4a9b-bc1f-452f0a8c9ae5\" } . ",
    "url": "/firefly/tutorials/custom_contracts.html#appendix-ii-work-directly-with-contracts-with-inline-requests",
    "relUrl": "/tutorials/custom_contracts.html#appendix-ii-work-directly-with-contracts-with-inline-requests"
  },"178": {
    "doc": "pages.custom_smart_contracts",
    "title": "pages.custom_smart_contracts",
    "content": " ",
    "url": "/firefly/tutorials/custom_contracts.html",
    "relUrl": "/tutorials/custom_contracts.html"
  },"179": {
    "doc": "pages.private_data_exchange",
    "title": "Private data exchange",
    "content": " ",
    "url": "/firefly/overview/data_exchange.html#private-data-exchange",
    "relUrl": "/overview/data_exchange.html#private-data-exchange"
  },"180": {
    "doc": "pages.private_data_exchange",
    "title": "Table of contents",
    "content": ". | Introduction | Qualities of service | FireFly OSS implementation | . ",
    "url": "/firefly/overview/data_exchange.html#table-of-contents",
    "relUrl": "/overview/data_exchange.html#table-of-contents"
  },"181": {
    "doc": "pages.private_data_exchange",
    "title": "Introduction",
    "content": "Private data exchange is the way most enterprise business-to-business communication happens today. One party private sends data to another, over a pipe that has been agreed as sufficiently secure between the two parties. That might be a REST API, SOAP Web Service, FTP / EDI, Message Queue (MQ), or other B2B Gateway technology. The ability to perform these same private data exchanges within a multi-party system is critical. In fact it’s common for the majority of business data continue to transfer over such interfaces. So real-time application to application private messaging, and private transfer of large blobs/documents, are first class constructs in the FireFly API. ",
    "url": "/firefly/overview/data_exchange.html#introduction",
    "relUrl": "/overview/data_exchange.html#introduction"
  },"182": {
    "doc": "pages.private_data_exchange",
    "title": "Qualities of service",
    "content": "FireFly recognizes that a multi-party system will need to establish a secure messaging backbone, with the right qualities of service for their requirements. So the implementation is pluggable, and the plugin interface embraces the following quality of service characteristics that differ between different implementations. | Transport Encryption . | Technologies like TLS encrypt data while it is in flight, so that it cannot be sniffed by a third party that has access to the underlying network. | . | Authentication . | There are many technologies including Mutual TLS, and Java Web Tokens (JWT), that can be used to ensure a private data exchange is happening with the correct party in the system. | Most modern approaches use public/private key encryption to establish the identity during the setup phase of a connection. This means a distribution mechanism is required for public keys, which might be enhanced with a trust hierarchy (like PKI). | . | Request/Response (Sync) vs. Message Queuing (Async) . | Synchronous transports like HTTPS require both parties to be available at the time data is sent, and the transmission must be retried at the application (plugin) layer if it fails or times out. | Asynchronous transports like AMQP, MQTT or Kafka introduce one or more broker runtimes between the parties, that reliably buffer the communications if the target application falls behind or is temporarily unavailable. | . | Hub &amp; spoke vs. Peer to peer . | Connectivity might be direct from one party to another within the network, tackling the IT security complexity of firewalls between sensitive networks. Or network shared infrastructure / as-a-service provider might be used to provide a reliable backbone for data exchange between the members. | . | End-to-end Payload Encryption . | Particularly in cases where the networking hops are complex, or involve shared shared/third-party infrastructure, end-to-end encryption can be used to additionally protect the data while in flight. This technology means data remains encrypted from the source to the target, regardless of the number of transport hops taken in-between. | . | Large blob / Managed file transfer . | The optimal approach to transferring real-time small messages (KBs in size) is different to the approach to transferring large blobs (MBs/GBs in size). For large blobs chunking, compression, and checkpoint restart are common for efficient and reliable transfer. | . | . ",
    "url": "/firefly/overview/data_exchange.html#qualities-of-service",
    "relUrl": "/overview/data_exchange.html#qualities-of-service"
  },"183": {
    "doc": "pages.private_data_exchange",
    "title": "FireFly OSS implementation",
    "content": "A reference implementation of a private data exchange is provided as part of the FireFly project. This implementation uses peer-to-peer transfer over a synchronous HTTPS transport, backed by Mutual TLS authentication. X509 certificate exchange is orchestrated by FireFly, such that self-signed certificates can be used (or multiple PKI trust roots) and bound to the blockchain-backed identities of the organizations in FireFly. See hyperledger/firefly-dataexchange-https . ",
    "url": "/firefly/overview/data_exchange.html#firefly-oss-implementation",
    "relUrl": "/overview/data_exchange.html#firefly-oss-implementation"
  },"184": {
    "doc": "pages.private_data_exchange",
    "title": "pages.private_data_exchange",
    "content": " ",
    "url": "/firefly/overview/data_exchange.html",
    "relUrl": "/overview/data_exchange.html"
  },"185": {
    "doc": "DataRef",
    "title": "DataRef",
    "content": " ",
    "url": "/firefly/reference/types/dataref.html",
    "relUrl": "/reference/types/dataref.html"
  },"186": {
    "doc": "DataRef",
    "title": "Table of contents",
    "content": ". | DataRef . | Example | Field Descriptions | . | . ",
    "url": "/firefly/reference/types/dataref.html#table-of-contents",
    "relUrl": "/reference/types/dataref.html#table-of-contents"
  },"187": {
    "doc": "DataRef",
    "title": "DataRef",
    "content": "Example . { \"id\": \"5bea782a-6cf2-4e01-95ee-cb5fa05873e9\", \"hash\": \"8b7df143d91c716ecfa5fc1730022f6b421b05cedee8fd52b1fc65a96030ad52\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the referenced data resource | UUID | . | hash | The hash of the referenced data | Bytes32 | . ",
    "url": "/firefly/reference/types/dataref.html",
    "relUrl": "/reference/types/dataref.html"
  },"188": {
    "doc": "Define a datatype",
    "title": "Define a datatype",
    "content": " ",
    "url": "/firefly/tutorials/define_datatype.html",
    "relUrl": "/tutorials/define_datatype.html"
  },"189": {
    "doc": "Define a datatype",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info . | Example 1: Broadcast new datatype | . | Example message response | Lookup the confirmed data type | Example private send referring to the datatype | . ",
    "url": "/firefly/tutorials/define_datatype.html#table-of-contents",
    "relUrl": "/tutorials/define_datatype.html#table-of-contents"
  },"190": {
    "doc": "Define a datatype",
    "title": "Quick reference",
    "content": "As your use case matures, it is important to agree formal datatypes between the parties. These canonical datatypes need to be defined and versioned, so that each member can extract and transform data from their internal systems into this datatype. Datatypes are broadcast to the network so everybody refers to the same JSON schema when validating their data. The broadcast must complete before a datatype can be used by an application to upload/broadcast/send data. The same system of broadcast within FireFly is used to broadcast definitions of datatypes, as is used to broadcast the data itself. ",
    "url": "/firefly/tutorials/define_datatype.html#quick-reference",
    "relUrl": "/tutorials/define_datatype.html#quick-reference"
  },"191": {
    "doc": "Define a datatype",
    "title": "Additional info",
    "content": ". | Key Concepts: Broadcast / shared data | Swagger: POST /api/v1/namespaces/{ns}/datatypes | . Example 1: Broadcast new datatype . POST /api/v1/namespaces/{ns}/broadcast/datatype . { \"name\": \"widget\", \"version\": \"0.0.2\", \"value\": { \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } } } } . ",
    "url": "/firefly/tutorials/define_datatype.html#additional-info",
    "relUrl": "/tutorials/define_datatype.html#additional-info"
  },"192": {
    "doc": "Define a datatype",
    "title": "Example message response",
    "content": "Status: 202 Accepted - a broadcast message has been sent, and on confirmation the new datatype will be created (unless it conflicts with another definition with the same name and version that was ordered onto the blockchain before this definition). Issue #112 proposes adding an option to wait for the message to be confirmed by the blockchain before returning, with 200 OK. { \"header\": { \"id\": \"727f7d3a-d07e-4e80-95af-59f8d2ac7531\", // this is the ID of the message, not the data type \"type\": \"definition\", // a special type for system broadcasts \"txtype\": \"batch_pin\", // the broadcast is pinned to the chain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // the local identity \"created\": \"2021-07-01T21:06:26.9997478Z\", // the time the broadcast was sent \"namespace\": \"ff_system\", // the data/message broadcast happens on the system namespace \"topic\": [ \"ff_ns_default\" // the namespace itself is used in the topic ], \"tag\": \"ff_define_datatype\", // a tag instructing FireFly to process this as a datatype definition \"datahash\": \"56bd677e3e070ba62f547237edd7a90df5deaaf1a42e7d6435ec66a587c14370\" }, \"hash\": \"5b6593720243831ba9e4ad002c550e95c63704b2c9dbdf31135d7d9207f8cae8\", \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ { \"id\": \"7539a0ab-78d8-4d42-b283-7e316b3afed3\", // this data object in the ff_system namespace, contains the schema \"hash\": \"22ba1cdf84f2a4aaffac665c83ff27c5431c0004dc72a9bf031ae35a75ac5aef\" } ] } . ",
    "url": "/firefly/tutorials/define_datatype.html#example-message-response",
    "relUrl": "/tutorials/define_datatype.html#example-message-response"
  },"193": {
    "doc": "Define a datatype",
    "title": "Lookup the confirmed data type",
    "content": "GET /api/v1/namespaces/default/datatypes?name=widget&amp;version=0.0.2 . [ { \"id\": \"421c94b1-66ce-4ba0-9794-7e03c63df29d\", // an ID allocated to the datatype \"message\": \"727f7d3a-d07e-4e80-95af-59f8d2ac7531\", // the message that broadcast this data type \"validator\": \"json\", // the type of validator that this datatype can be used for (this one is JSON Schema) \"namespace\": \"default\", // the namespace of the datatype \"name\": \"widget\", // the name of the datatype \"version\": \"0.0.2\", // the version of the data type \"hash\": \"a4dceb79a21937ca5ea9fa22419011ca937b4b8bc563d690cea3114af9abce2c\", // hash of the schema itself \"created\": \"2021-07-01T21:06:26.983986Z\", // time it was confirmed \"value\": { // the JSON schema itself \"$id\": \"https://example.com/widget.schema.json\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema\", \"title\": \"Widget\", \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"The unique identifier for the widget.\" }, \"name\": { \"type\": \"string\", \"description\": \"The person's last name.\" } } } } ] . ",
    "url": "/firefly/tutorials/define_datatype.html#lookup-the-confirmed-data-type",
    "relUrl": "/tutorials/define_datatype.html#lookup-the-confirmed-data-type"
  },"194": {
    "doc": "Define a datatype",
    "title": "Example private send referring to the datatype",
    "content": "Once confirmed, a piece of data can be assigned that datatype and all FireFly nodes will verify it against the schema. On a sending node, the data will be rejected at upload/send time if it does not conform. On other nodes, bad data results in a message_rejected event (rather than message_confirmed) for any message that arrives referring to that data. POST /api/v1/namespaces/default/send/message . { \"header\": { \"tag\": \"new_widget_created\", \"topic\": [\"widget_id_12345\"] }, \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] }, \"data\": [ { \"datatype\": { \"name\": \"widget\", \"version\": \"0.0.2\" }, \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/tutorials/define_datatype.html#example-private-send-referring-to-the-datatype",
    "relUrl": "/tutorials/define_datatype.html#example-private-send-referring-to-the-datatype"
  },"195": {
    "doc": "Deterministic compute",
    "title": "Deterministic compute",
    "content": " ",
    "url": "/firefly/overview/deterministic_compute.html",
    "relUrl": "/overview/deterministic_compute.html"
  },"196": {
    "doc": "Deterministic compute",
    "title": "Table of contents",
    "content": ". | Introduction | The fundamental building blocks | Advanced Cryptography and Privacy Preserving Trusted Compute | Complementary approaches to deterministic computation | . ",
    "url": "/firefly/overview/deterministic_compute.html#table-of-contents",
    "relUrl": "/overview/deterministic_compute.html#table-of-contents"
  },"197": {
    "doc": "Deterministic compute",
    "title": "Introduction",
    "content": "A critical aspect of designing a multi-party systems, is choosing where you exploit the blockchain and other advanced cryptography technology to automate agreement between parties. Specifically where you rely on the computation itself to come up with a result that all parties can independently trust. For example because all parties performed the same computation independently and came up with the same result, against the same data, and agreed to that result using a consensus algorithm. The more sophisticated the agreement is you want to prove, the more consideration needs to be taken into factors such as: . | Data privacy | Data deletion | Ease of understanding by business users | Ease of audit | Autonomy of parties with proprietary business logic | Human workflows (obviously non-deterministic) | Technology complexity/maturity (particularly for privacy preserving technologies) | Cost and skills for implementation | . FireFly embraces the fact that different use cases, will make different decisions on how much of the agreement should be enforced through deterministic compute. Also that multi-party systems include a mixture of approaches in addition to deterministic compute, including traditional off-chain secure HTTP/Messaging, documents, private non-deterministic logic, and human workflows. ",
    "url": "/firefly/overview/deterministic_compute.html#introduction",
    "relUrl": "/overview/deterministic_compute.html#introduction"
  },"198": {
    "doc": "Deterministic compute",
    "title": "The fundamental building blocks",
    "content": "There are some fundamental types of deterministic computation, that can be proved with mature blockchain technology, and all multi-party systems should consider exploiting: . | Total conservation of value . | Allows you to assign value to something, because you know it is a fraction of a total pool | This is the magic behind fungible tokens, or “coins” | The proven technology for this is a shared ledger of all previous transactions | Learn more in the Tokens section | . | Existence and ownership of a unique identifiable thing . | Gives you an anchor to attach to something in the real world | This is the magic behind non-fungible tokens (NTFs) | The proven technology for this is a shared ledger of its creation, and ownership changes | Learn more in the Tokens section | . | An agreed sequence of events . | The foundation tool that allows the building of higher level constructs (including tokens) | Not previously available when business ecosystems used HTTP/Messaging transports alone | Can be bi-lateral, multi-lateral or global | Each blockchain technology has different features to establish these “chains” of information | Different approaches provide privacy different levels of privacy on the parties and sequence | . | Identification of data by a “hash” of its contents . | The glue that binds a piece of private data, to a proof that you have a copy of that data | This is the basis of “pinning” data to the blockchain, without sharing its contents | Care needs to be taken to make sure the data is unique enough to make the hash secure | Learn more in the On-chain/off-chain coordination section | . | . ",
    "url": "/firefly/overview/deterministic_compute.html#the-fundamental-building-blocks",
    "relUrl": "/overview/deterministic_compute.html#the-fundamental-building-blocks"
  },"199": {
    "doc": "Deterministic compute",
    "title": "Advanced Cryptography and Privacy Preserving Trusted Compute",
    "content": "There are use cases where a deterministic agreement on computation is desired, but the data upon which the execution is performed cannot be shared between all the parties. For example proving total conservation of value in a token trading scenario, without knowing who is involved in the individual transactions. Or providing you have access to a piece of data, without disclosing what that data is. Technologies exist that can solve these requirements, with two major categories: . | Zero Knowledge Proofs (ZKPs) . | Advanced cryptography techniques that allow one party to generate a proof that can be be verified by another party, without access to the data used to generate the proof. | . | Trusted Compute Environments (TEEs) . | Secure compute environments that provide proofs of what code was executed, such that other parties can be confident of the logic that was executed without having access to the data. | . | . FireFly today provides an orchestration engine that’s helpful in coordinating the inputs, outputs, and execution of such advanced cryptography technologies. Active collaboration between the FireFly and other projects like Hyperledger Avalon, and Hyperledger Cactus, is evolving how these technologies can plug-in with higher level patterns. ",
    "url": "/firefly/overview/deterministic_compute.html#advanced-cryptography-and-privacy-preserving-trusted-compute",
    "relUrl": "/overview/deterministic_compute.html#advanced-cryptography-and-privacy-preserving-trusted-compute"
  },"200": {
    "doc": "Deterministic compute",
    "title": "Complementary approaches to deterministic computation",
    "content": "Enterprise multi-party systems usually operate differently to end-user decentralized applications. In particular, strong identity is established for the organizations that are involved, and those organizations usually sign legally binding commitments around their participation in the network. Those businesses then bring on-board an ecosystem of employees and or customers that are end-users to the system. So the shared source of truth empowered by the blockchain and other cryptography are not the only tools that can be used in the toolbox to ensure correct behavior. Regognizing that there are real legal entities involved, that are mature and regulated, does not undermine the value of the blockchain components. In fact it enhances it. A multi-party system can use just enough of this secret sauce in the right places, to change the dynamics of trust such that competitors in a market are willing to create value together that could never be created before. Or create a system where parties can share data with each other while still conforming to their own regulatory and audit commitments, that previously would have been impossible to share. Not to be overlooked is the sometimes astonishing efficiency increase that can be added to existing business relationships, by being able to agree the order and sequence of a set of events. Having the tools to digitize processes that previously took physical documents flying round the world, into near-immediate digital agreement where the arbitration of a dispute can be resolved at a tiny fraction of what would have been possible without a shared and immutable audit trail of who said what when. ",
    "url": "/firefly/overview/deterministic_compute.html#complementary-approaches-to-deterministic-computation",
    "relUrl": "/overview/deterministic_compute.html#complementary-approaches-to-deterministic-computation"
  },"201": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Setting up a FireFly Core Development Environment",
    "content": " ",
    "url": "/firefly/contributors/dev_environment_setup.html",
    "relUrl": "/contributors/dev_environment_setup.html"
  },"202": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Table of contents",
    "content": ". | Setting up a FireFly Core Development Environment . | Dependencies . | Installing GO and setting up your GOPATH | . | Building FireFly | Install the CLI | Set up a development stack . | Start the stack | 1) From another terminal | 2) Using an IDE | . | . | . This guide will walk you through setting up your machine for contributing to FireFly, specifically the FireFly core. ",
    "url": "/firefly/contributors/dev_environment_setup.html#table-of-contents",
    "relUrl": "/contributors/dev_environment_setup.html#table-of-contents"
  },"203": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Dependencies",
    "content": "You will need a few prerequisites set up on your machine before you can build FireFly from source. We recommend doing development on macOS, Linux, or WSL 2.0. | Go (1.16 or newer) | make | GCC | openssl | . Installing GO and setting up your GOPATH . We recommend following the instructions on golang.org to install Go, rather than installing Go from another package magager such as brew. Although it is possible to install Go any way you’d like, setting up your GOPATH may differ from the following instructions. After installing Go, you will need to add a few environment variables to your shell run commands file. This is usually a hidden file in your home directory called .bashrc or .zshrc, depending on which shell you’re using. Add the following lines to your .bashrc or .zshrc file: . export GOPATH=$HOME/go export GOROOT=\"/usr/local/go\" export PATH=\"$PATH:${GOPATH}/bin:${GOROOT}/bin\" . The FireFly CLI is the recommended path for running a local development stack. It has its own set of prerequisites as well. ",
    "url": "/firefly/contributors/dev_environment_setup.html#dependencies",
    "relUrl": "/contributors/dev_environment_setup.html#dependencies"
  },"204": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Building FireFly",
    "content": "After installing dependencies, building FireFly from source is very easy. Just clone the repo: . git clone git@github.com:hyperledger/firefly.git &amp;&amp; cd firefly . And run the Makefile to run tests, and compile the app . make . If you want to install the binary on your path (assuming your Go Home is already on your path), from inside the project directory you can simply run: . go install . ",
    "url": "/firefly/contributors/dev_environment_setup.html#building-firefly",
    "relUrl": "/contributors/dev_environment_setup.html#building-firefly"
  },"205": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Install the CLI",
    "content": "Please check the CLI Installation instructions for the best way to install the CLI on your machine: https://github.com/hyperledger/firefly-cli#install-the-cli . ",
    "url": "/firefly/contributors/dev_environment_setup.html#install-the-cli",
    "relUrl": "/contributors/dev_environment_setup.html#install-the-cli"
  },"206": {
    "doc": "Setting up a FireFly Core Development Environment",
    "title": "Set up a development stack",
    "content": "Now that you have both FireFly and the FireFly CLI installed, it’s time to create a development stack. The CLI can be used to create a docker-compose environment that runs the entirety of a FireFly network. This will include several different processes for each member of the network. This is very useful for people that want to build apps that use FireFly’s API. It can also be useful if you want to make changes to FireFly itself, however we need to set up the stack slightly differently in that case. Essentially what we are going to do is have docker-compose run everything in the FireFly network except one FireFly core process. We’ll run this FireFly core process on our host machine, and configure it to connect to the rest of the microservices running in docker-compose. This means we could launch FireFly from Visual Studio Code or some other IDE and use a debugger to see what’s going on inside FireFly as it’s running. We’ll call this stack dev. We’re also going to add --external 1 to the end of our command to create the new stack: . ff init dev --external 1 . This tells the CLI that we want to manage one of the FireFly core processes outside the docker-compose stack. For convenience, the CLI will still generate a config file for this process though. Start the stack . To start your new stack simply run: . ff start dev . At a certain point in the startup process, the CLI will pause and wait for up to two minutes for you to start the other FireFly node. There are two different ways you can run the extenral FireFly core process. 1) From another terminal . The CLI will print out the command line which can be copied and pasted into another terminal window to run FireFly. This command should be run from the firefly core project directory. Here is an example of the command that the CLI will tell you to run: ./firefly -f ~/.stacks/firefly/dev/configs/firefly_core_0.yml . NOTE: The first time you run FireFly with a fresh database, it will need a directory of database migrations to apply to the empty database. If you run FireFly from the firefly project directory you cloned from GitHub, it will automatically find these and apply them. If you run it from some other directory, you will have to point FireFly to the migrations on your own. 2) Using an IDE . If you named your stack dev there is a launch.json file for Visual Studio code already in the project directory. If you have the project open in Visual Studio Code, you can either press the F5 key to run it, or go to the “Run and Debug” view in Visual Studio code, and click “Run FireFly Core”. Now you should have a full FireFly stack up and running, and be able to debug FireFly using your IDE. Happy hacking! . NOTE: Because firefly-ui is a separate repo, unless you also start a UI dev server for the external FireFly core, the default UI path will not load. This is expected, and if you’re just working on FireFly core itself, you don’t need to worry about it.` . ",
    "url": "/firefly/contributors/dev_environment_setup.html#set-up-a-development-stack",
    "relUrl": "/contributors/dev_environment_setup.html#set-up-a-development-stack"
  },"207": {
    "doc": "Contributing to Documentation",
    "title": "Contributing to Documentation",
    "content": " ",
    "url": "/firefly/contributors/docs_setup.html",
    "relUrl": "/contributors/docs_setup.html"
  },"208": {
    "doc": "Contributing to Documentation",
    "title": "Table of contents",
    "content": ". | Contributing to Documentation . | Process for updating documentation | Dependencies . | macOS | Linux | . | Build and serve the docs locally | . | . This guide will walk you through setting up your machine for contributing to FireFly documentation. Documentation contributions are extremely valuable. If you discover something is missing in the docs, we would love to include your additions or clarifications to help the next person who has the same question. This doc site is generated by a set of Markdown files in the main FireFly repository, under the ./docs directory. You can browse the source for the current live site in GitHub here: https://github.com/hyperledger/firefly/tree/main/docs . ",
    "url": "/firefly/contributors/docs_setup.html#table-of-contents",
    "relUrl": "/contributors/docs_setup.html#table-of-contents"
  },"209": {
    "doc": "Contributing to Documentation",
    "title": "Process for updating documentation",
    "content": "The process for updating the documentation is really easy! You’ll follow the same basic steps outlined in the same steps outlined in the Contributor’s guide. Here are the detailed steps for contributing to the docs: . | Fork https://github.com/hyperledger/firefly | Clone your fork locally to your computer | Follow the steps below to view your local copy of the docs in a browser | Make some improvements to the Markdown files | Verify that your changes look they way you want them to in your browser | Create a new git commit with your changes. Be sure to sign-off on your commit by using git commit -s! | Push your changes | Open a Pull Request to incorporate your changes back into the hyperledger/firefly repo | . ",
    "url": "/firefly/contributors/docs_setup.html#process-for-updating-documentation",
    "relUrl": "/contributors/docs_setup.html#process-for-updating-documentation"
  },"210": {
    "doc": "Contributing to Documentation",
    "title": "Dependencies",
    "content": "The FireFly docs site uses GitHub pages, which uses a tool called Jekyll to convert Markdown files into HTML files that can be read in your browser. Basically that means in order to build and view the pages locally on your machine, you need to have Jekyll. Jekyll is a Ruby app, so you’ll also need to have Ruby, and the Ruby bundler app to install Jekyll’s dependencies. The good news is these things are very easy to set up. macOS . If you’re using an Intel Mac, you are already good to go! macOS already comes with ruby and bundle installed and set up already. You don’t need to do anything extra. However, it may be advisable to install a newer version of Ruby anyway. NOTE: From the macOS Catalina 10.15 Release Notes: Scripting language runtimes such as Python, Ruby, and Perl are included in macOS for compatibility with legacy software. Future versions of macOS won’t include scripting language runtimes by default, and might require you to install additional packages. If your software depends on scripting languages, it’s recommended that you bundle the runtime within the app. (49764202) . If you’re using an Apple Silicon based Mac, the version of Ruby that comes with macOS supports both Intel and ARM binaries which unfortunately ends up causing some problems when installing certain gems. We recommend installing Ruby with brew and setting it on your path. This will also give you a newer version of Ruby. To do this, run: . brew install ruby echo 'export PATH=\"/opt/homebrew/opt/ruby/bin:$PATH\"' &gt;&gt; ~/.zshrc . Linux . You will need to install ruby and bundle and have them on your path to build and serve the docs locally. On Ubuntu, to install these, run the following commands: . sudo apt-get update sudo apt-get install ruby ruby-bundler . ",
    "url": "/firefly/contributors/docs_setup.html#dependencies",
    "relUrl": "/contributors/docs_setup.html#dependencies"
  },"211": {
    "doc": "Contributing to Documentation",
    "title": "Build and serve the docs locally",
    "content": "To build and serve the docs locally, from the project root, navigate to the docs directory: . cd docs . Install docs dependencies: . bundle install . And start the Jekyll test server: . bundle exec jekyll serve --livereload . You should now be able to open http://127.0.0.1:4000/firefly/index.html in your browser and see a locally hosted version of the doc site. As you make changes to files in the ./docs directory, Jekyll will automatically rebuild the pages, and notify you of any errors or warnings in your terminal. If you have a browser open, it will automatically reload when changes are made to pages. ",
    "url": "/firefly/contributors/docs_setup.html#build-and-serve-the-docs-locally",
    "relUrl": "/contributors/docs_setup.html#build-and-serve-the-docs-locally"
  },"212": {
    "doc": "ERC-1155",
    "title": "Use ERC-1155 tokens",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc1155.html#use-erc-1155-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#use-erc-1155-tokens"
  },"213": {
    "doc": "ERC-1155",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | Create a stack with an ERC-1155 connector | Use the Sandbox (optional) | Create a pool | Mint tokens | Transfer tokens | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc1155.html#table-of-contents"
  },"214": {
    "doc": "ERC-1155",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the Getting Started guide and read the section on how to Install the FireFly CLI. ← ① Install the FireFly CLI . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/tutorials/tokens/erc1155.html#previous-steps-install-the-firefly-cli"
  },"215": {
    "doc": "ERC-1155",
    "title": "Create a stack with an ERC-1155 connector",
    "content": "The default Token Connector that the FireFly CLI sets up is for ERC-20 and ERC-721. If you would like to work with ERC-1155 tokens, you need to create a stack that is configured to use that Token Connector. To do that, run: . ff init -t erc-1155 . Then run: . ff start &lt;your_stack_name&gt; . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#create-a-stack-with-an-erc-1155-connector",
    "relUrl": "/tutorials/tokens/erc1155.html#create-a-stack-with-an-erc-1155-connector"
  },"216": {
    "doc": "ERC-1155",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox to http://localhost:3000/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/tutorials/tokens/erc1155.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc1155.html#use-the-sandbox-optional"
  },"217": {
    "doc": "ERC-1155",
    "title": "Create a pool",
    "content": "After you stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type (fungible or nonfungible) for the pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\" } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc1155.html#create-a-pool"
  },"218": {
    "doc": "ERC-1155",
    "title": "Mint tokens",
    "content": "Once you have a token pool, you can mint tokens within it. With the default firefly-tokens-erc1155 connector, only the creator of a pool is allowed to mint - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": 10 } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#mint-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#mint-tokens"
  },"219": {
    "doc": "ERC-1155",
    "title": "Transfer tokens",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With the default firefly-tokens-erc1155 connector, only the owner of a token may transfer it away - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\" } . NOTE: When transferring a non-fungible token, the amount must always be 1. The tokenIndex field is also required when transferring a non-fungible token. Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#transfer-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#transfer-tokens"
  },"220": {
    "doc": "ERC-1155",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/tutorials/tokens/erc1155.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc1155.html#sending-data-with-a-transfer"
  },"221": {
    "doc": "ERC-1155",
    "title": "Burn tokens",
    "content": "You may burn tokens by simply specifying an amount. With the default firefly-tokens-erc1155 connector, only the owner of a token may burn it - but each connector may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, } . NOTE: When burning a non-fungible token, the amount must always be 1. The tokenIndex field is also required when burning a non-fungible token. Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc1155.html#burn-tokens"
  },"222": {
    "doc": "ERC-1155",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer any amount of tokens from my wallet . Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\" } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc1155\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" } } . ",
    "url": "/firefly/tutorials/tokens/erc1155.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc1155.html#token-approvals"
  },"223": {
    "doc": "ERC-1155",
    "title": "ERC-1155",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc1155.html",
    "relUrl": "/tutorials/tokens/erc1155.html"
  },"224": {
    "doc": "ERC-20",
    "title": "Use ERC-20 tokens",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc20.html#use-erc-20-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#use-erc-20-tokens"
  },"225": {
    "doc": "ERC-20",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Use the built in sample token factory | Use the Sandbox (optional) | Create a pool . | Request | Response | Get the address of the deployed contract . | Request | Response | . | Create a pool for an existing contract | . | Mint tokens . | Request | Response | . | Transfer tokens . | Request | Response | . | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | Use Metamask . | Configure a new network | Import tokens | Transfer tokens | . | . ",
    "url": "/firefly/tutorials/tokens/erc20.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc20.html#table-of-contents"
  },"226": {
    "doc": "ERC-20",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go to the Getting Started guide on how to Start your environment. This will set up a token connector that works with both ERC-20 and ERC-721 by default. ← ② Start your environment . ",
    "url": "/firefly/tutorials/tokens/erc20.html#previous-steps-start-your-environment",
    "relUrl": "/tutorials/tokens/erc20.html#previous-steps-start-your-environment"
  },"227": {
    "doc": "ERC-20",
    "title": "Use the built in sample token factory",
    "content": "If you are using the default ERC-20 / ERC-721 token connector, when the FireFly CLI set up your FireFly stack, it also deployed a token factory contract. When you create a token pool through FireFly’s token APIs, the token factory contract will automatically deploy an ERC-20 or ERC-721 contract, based on the pool type in the API request. ⚠️ WARNING: The default token contract that was deployed by the FireFly CLI is only provided for the purpose of learning about FireFly. It is not a production grade contract. If you intend to deploy a production application using tokens FireFly you should research token contract best practices. For details, please see the source code for the contract that was deployed. ",
    "url": "/firefly/tutorials/tokens/erc20.html#use-the-built-in-sample-token-factory",
    "relUrl": "/tutorials/tokens/erc20.html#use-the-built-in-sample-token-factory"
  },"228": {
    "doc": "ERC-20",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox at http://127.0.0.1:5109/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/tutorials/tokens/erc20.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc20.html#use-the-sandbox-optional"
  },"229": {
    "doc": "ERC-20",
    "title": "Create a pool",
    "content": "After your stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type for the pool. If you’re using the default ERC-20 / ERC-721 token connector and its sample token factory, it will automatically deploy a new token contract, based on the type in the request to create the token pool. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\" } . Response . { \"id\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"type\": \"fungible\", \"namespace\": \"default\", \"name\": \"testpool\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"connector\": \"erc20_erc721\", \"tx\": { \"type\": \"token_pool\", \"id\": \"e901921e-ffc4-4776-b20a-9e9face70a47\" } } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . Get the address of the deployed contract . To lookup the address of the new contract, you can lookup the Token Pool by its ID on the API. Creating the token pool will also emit an event which will contain the address. To query the token pool you can make a GET request to the pool’s ID: . Request . GET http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools/5811e8d5-52d0-44b1-8b75-73f5ff88f598 . Response . { \"id\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"type\": \"fungible\", \"namespace\": \"default\", \"name\": \"testpool\", \"standard\": \"ERC20\", \"locator\": \"address=0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c&amp;schema=ERC20WithData&amp;type=fungible\", \"decimals\": 18, \"connector\": \"erc20_erc721\", \"message\": \"7e2f6004-31fd-4ba8-9845-15c5fe5fbcd7\", \"state\": \"confirmed\", \"created\": \"2022-04-28T14:03:16.732222381Z\", \"info\": { \"address\": \"0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c\", \"name\": \"testpool\", \"schema\": \"ERC20WithData\" }, \"tx\": { \"type\": \"token_pool\", \"id\": \"e901921e-ffc4-4776-b20a-9e9face70a47\" } } . Create a pool for an existing contract . If you wish to use a contract that is already on the chain, you can pass the address in a config object with an address when you make the request to create the Token Pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\", \"config\": { \"address\": \"0xb1C845D32966c79E23f733742Ed7fCe4B41901FC\" } } . ",
    "url": "/firefly/tutorials/tokens/erc20.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc20.html#create-a-pool"
  },"230": {
    "doc": "ERC-20",
    "title": "Mint tokens",
    "content": "Once you have a token pool, you can mint tokens within it. With a token contract deployed by the default token factory, only the creator of a pool is allowed to mint, but a different contract may define its own permission model. NOTE: The default token factory creates an ERC-20 with 18 decimal places. This means that if you want to create 100 tokens, the number submitted to the API / blockchain should actually be 100×1018 = 100000000000000000000. This allows users to work with “fractional” tokens even though Ethereum virtual machines only support integer arithmetic. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": \"100000000000000000000\" } . Response . { \"type\": \"mint\", \"localId\": \"835fe2a1-594b-4336-bc1d-b2f59d51064b\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"amount\": \"100000000000000000000\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"3fc97e24-fde1-4e80-bd82-660e479c0c43\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc20.html#mint-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#mint-tokens"
  },"231": {
    "doc": "ERC-20",
    "title": "Transfer tokens",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With a token contract deployed by the default token factory, only the owner of the tokens or another approved account may transfer their tokens, but a different contract may define its own permission model. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": \"10000000000000000000\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\" } . Response . { \"type\": \"transfer\", \"localId\": \"61f0a71f-712b-4778-8b37-784fbee52657\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\", \"amount\": \"10000000000000000000\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"c0c316a3-23a9-42f3-89b3-1cfdba6c948d\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc20.html#transfer-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#transfer-tokens"
  },"232": {
    "doc": "ERC-20",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/tutorials/tokens/erc20.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc20.html#sending-data-with-a-transfer"
  },"233": {
    "doc": "ERC-20",
    "title": "Burn tokens",
    "content": "You may burn tokens by simply specifying an amount. With a token contract deployed by the default token factory, only the owner of a token may burn it, but a different contract may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc20.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc20.html#burn-tokens"
  },"234": {
    "doc": "ERC-20",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | config.allowance: The number of tokens the other account is allowed to transfer. If 0 or not set, the approval is valid for any number. | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer up to 10×1018 (10000000000000000000) tokens from my wallet . Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"config\": { \"allowance\": \"10000000000000000000\" } } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" }, \"config\": { \"allowance\": \"10000000000000000000\" } } . ",
    "url": "/firefly/tutorials/tokens/erc20.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc20.html#token-approvals"
  },"235": {
    "doc": "ERC-20",
    "title": "Use Metamask",
    "content": "Now that you have an ERC-20 contract up and running, you may be wondering how to use Metamask (or some other wallet) with this contract. This section will walk you through how to connect Metamask to the blockchain and token contract that FireFly is using. Configure a new network . The first thing we need to do is tell Metamask how to connect to our local blockchain node. To do that: . | Click your account icon | In the drop down menu, click Settings . | On the left hand side of the page, click Networks | Click the Add a network button . | Fill in the network details: . | Network Name: FireFly (could be any name) | New RPC URL: http://127.0.0.1:5100 | Chain ID: 2021 | Currency Symbol: ETH | . | Click Save | . Import tokens . Metamask won’t know about our custom ERC-20 contract until we give it the Ethereum address for the contract, so that’s what we’ll do next. | Click on Import tokens . | Enter the Ethereum address of the contract | Enter a Token Symbol (can be anything you want) | Click Add Custom Token | . NOTE: You can find the address of your contract from the response to the request to create the token pool above. You can also do a GET to http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools to lookup your configured token pools. Transfer tokens . Now you can copy your account address from your Metamask wallet, and perform a transfer from FireFly’s API (as described above) to your Metamask address. After a couple seconds, you should see your tokens show up in your Metamask wallet. You can also send tokens to a FireFly address or any other Ethereum address from your Metamask wallet. NOTE: You can find the Ethereum addresses for organizations in your FireFly network in the Network → Organizations page in the FireFly explorer. Click on an organization and look under the Verifiers header for the organization’s Ethereum address. ",
    "url": "/firefly/tutorials/tokens/erc20.html#use-metamask",
    "relUrl": "/tutorials/tokens/erc20.html#use-metamask"
  },"236": {
    "doc": "ERC-20",
    "title": "ERC-20",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc20.html",
    "relUrl": "/tutorials/tokens/erc20.html"
  },"237": {
    "doc": "ERC-721",
    "title": "Use ERC-721 tokens",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc721.html#use-erc-721-tokens",
    "relUrl": "/tutorials/tokens/erc721.html#use-erc-721-tokens"
  },"238": {
    "doc": "ERC-721",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Use the built in sample token factory | Use the Sandbox (optional) | Create a pool . | Request | Response | Get the address of the deployed contract . | Request | Response | . | Create a pool for an existing contract | . | Mint a token . | Request | Response | . | Transfer a token . | Request | Response | . | Sending data with a transfer . | Broadcast message | Private message | . | Burn tokens | Token approvals . | Request | Response | . | Use Metamask . | Configure a new network | Import tokens | Transfer tokens | . | . ",
    "url": "/firefly/tutorials/tokens/erc721.html#table-of-contents",
    "relUrl": "/tutorials/tokens/erc721.html#table-of-contents"
  },"239": {
    "doc": "ERC-721",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go to the Getting Started guide on how to Start your environment. This will set up a token connector that works with both ERC-20 and ERC-721 by default. ← ② Start your environment . ",
    "url": "/firefly/tutorials/tokens/erc721.html#previous-steps-start-your-environment",
    "relUrl": "/tutorials/tokens/erc721.html#previous-steps-start-your-environment"
  },"240": {
    "doc": "ERC-721",
    "title": "Use the built in sample token factory",
    "content": "If you are using the default ERC-20 / ERC-721 token connector, when the FireFly CLI set up your FireFly stack, it also deployed a token factory contract. When you create a token pool through FireFly’s token APIs, the token factory contract will automatically deploy an ERC-20 or ERC-721 contract, based on the pool type in the API request. ⚠️ WARNING: The default token contract that was deployed by the FireFly CLI is only provided for the purpose of learning about FireFly. It is not a production grade contract. If you intend to deploy a production application using tokens FireFly you should research token contract best practices. For details, please see the source code for the contract that was deployed. ",
    "url": "/firefly/tutorials/tokens/erc721.html#use-the-built-in-sample-token-factory",
    "relUrl": "/tutorials/tokens/erc721.html#use-the-built-in-sample-token-factory"
  },"241": {
    "doc": "ERC-721",
    "title": "Use the Sandbox (optional)",
    "content": "At this point you could open the Sandbox at http://127.0.0.1:5109/home?action=tokens.pools and perform the functions outlined in the rest of this guide. Or you can keep reading to learn how to build HTTP requests to work with tokens in FireFly. ",
    "url": "/firefly/tutorials/tokens/erc721.html#use-the-sandbox-optional",
    "relUrl": "/tutorials/tokens/erc721.html#use-the-sandbox-optional"
  },"242": {
    "doc": "ERC-721",
    "title": "Create a pool",
    "content": "After you stack is up and running, the first thing you need to do is create a Token Pool. Every application will need at least one Token Pool. At a minimum, you must always specify a name and type for the pool. If you’re using the default ERC-20 / ERC-721 token connector and its sample token factory, it will automatically deploy a new token contract, based on the type in the request to create the token pool. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"type\": \"nonfungible\", \"name\": \"nfts\" } . Response . { \"id\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"type\": \"nonfungible\", \"namespace\": \"default\", \"name\": \"nfts\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"connector\": \"erc20_erc721\", \"tx\": { \"type\": \"token_pool\", \"id\": \"00678116-89d2-4295-990c-bd5ffa6e2434\" } } . Other parameters: . | You must specify a connector if you have configured multiple token connectors | You may pass through a config object of additional parameters, if supported by your token connector | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | . Get the address of the deployed contract . To lookup the address of the new contract, you can lookup the Token Pool by its ID on the API. Creating the token pool will also emit an event which will contain the address. To query the token pool you can make a GET request to the pool’s ID: . Request . GET http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools/5811e8d5-52d0-44b1-8b75-73f5ff88f598 . Response . { \"id\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"type\": \"nonfungible\", \"namespace\": \"default\", \"name\": \"nfts\", \"standard\": \"ERC721\", \"locator\": \"address=0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c&amp;schema=ERC721WithData&amp;type=nonfungible\", \"connector\": \"erc20_erc721\", \"message\": \"53d95dda-e8ca-4546-9226-a0fdc6ec03ec\", \"state\": \"confirmed\", \"created\": \"2022-04-29T12:03:51.971349509Z\", \"info\": { \"address\": \"0xc4d02efcfab06f18ec0a68e00b98ffecf6bf7e3c\", \"name\": \"nfts\", \"schema\": \"ERC721WithData\" }, \"tx\": { \"type\": \"token_pool\", \"id\": \"00678116-89d2-4295-990c-bd5ffa6e2434\" } } . Create a pool for an existing contract . If you wish to use a contract that is already on the chain, you can pass the address in a config object with an address when you make the request to create the Token Pool. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools . { \"name\": \"testpool\", \"type\": \"fungible\", \"config\": { \"address\": \"0xb1C845D32966c79E23f733742Ed7fCe4B41901FC\" } } . ",
    "url": "/firefly/tutorials/tokens/erc721.html#create-a-pool",
    "relUrl": "/tutorials/tokens/erc721.html#create-a-pool"
  },"243": {
    "doc": "ERC-721",
    "title": "Mint a token",
    "content": "Once you have a token pool, you can mint tokens within it. With a token contract deployed by the default token factory, only the creator of a pool is allowed to mint, but a different contract may define its own permission model. With the default ERC-20 / ERC-721 token connector, the tokenIndex field must be set when minting an NFT. This is the unique index within the pool for the specific token that you are minting. NOTE: When minting NFTs the amount must be 1. If you wish to mint more NFTs, simply call the endpoint multiple times. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/mint . { \"amount\": \"1\", \"tokenIndex\": \"1\" } . Response . { \"type\": \"mint\", \"localId\": \"2de2e05e-9474-4a08-a64f-2cceb076bdaa\", \"pool\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"amount\": \"1\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"0fad4581-7cb2-42c7-8f78-62d32205c2c2\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify to if you’d like to send the minted tokens to a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc721.html#mint-a-token",
    "relUrl": "/tutorials/tokens/erc721.html#mint-a-token"
  },"244": {
    "doc": "ERC-721",
    "title": "Transfer a token",
    "content": "You may transfer tokens within a pool by specifying an amount and a destination understood by the connector (i.e. an Ethereum address). With a token contract deployed by the default token factory, only the owner of the tokens or another approved account may transfer their tokens, but a different contract may define its own permission model. When transferring an NFT, you must also specify the tokenIndex that you wish to transfer. The tokenIndex is simply the ID of the specific NFT within the pool that you wish to transfer. NOTE: When transferring NFTs the amount must be 1. If you wish to transfer more NFTs, simply call the endpoint multiple times, specifying the token index of each token to transfer. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . { \"amount\": \"1\", \"tokenIndex\": \"1\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\" } . Response . { \"type\": \"transfer\", \"localId\": \"f5fd0d13-db13-4d70-9a99-6bcd747f1e42\", \"pool\": \"a92a0a25-b886-4b43-931f-4add2840258a\", \"tokenIndex\": \"1\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"from\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"to\": \"0xa4222a4ae19448d43a338e6586edd5fb2ac398e1\", \"amount\": \"1\", \"tx\": { \"type\": \"token_transfer\", \"id\": \"63c1a89b-240c-41eb-84bb-323d56f4ba5a\" } } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to send tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc721.html#transfer-a-token",
    "relUrl": "/tutorials/tokens/erc721.html#transfer-a-token"
  },"245": {
    "doc": "ERC-721",
    "title": "Sending data with a transfer",
    "content": "All transfers (as well as mint/burn operations) support an optional message parameter that contains a broadcast or private message to be sent along with the transfer. This message follows the same convention as other FireFly messages, and may be comprised of text or blob data, and can provide context, metadata, or other supporting information about the transfer. The message will be batched, hashed, and pinned to the primary blockchain. The message ID and hash will also be sent to the token connector as part of the transfer operation, to be written to the token blockchain when the transaction is submitted. All recipients of the message will then be able to correlate the message with the token transfer. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/transfers . Broadcast message . { \"amount\": 1, \"tokenIndex\": \"1\", \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"data\": [{ \"value\": \"payment for goods\" }] } } . Private message . { \"amount\": 1, \"tokenIndex\": \"1\", \"to\": \"0x07eab7731db665caf02bc92c286f51dea81f923f\", \"message\": { \"header\": { \"type\": \"transfer_private\", }, \"group\": { \"members\": [{ \"identity\": \"org_1\" }] }, \"data\": [{ \"value\": \"payment for goods\" }] } } . Note that all parties in the network will be able to see the transfer (including the message ID and hash), but only the recipients of the message will be able to view the actual message data. ",
    "url": "/firefly/tutorials/tokens/erc721.html#sending-data-with-a-transfer",
    "relUrl": "/tutorials/tokens/erc721.html#sending-data-with-a-transfer"
  },"246": {
    "doc": "ERC-721",
    "title": "Burn tokens",
    "content": "You may burn a token by specifying the token’s tokenIndex. With a token contract deployed by the default token factory, only the owner of a token may burn it, but a different contract may define its own permission model. POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/burn . { \"amount\": 1, \"tokenIndex\": \"1\" } . Other parameters: . | You must specify a pool name if you’ve created more than one pool | You may specify a key understood by the connector (i.e. an Ethereum address) if you’d like to use a non-default signing identity | You may specify from if you’d like to burn tokens from a specific identity (default is the same as key) | . ",
    "url": "/firefly/tutorials/tokens/erc721.html#burn-tokens",
    "relUrl": "/tutorials/tokens/erc721.html#burn-tokens"
  },"247": {
    "doc": "ERC-721",
    "title": "Token approvals",
    "content": "You can also approve other wallets to transfer tokens on your behalf with the /approvals API. The important fields in a token approval API request are as follows: . | approved: Sets whether another account is allowed to transfer tokens out of this wallet or not. If not specified, will default to true. Setting to false can revoke an existing approval. | operator: The other account that is allowed to transfer tokens out of the wallet specified in the key field | config.tokenIndex: The specific token index within the pool that the operator is allowed to transfer. If 0 or not set, the approval is valid for all tokens. | key: The wallet address for the approval. If not set, it defaults to the address of the FireFly node submitting the transaction | . Here is an example request that would let the signing account 0x634ee8c7d0894d086c7af1fc8514736aed251528 transfer tokenIndex 2 from my wallet. Request . POST http://127.0.0.1:5000/api/v1/namespaces/default/tokens/approvals . { \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"config\": { \"tokenIndex\": \"2\" } } . Response . { \"localId\": \"46fef50a-cf93-4f92-acf8-fae161b37362\", \"pool\": \"e1477ed5-7282-48e5-ad9d-1612296bb29d\", \"connector\": \"erc20_erc721\", \"key\": \"0x14ddd36a0c2f747130915bf5214061b1e4bec74c\", \"operator\": \"0x634ee8c7d0894d086c7af1fc8514736aed251528\", \"approved\": true, \"tx\": { \"type\": \"token_approval\", \"id\": \"00faa011-f42c-403d-a047-2df7318967cd\" }, \"config\": { \"tokenIndex\": \"2\" } } . ",
    "url": "/firefly/tutorials/tokens/erc721.html#token-approvals",
    "relUrl": "/tutorials/tokens/erc721.html#token-approvals"
  },"248": {
    "doc": "ERC-721",
    "title": "Use Metamask",
    "content": "Now that you have an ERC-721 contract up and running, you may be wondering how to use Metamask (or some other wallet) with this contract. This section will walk you through how to connect Metamask to the blockchain and token contract that FireFly is using. Configure a new network . The first thing we need to do is tell Metamask how to connect to our local blockchain node. To do that: . | Click your account icon | In the drop down menu, click Settings . | On the left hand side of the page, click Networks | Click the Add a network button . | Fill in the network details: . | Network Name: FireFly (could be any name) | New RPC URL: http://127.0.0.1:5100 | Chain ID: 2021 | Currency Symbol: ETH | . | Click Save | . Import tokens . Metamask won’t know about our custom ERC-721 contract until we give it the Ethereum address for the contract, so that’s what we’ll do next. | Click on Import tokens . | Enter the Ethereum address of the contract | Enter a Token Symbol (can be anything you want) | Click Add Custom Token | . NOTE: You can find the address of your contract from the response to the request to create the token pool above. You can also do a GET to http://127.0.0.1:5000/api/v1/namespaces/default/tokens/pools to lookup your configured token pools. Transfer tokens . Now you can copy your account address from your Metamask wallet, and perform a transfer from FireFly’s API (as described above) to your Metamask address. After a couple seconds, you should see your token show up in your Metamask wallet. NOTE: While the NFT token balance can be viewed in Metamask, it does not appear that Metamask supports sending these tokens to another address at this time. ",
    "url": "/firefly/tutorials/tokens/erc721.html#use-metamask",
    "relUrl": "/tutorials/tokens/erc721.html#use-metamask"
  },"249": {
    "doc": "ERC-721",
    "title": "ERC-721",
    "content": " ",
    "url": "/firefly/tutorials/tokens/erc721.html",
    "relUrl": "/tutorials/tokens/erc721.html"
  },"250": {
    "doc": "Listen for events",
    "title": "Listen for events",
    "content": " ",
    "url": "/firefly/tutorials/events.html",
    "relUrl": "/tutorials/events.html"
  },"251": {
    "doc": "Listen for events",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | WebSockets Example 1: Ephemeral subscription with auto-commit | Example event payload | Download the message and data | Download just the data array associated with a message | WebSockets Example 2: Durable subscription for your application, with manual-commit . | Set up the WebSocket subscription | Connect to consume messages | . | . ",
    "url": "/firefly/tutorials/events.html#table-of-contents",
    "relUrl": "/tutorials/events.html#table-of-contents"
  },"252": {
    "doc": "Listen for events",
    "title": "Quick reference",
    "content": "Probably the most important aspect of FireFly is that it is an event-driven programming model. Parties interact by sending messages and transactions to each other, on and off chain. Once aggregated and confirmed those events drive processing in the other party. This allows orchestration of complex multi-party system applications and business processes. FireFly provides each party with their own private history, that includes all exchanges outbound and inbound performed through the node into the multi-party system. That includes blockchain backed transactions, as well as completely off-chain message exchanges. The event transports are pluggable. The core transports are WebSockets and Webhooks. We focus on WebSockets in this getting started guide. Check out the Request/Reply section for more information on Webhooks . ",
    "url": "/firefly/tutorials/events.html#quick-reference",
    "relUrl": "/tutorials/events.html#quick-reference"
  },"253": {
    "doc": "Listen for events",
    "title": "Additional info",
    "content": ". | Key Concepts: Multi-party process flow | Reference: coming soon | . ",
    "url": "/firefly/tutorials/events.html#additional-info",
    "relUrl": "/tutorials/events.html#additional-info"
  },"254": {
    "doc": "Listen for events",
    "title": "WebSockets Example 1: Ephemeral subscription with auto-commit",
    "content": "The simplest way to get started consuming events, is with an ephemeral WebSocket listener. Example connection URL: . ws://localhost:5000/ws?namespace=default&amp;ephemeral&amp;autoack&amp;filter.events=message_confirmed . | namespace=default - event listeners are scoped to a namespace | ephemeral - listen for events that occur while this connection is active, but do not remember the app instance (great for UIs) | autoack- automatically acknowledge each event, so the next event is sent (great for UIs) | filter.events=message_confirmed - only listen for events resulting from a message confirmation | . There are a number of browser extensions that let you experiment with WebSockets: . ",
    "url": "/firefly/tutorials/events.html#websockets-example-1-ephemeral-subscription-with-auto-commit",
    "relUrl": "/tutorials/events.html#websockets-example-1-ephemeral-subscription-with-auto-commit"
  },"255": {
    "doc": "Listen for events",
    "title": "Example event payload",
    "content": "The events (by default) do not contain the payload data, just the event and referred message. This means the WebSocket payloads are a predictably small size, and the application can use the information in the message to post-filter the event to decide if it needs to download the full data. There are server-side filters provided on events as well . { \"id\": \"8f0da4d7-8af7-48da-912d-187979bf60ed\", \"sequence\": 61, \"type\": \"message_confirmed\", \"namespace\": \"default\", \"reference\": \"9710a350-0ba1-43c6-90fc-352131ce818a\", \"created\": \"2021-07-02T04:37:47.6556589Z\", \"subscription\": { \"id\": \"2426c5b1-ffa9-4f7d-affb-e4e541945808\", \"namespace\": \"default\", \"name\": \"2426c5b1-ffa9-4f7d-affb-e4e541945808\" }, \"message\": { \"header\": { \"id\": \"9710a350-0ba1-43c6-90fc-352131ce818a\", \"type\": \"broadcast\", \"txtype\": \"batch_pin\", \"author\": \"0x1d14b65d2dd5c13f6cb6d3dc4aa13c795a8f3b28\", \"created\": \"2021-07-02T04:37:40.1257944Z\", \"namespace\": \"default\", \"topic\": [ \"default\" ], \"datahash\": \"cd6a09a15ccd3e6ed1d67d69fa4773b563f27f17f3eaad611a2792ba945ca34f\" }, \"hash\": \"1b6808d2b95b418e54e7bd34593bfa36a002b841ac42f89d00586dac61e8df43\", \"batchID\": \"16ffc02c-8cb0-4e2f-8b58-a707ad1d1eae\", \"state\": \"confirmed\", \"confirmed\": \"2021-07-02T04:37:47.6548399Z\", \"data\": [ { \"id\": \"b3a814cc-17d1-45d5-975e-90279ed2c3fc\", \"hash\": \"9ddefe4435b21d901439e546d54a14a175a3493b9fd8fbf38d9ea6d3cbf70826\" } ] } } . ",
    "url": "/firefly/tutorials/events.html#example-event-payload",
    "relUrl": "/tutorials/events.html#example-event-payload"
  },"256": {
    "doc": "Listen for events",
    "title": "Download the message and data",
    "content": "A simple REST API is provided to allow you to download the data associated with the message: . GET /api/v1/namespaces/default/messages/{id}?data=true . ",
    "url": "/firefly/tutorials/events.html#download-the-message-and-data",
    "relUrl": "/tutorials/events.html#download-the-message-and-data"
  },"257": {
    "doc": "Listen for events",
    "title": "Download just the data array associated with a message",
    "content": "As you already have the message object in the event delivery, you can query just the array of data objects as follows: . GET /api/v1/namespaces/default/messages/{id}/data . ",
    "url": "/firefly/tutorials/events.html#download-just-the-data-array-associated-with-a-message",
    "relUrl": "/tutorials/events.html#download-just-the-data-array-associated-with-a-message"
  },"258": {
    "doc": "Listen for events",
    "title": "WebSockets Example 2: Durable subscription for your application, with manual-commit",
    "content": "To reliably process messages within your application, you should first set up a subscription. A subscription requests that: . | FireFly keeps a record of the latest event consumed by that application | FireFly only delivers one copy of the event to the application, even when there are multiple active connections | . This should be combined with manual acknowledgment of the events, where the application sends a payload such as the following in response to each event it receives (where the id comes from the event it received): . { \"type\": \"ack\", \"id\": \"617db63-2cf5-4fa3-8320-46150cbb5372\" } . _You must send an acknowledgement for every message, or you will stop receiving messages. Set up the WebSocket subscription . Each subscription is scoped to a namespace, and must have a name. You can then choose to perform server-side filtering on the events using regular expressions matched against the information in the event. POST /namespaces/default/subscriptions . { \"transport\": \"websockets\", \"name\": \"app1\", \"filter\": { \"blockchainevent\": { \"listener\": \".*\", \"name\": \".*\" }, \"events\": \".*\", \"message\": { \"author\": \".*\", \"group\": \".*\", \"tag\": \".*\", \"topics\": \".*\" }, \"transaction\": { \"type\": \".*\" } }, \"options\": { \"firstEvent\": \"newest\", \"readAhead\": 50 } } . Connect to consume messages . Example connection URL: . ws://localhost:5000/ws?namespace=default&amp;name=app1 . | namespace=default - event listeners are scoped to a namespace | name=app1 - the subscription name | . ",
    "url": "/firefly/tutorials/events.html#websockets-example-2-durable-subscription-for-your-application-with-manual-commit",
    "relUrl": "/tutorials/events.html#websockets-example-2-durable-subscription-for-your-application-with-manual-commit"
  },"259": {
    "doc": "pages.faqs",
    "title": "FAQs",
    "content": "Find answers to the most commonly asked FireFly questions. This content is coming soon and will be guided by community interactions via Discord, meetups, webinars and other technical forums. If you have immediate questions please don’t hesitate to reach out to us on the Hyperledger Discord in the #firefly channel. ",
    "url": "/firefly/faqs/faqs.html#faqs",
    "relUrl": "/faqs/faqs.html#faqs"
  },"260": {
    "doc": "pages.faqs",
    "title": "pages.faqs",
    "content": " ",
    "url": "/firefly/faqs/faqs.html",
    "relUrl": "/faqs/faqs.html"
  },"261": {
    "doc": "FFI",
    "title": "FFI",
    "content": " ",
    "url": "/firefly/reference/types/ffi.html",
    "relUrl": "/reference/types/ffi.html"
  },"262": {
    "doc": "FFI",
    "title": "Table of contents",
    "content": ". | FFI . | Example | Field Descriptions | . | FFIMethod | FFIParam | FFIEvent | . ",
    "url": "/firefly/reference/types/ffi.html#table-of-contents",
    "relUrl": "/reference/types/ffi.html#table-of-contents"
  },"263": {
    "doc": "FFI",
    "title": "FFI",
    "content": "Example . { \"name\": \"\", \"description\": \"\", \"version\": \"\" } . Field Descriptions . | Field Name | Description | Type | . | id | The UUID of the FireFly interface (FFI) smart contract definition | UUID | . | message | The UUID of the broadcast message that was used to publish this FFI to the network | UUID | . | namespace | The namespace of the FFI | string | . | name | The name of the FFI - usually matching the smart contract name | string | . | description | A description of the smart contract this FFI represents | string | . | version | A version for the FFI - use of semantic versioning such as ‘v1.0.1’ is encouraged | string | . | methods | An array of smart contract method definitions | FFIMethod[] | . | events | An array of smart contract event definitions | FFIEvent[] | . ",
    "url": "/firefly/reference/types/ffi.html",
    "relUrl": "/reference/types/ffi.html"
  },"264": {
    "doc": "FFI",
    "title": "FFIMethod",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FFI method definition | UUID | . | interface | The UUID of the FFI smart contract definition that this method is part of | UUID | . | name | The name of the method | string | . | namespace | The namespace of the FFI | string | . | pathname | The unique name allocated to this method within the FFI for use on URL paths. Supports contracts that have multiple method overrides with the same name | string | . | description | A description of the smart contract method | string | . | params | An array of method parameter/argument definitions | FFIParam[] | . | returns | An array of method return definitions | FFIParam[] | . ",
    "url": "/firefly/reference/types/ffi.html#ffimethod",
    "relUrl": "/reference/types/ffi.html#ffimethod"
  },"265": {
    "doc": "FFI",
    "title": "FFIParam",
    "content": "| Field Name | Description | Type | . | name | The name of the parameter. Note that parameters must be ordered correctly on the FFI, according to the order in the blockchain smart contract | string | . | schema | FireFly uses an extended subset of JSON Schema to describe parameters, similar to OpenAPI/Swagger. Converters are available for native blockchain interface definitions / type systems - such as an Ethereum ABI. See the documentation for more detail | JSONAny | . ",
    "url": "/firefly/reference/types/ffi.html#ffiparam",
    "relUrl": "/reference/types/ffi.html#ffiparam"
  },"266": {
    "doc": "FFI",
    "title": "FFIEvent",
    "content": "| Field Name | Description | Type | . | id | The UUID of the FFI event definition | UUID | . | interface | The UUID of the FFI smart contract definition that this event is part of | UUID | . | namespace | The namespace of the FFI | string | . | pathname | The unique name allocated to this event within the FFI for use on URL paths. Supports contracts that have multiple event overrides with the same name | string | . | signature | The stringified signature of the event, as computed by the blockchain plugin | string | . ",
    "url": "/firefly/reference/types/ffi.html#ffievent",
    "relUrl": "/reference/types/ffi.html#ffievent"
  },"267": {
    "doc": "① Install the FireFly CLI",
    "title": "① Install the FireFly CLI",
    "content": " ",
    "url": "/firefly/gettingstarted/firefly_cli.html",
    "relUrl": "/gettingstarted/firefly_cli.html"
  },"268": {
    "doc": "① Install the FireFly CLI",
    "title": "Table of contents",
    "content": ". | FireFly CLI | Prerequisites . | Linux Users | Windows Users | . | Install the CLI . | Download the package for your OS | Extract the binary and move it to /usr/bin/local | macOSUsers | Alternative installation method: Install via Go | . | Verify the installation | Next steps: Start your environment | . ",
    "url": "/firefly/gettingstarted/firefly_cli.html#table-of-contents",
    "relUrl": "/gettingstarted/firefly_cli.html#table-of-contents"
  },"269": {
    "doc": "① Install the FireFly CLI",
    "title": "FireFly CLI",
    "content": "The FireFly CLI can be used to create local FireFly stacks for offline development of blockchain apps. This allows developers to rapidly iterate on their idea without needing to set up a bunch of infrastructure before they can write the first line of code. ",
    "url": "/firefly/gettingstarted/firefly_cli.html#firefly-cli",
    "relUrl": "/gettingstarted/firefly_cli.html#firefly-cli"
  },"270": {
    "doc": "① Install the FireFly CLI",
    "title": "Prerequisites",
    "content": "In order to run the FireFly CLI, you will need a few things installed on your dev machine: . | Docker | Docker Compose | openssl | . Linux Users . NOTE: For Linux users, it is recommended that you add your user to the docker group so that you do not have to run ff or docker as root or with sudo. For more information about Docker permissions on Linux, please see Docker’s documentation on the topic. Windows Users . NOTE: For Windows users, we recommend that you use Windows Subsystem for Linux 2 (WSL2). Binaries provided for Linux will work in this environment. ",
    "url": "/firefly/gettingstarted/firefly_cli.html#prerequisites",
    "relUrl": "/gettingstarted/firefly_cli.html#prerequisites"
  },"271": {
    "doc": "① Install the FireFly CLI",
    "title": "Install the CLI",
    "content": "There are several ways to install the FireFly CLI. The easiest way to get up and running with the FireFly CLI is to download a pre-compiled binary of the latest release. Download the package for your OS . Go to the latest release page and download the package for your OS and CPU architecture. Extract the binary and move it to /usr/bin/local . Assuming you downloaded the package from GitHub into your Downloads directory, run the following command: . sudo tar -zxf ~/Downloads/firefly-cli_*.tar.gz -C /usr/local/bin ff &amp;&amp; rm ~/Downloads/firefly-cli_*.tar.gz . If you downloaded the package from GitHub into a different directory, you will need to change the tar command above to wherever the firefly-cli_*.tar.gz file is located. macOSUsers . NOTE: On recent versions of macOS, default security settings will prevent the FireFly CLI binary from running, because it was downloaded from the internet. You will need to allow the FireFly CLI in System Preferences, before it will run. Alternative installation method: Install via Go . If you have a local Go development environment, and you have included ${GOPATH}/bin in your path, you could also use Go to install the FireFly CLI by running: . go install github.com/hyperledger/firefly-cli/ff@latest . ",
    "url": "/firefly/gettingstarted/firefly_cli.html#install-the-cli",
    "relUrl": "/gettingstarted/firefly_cli.html#install-the-cli"
  },"272": {
    "doc": "① Install the FireFly CLI",
    "title": "Verify the installation",
    "content": "After using either installation method above, you can verify that the CLI is successfully installed by running ff version. This should print the current version like this: . { \"Version\": \"v0.0.47\", \"License\": \"Apache-2.0\" } . ",
    "url": "/firefly/gettingstarted/firefly_cli.html#verify-the-installation",
    "relUrl": "/gettingstarted/firefly_cli.html#verify-the-installation"
  },"273": {
    "doc": "① Install the FireFly CLI",
    "title": "Next steps: Start your environment",
    "content": "Now that you’ve got the FireFly CLI set up on your machine, the next step is to create and start a FireFly stack. ② Start your environment → . ",
    "url": "/firefly/gettingstarted/firefly_cli.html#next-steps-start-your-environment",
    "relUrl": "/gettingstarted/firefly_cli.html#next-steps-start-your-environment"
  },"274": {
    "doc": "FireFly Interface Format",
    "title": "FireFly Interface Format",
    "content": "FireFly defines a common, blockchain agnostic way to describe smart contracts. This is referred to as a Contract Interface, and it is written in the FireFly Interface (FFI) format. It is a simple JSON document that has a name, a namespace, a version, a list of methods, and a list of events. ",
    "url": "/firefly/reference/firefly_interface_format.html",
    "relUrl": "/reference/firefly_interface_format.html"
  },"275": {
    "doc": "FireFly Interface Format",
    "title": "Table of contents",
    "content": ". | Overview | Method | Event | Param . | Schema | Schema details | . | Automated generation of FireFly Interfaces | Full Example | . ",
    "url": "/firefly/reference/firefly_interface_format.html#table-of-contents",
    "relUrl": "/reference/firefly_interface_format.html#table-of-contents"
  },"276": {
    "doc": "FireFly Interface Format",
    "title": "Overview",
    "content": "There are four required fields when broadcasting a contract interface in FireFly: a name, a version, a list of methods, and a list of events. A namespace field will also be filled in automatically based on the URL path parameter. Here is an example of the structure of the required fields: . { \"name\": \"example\", \"version\": \"v1.0.0\", \"methods\": [], \"events\": [] } . NOTE: Contract interfaces are scoped to a namespace. Within a namespace each contract interface must have a unique name and version combination. The same name and version combination can exist in different namespaces simultaneously. ",
    "url": "/firefly/reference/firefly_interface_format.html#overview",
    "relUrl": "/reference/firefly_interface_format.html#overview"
  },"277": {
    "doc": "FireFly Interface Format",
    "title": "Method",
    "content": "Let’s look at a what goes inside the methods array now. It is also a JSON object that has a name, a list of params which are the arguments the function will take and a list of returns which are the return values of the function. Optionally, it also has a description which can be helpful in OpenAPI Spec generation. { \"name\": \"add\", \"description\": \"Add two numbers together\", \"params\": [], \"returns\": [] } . ",
    "url": "/firefly/reference/firefly_interface_format.html#method",
    "relUrl": "/reference/firefly_interface_format.html#method"
  },"278": {
    "doc": "FireFly Interface Format",
    "title": "Event",
    "content": "What goes into the events array is very similar. It is also a JSON object that has a name and a list of params. The difference is that events don’t have returns. Arguments that are passed to the event when it is emitted are in params. Optionally, it also has a description which can be helpful in OpenAPI Spec generation. { \"name\": \"added\", \"description\": \"An event that occurs when numbers have been added\", \"params\": [] } . ",
    "url": "/firefly/reference/firefly_interface_format.html#event",
    "relUrl": "/reference/firefly_interface_format.html#event"
  },"279": {
    "doc": "FireFly Interface Format",
    "title": "Param",
    "content": "Both methods, and events have lists of params or returns, and the type of JSON object that goes in each of these arrays is the same. It is simply a JSON object with a name and a schema. There is also an optional details field that is passed to the blockchain plugin for blockchain specific requirements. { \"name\": \"x\", \"schema\": { \"type\": \"integer\", \"details\": {} } } . Schema . The param schema is an important field which tells FireFly the type information about this particular field. This is used in several different places, such as OpenAPI Spec generation, API request validation, and blockchain request preparation. The schema field accepts JSON Schema (version 2020-12) with several additional requirements: . | A type field is always mandatory | The list of valid types is: . | boolean | integer | string | object | array | . | Blockchain plugins can add their own specific requirements to this list of validation rules | . NOTE: Floats or decimals are not currently accepted because certain underlying blockchains (e.g. Ethereum) only allow integers . The type field here is the JSON input type when making a request to FireFly to invoke or query a smart contract. This type can be different from the actual blockchain type, usually specified in the details field, if there is a compatible type mapping between the two. Schema details . The details field is quite important in some cases. Because the details field is passed to the blockchain plugin, it is used to encapsulate blockchain specific type information about a particular field. Additionally, because each blockchain plugin can add rules to the list of schema requirements above, a blockchain plugin can enforce that certain fields are always present within the details field. For example, the Ethereum plugin always needs to know what Solidity type the field is. It also defines several optional fields. A full Ethereum details field may look like: . { \"type\": \"uint256\", \"internalType\": \"uint256\", \"indexed\": false } . ",
    "url": "/firefly/reference/firefly_interface_format.html#param",
    "relUrl": "/reference/firefly_interface_format.html#param"
  },"280": {
    "doc": "FireFly Interface Format",
    "title": "Automated generation of FireFly Interfaces",
    "content": "A convenience endpoint exists on the API to facilitate converting from native blockchain interface formats such as an Ethereum ABI to the FireFly Interface format. For details, please see the API documentation for the contract interface generation endpoint. For an example of using this endpoint with a specific Ethereum contract, please see the Tutorial to Work with custom smart contracts. ",
    "url": "/firefly/reference/firefly_interface_format.html#automated-generation-of-firefly-interfaces",
    "relUrl": "/reference/firefly_interface_format.html#automated-generation-of-firefly-interfaces"
  },"281": {
    "doc": "FireFly Interface Format",
    "title": "Full Example",
    "content": "Putting it all together, here is a full example of the FireFly Interface format with all the fields filled in: . { \"namespace\": \"default\", \"name\": \"SimpleStorage\", \"description\": \"A simple smart contract that stores and retrieves an integer on-chain\", \"version\": \"v1.0.0\", \"methods\": [ { \"name\": \"get\", \"description\": \"Retrieve the value of the stored integer\", \"params\": [], \"returns\": [ { \"name\": \"output\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] }, { \"name\": \"set\", \"description\": \"Set the stored value on-chain\", \"params\": [ { \"name\": \"newValue\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ], \"returns\": [] } ], \"events\": [ { \"name\": \"Changed\", \"description\": \"An event that is fired when the stored integer value changes\", \"params\": [ { \"name\": \"from\", \"schema\": { \"type\": \"string\", \"details\": { \"type\": \"address\", \"internalType\": \"address\", \"indexed\": true } } }, { \"name\": \"value\", \"schema\": { \"type\": \"integer\", \"details\": { \"type\": \"uint256\", \"internalType\": \"uint256\" } } } ] } ] } . ",
    "url": "/firefly/reference/firefly_interface_format.html#full-example",
    "relUrl": "/reference/firefly_interface_format.html#full-example"
  },"282": {
    "doc": "The FireFly node",
    "title": "The FireFly node",
    "content": " ",
    "url": "/firefly/overview/firefly_node.html",
    "relUrl": "/overview/firefly_node.html"
  },"283": {
    "doc": "The FireFly node",
    "title": "Table of contents",
    "content": ". | FireFly node runtimes | Pluggable microservices architecture | . ",
    "url": "/firefly/overview/firefly_node.html#table-of-contents",
    "relUrl": "/overview/firefly_node.html#table-of-contents"
  },"284": {
    "doc": "The FireFly node",
    "title": "FireFly node runtimes",
    "content": "A FireFly node is a collection of multiple microservice runtimes with a single unified HTTPS/Websocket API (exposed by the Core). The minimum set of runtimes is as follows: . | FireFly Core - the API and event server for your multi-party applications | Blockchain node - the decentralized ledger technology establishing a shared source of truth | Blockchain interface - transaction submission and event streams for your chosen protocol | Shared storage node - a network-wide peer-to-peer store of shared data | Data exchange - for private member to member communications of messages and files | . Check out the FireFly CLI to get a a multi-party system running on your laptop in minutes. ",
    "url": "/firefly/overview/firefly_node.html#firefly-node-runtimes",
    "relUrl": "/overview/firefly_node.html#firefly-node-runtimes"
  },"285": {
    "doc": "The FireFly node",
    "title": "Pluggable microservices architecture",
    "content": "The runtimes are pluggable, allowing technology choice, and extensibility. | FireFly Core . | Orchestration engine - manages lifecycle of assets and data | Hosts the API and UI - applications connect here | Maintains private storage | Written in Go | . | Connectors . | Runtimes that bridge the core to multi-party infrastructure | Can be written in any language Go, Java, Node.js etc. | Can be stateful or stateless, depending on requirements | Can contain significant function, such as managed file transfer, or e2e encryption | . | Infrastructure runtimes . | Can be local runtimes, or cloud services | Blockchain nodes - Fabric, Ethereum, Corda etc. | Database servers - PostreSQL, SQLite, CouchDB etc. | Private messaging - Kafka, RabbitMQ, ActiveMQ, Mosquitto etc. | Private blob storage - Kubernetes PVCs, AWS S3, Azure File etc. | Public blob storage - IPFS, etc. | … and more - token bridges, trusted compute engines, etc. | . | . ",
    "url": "/firefly/overview/firefly_node.html#pluggable-microservices-architecture",
    "relUrl": "/overview/firefly_node.html#pluggable-microservices-architecture"
  },"286": {
    "doc": "Introduction to Supernodes",
    "title": "Introduction to Supernodes",
    "content": " ",
    "url": "/firefly/overview/firefly_supernode.html",
    "relUrl": "/overview/firefly_supernode.html"
  },"287": {
    "doc": "Introduction to Supernodes",
    "title": "Table of contents",
    "content": ". | What is a Supernode | Your project with or without a Supernode | Types of blockchain project that benefit . | Solution builders | Organizations needing a gateway to Web3 | . | Feature view | Application features . | API Gateway | Event Streams | API Generation | . | Flow features . | Private data flow | Multi-party business process flow | Data exchange | . | Digital asset features . | Token API | Transfer history / audit trail | Wallets | . | . ",
    "url": "/firefly/overview/firefly_supernode.html#table-of-contents",
    "relUrl": "/overview/firefly_supernode.html#table-of-contents"
  },"288": {
    "doc": "Introduction to Supernodes",
    "title": "What is a Supernode",
    "content": "Over the last decade of enterprise blockchain projects, architects and developers have realized that they need much more than a blockchain node for their projects to be successful. The development stack needed for an enterprise grade Web3 application, is just as sophisticated as the stack required for the Web 2.0 applications that came before. A raw blockchain node is simply not enough. ",
    "url": "/firefly/overview/firefly_supernode.html#what-is-a-supernode",
    "relUrl": "/overview/firefly_supernode.html#what-is-a-supernode"
  },"289": {
    "doc": "Introduction to Supernodes",
    "title": "Your project with or without a Supernode",
    "content": ". So your choice as a development team for a blockchain project becomes whether you build and update all of the “plumbing” / “middleware” components needed underneath your business logic yourself, or whether you look for pre-built solutions. The Hyperledger FireFly approach is to allow the community to collaborate on the development and hardening of these components, across industries and projects. Then fit them into an open source, enterprise grade, pluggable development and runtime stack… the Supernode. The application developers then code against these APIs, and can be confident that the business logic that works on their local laptop against a sandbox, is being written in a way that scales to an enterprise decentralized application and can be deployed against one or more public/private blockchains in production. Thus allowing development teams to focus on differentiation where it matters - at the solution layer. ",
    "url": "/firefly/overview/firefly_supernode.html#your-project-with-or-without-a-supernode",
    "relUrl": "/overview/firefly_supernode.html#your-project-with-or-without-a-supernode"
  },"290": {
    "doc": "Introduction to Supernodes",
    "title": "Types of blockchain project that benefit",
    "content": "There are two main reasons your project might be exploring Supernodes, and considering the open source approach of Hyperledger FireFly. Solution builders . Teams building new decentralized Web3 solutions need a full technology stack for the application, to manage both private and blockchain data. Particularly in the enterprise space due to data security, regulatory and privacy concerns. For theses solutions to be successful, they need decentralized deployment to multiple parties. Each party needs to customize the deployment to their SecDevOps environment, as well as onboard it to their key management solution etc. So the complexity of requiring a bespoke technology stack for a solution can be a barrier to its adoption. Whereas, building on top of a standardized and open technology stack can ease adoption, as well as radically reducing the amount of engineering needed by the solution developer. Organizations needing a gateway to Web3 . Organizations are increasingly participating in multiple blockchain projects, and integrating with digital assets in multiple blockchain ecosystems. This means core IT security policy needs to scale to the challenge of adding these connections, and managing the wallets / signing identities, data flow, and SecDevOps requirements across multiple projects. A gateway tier at the edge between the core systems of the enterprise, and the Web3 transactions, helps reduce the overhead, and reduce risk. ",
    "url": "/firefly/overview/firefly_supernode.html#types-of-blockchain-project-that-benefit",
    "relUrl": "/overview/firefly_supernode.html#types-of-blockchain-project-that-benefit"
  },"291": {
    "doc": "Introduction to Supernodes",
    "title": "Feature view",
    "content": "So what makes a Supernode? . Let’s break down the functionality that is needed for an enterprise blockchain solution. ",
    "url": "/firefly/overview/firefly_supernode.html#feature-view",
    "relUrl": "/overview/firefly_supernode.html#feature-view"
  },"292": {
    "doc": "Introduction to Supernodes",
    "title": "Application features",
    "content": "Rapidly accelerating development is a key requirement of any Supernode. The business logic APIs, web and mobile user experiences for Web3 applications need to be just as rich and feature-full as the Web 2.0 / centralized applications. That means developers skilled in these application layers, must have the tools they need. Capabilities fitting their application development toolchain, and optimized to their skillset. API Gateway . Modern APIs that: . | Are fast and efficient | Have rich query support | Give deterministic outcomes and clear instruction for safe use | Integrate with your security frameworks like OAuth 2.0 / OpenID Connect single sign-on | Provide Open API 3 / Swagger definitions | Come with code SDKs, with rich type information | Conform as closely as possible to the principles of REST | Do not pretend to be RESTful in cases when it is impossible to be | . Event Streams . The reality is that the only programming paradigm that works for a decentralized solutions, is an event-driven one. All blockchain technologies are for this reason event-driven programming interfaces at their core. In an overall solution, those on-chain events must be coordinated with off-chain private data transfers, and existing core-systems / human workflows. This means great event support is a must: . | Convenient WebSocket APIs that work for your microservices development stack | Support for Webhooks to integrated serverless functions | Integration with your core enterprise message queue (MQ) or enterprise service bus (ESB) | At-least-once delivery assurance, with simple instructions at the application layer | . API Generation . The blockchain is going to be at the heart of your Web3 project. While usually small in overall surface area compared to the lines of code in the traditional application tiers, this kernel of mission-critical code is what makes your solution transformational compared to a centralized / Web 2.0 solution. Whether the smart contract is hand crafted for your project, an existing contract on a public blockchain, or a built-in pattern of a framework like FireFly - it must be interacted with correctly. So there can be no room for misinterpretation in the hand-off between the blockchain Smart Contract specialist, familiar with EVM contracts in Solidity/Vyper, Fabric chaincode (or maybe even raw block transition logic in Rust or Go), and the backend/full-stack application developer / core-system integrator. Well documented APIs are the modern norm for this, and it is no different for blockchain. This means: . | Generating the interface for methods and events on your smart contract | Providing robust transaction submission, and event streaming | Publishing the API, version, and location, of your smart contracts to the network | . ",
    "url": "/firefly/overview/firefly_supernode.html#application-features",
    "relUrl": "/overview/firefly_supernode.html#application-features"
  },"293": {
    "doc": "Introduction to Supernodes",
    "title": "Flow features",
    "content": "Data, value, and process flow are how decentralized systems function. In an enterprise context not all of this data can be shared with all parties, and some is very sensitive. Private data flow . Managing the flows of data so that the right information is shared with the right parties, at the right time, means thinking carefully about what data flows over what channel. The number of enterprise solutions where all data can flow directly through the blockchain, is vanishingly small. Coordinating these different data flows is often one of the biggest pieces of heavy lifting solved on behalf of the application by a robust framework like FireFly: . | Establishing the identity of participants so data can be shared | Securing the transfer of data off-chain | Coordinating off-chain data flow with on-chain data flow | Managing sequence for deterministic outcomes for all parties | Integrating off-chain private execution with multi-step stateful business logic | . Multi-party business process flow . Web3 has the potential to transform how ecosystems interact. Digitally transforming legacy process flows, by giving deterministic outcomes that are trusted by all parties, backed by new forms of digital trust between parties. Some of the most interesting use cases require complex multi-step business process across participants. The Web3 version of business process management, comes with a some new challenges. So you need the platform to: . | Provide a robust event-driven programming model fitting a “state machine” approach | Integrate with the decentralized application stack of each participant | Allow integration with the core-systems and human decision making of each participant | Provide deterministic ordering between all parties | Provide identity assurance and proofs for data flow / transition logic | . Data exchange . Business processes need data, and that data comes in many shapes and sizes. The platform needs to handle all of them: . | Large files and documents, as well as application data | Uniqueness / Enterprise NFTs - agreement on a single “foreign key” for a record | Non-repudiation, and acknowledgement of receipt | Coordination of flows of data, with flows of value - delivery vs. payment scenarios | . ",
    "url": "/firefly/overview/firefly_supernode.html#flow-features",
    "relUrl": "/overview/firefly_supernode.html#flow-features"
  },"294": {
    "doc": "Introduction to Supernodes",
    "title": "Digital asset features",
    "content": "The modelling, transfer and management of digital assets is the core programming foundation of blockchain. Yet out of the box, raw blockchains designed to efficiently manage these assets in large ecosystems, do not come with all the building blocks needed by applications. Token API . Tokens are such a fundamental construct, that they justify a standard API. This has been evolving in the industry through standards like ERC-20/ERC-721, and Web3 signing wallets and that support these. Supernodes bring this same standardization to applications. Providing APIs that work across token standards, and blockchain implementations, providing consistent and interoperable support. This means one application or set of back-end systems, can integrate with multiple blockchains, and different token implementations. Pluggability here is key, so that the rules of governance of each digital asset ecosystem can be exposed and enforced. Whether tokens are fungible, non-fungible, or some hybrid in between. Transfer history / audit trail . For efficiency blockchains seldom provide in their core the ability to query historical transaction information. Sometimes even the ability to query balances is unavailable, for blockchains based on a UTXO model. So off-chain indexing of transaction history is an absolute must-have for any digital asset solution, or even a simple wallet application. A platform like Hyperledger FireFly provides: . | Automatic indexing of tokens, whether existing or newly deployed | Off-chain indexing of fungible and non-fungible asset transfers &amp; balances | Off-chain indexing of approvals | Integration with digital identity | Full extensibility across both token standards and blockchain technologies | . Wallets . Wallet and signing-key management is a critical requirement for any blockchain solution, particularly those involving the transfer of digital assets between wallets. A platform like Hyperledger FireFly provides you the ability to: . | Integrate multiple different signing/custody solutions in a proven way | Manage the mapping of off-chain identities to on-chain signing identities | Provide a plug-point for policy-based decision making on high value transactions | Manage connections to multiple different blockchain solutions | . ",
    "url": "/firefly/overview/firefly_supernode.html#digital-asset-features",
    "relUrl": "/overview/firefly_supernode.html#digital-asset-features"
  },"295": {
    "doc": "pages.architecture",
    "title": "Architecture",
    "content": "This section contains a collection of technical architecture diagrams detailing the various runtime components of a FireFly deployment. ",
    "url": "/firefly/architecture/#architecture",
    "relUrl": "/architecture/#architecture"
  },"296": {
    "doc": "pages.architecture",
    "title": "pages.architecture",
    "content": " ",
    "url": "/firefly/architecture/",
    "relUrl": "/architecture/"
  },"297": {
    "doc": "Types",
    "title": "Types",
    "content": " ",
    "url": "/firefly/reference/types/",
    "relUrl": "/reference/types/"
  },"298": {
    "doc": "pages.reference",
    "title": "Reference",
    "content": ". This section developer reference information . ",
    "url": "/firefly/reference/#reference",
    "relUrl": "/reference/#reference"
  },"299": {
    "doc": "pages.reference",
    "title": "pages.reference",
    "content": " ",
    "url": "/firefly/reference/",
    "relUrl": "/reference/"
  },"300": {
    "doc": "Use tokens",
    "title": "Quick reference",
    "content": "Tokens are a critical building block in many blockchain-backed applications. Fungible tokens can represent a store of value or a means of rewarding participation in a multi-party system, while non-fungible tokens provide a clear way to identify and track unique entities across the network. FireFly provides flexible mechanisms to operate on any type of token and to tie those operations to on- and off-chain data. | FireFly provides an abstraction layer for multiple types of tokens | Tokens are grouped into pools, which each represent a particular type or class of token | Each pool is classified as fungible or non-fungible | In the case of non-fungible tokens, the pool is subdivided into individual tokens with a unique token index | Within a pool, you may mint (issue), transfer, and burn (redeem) tokens | Each operation can be optionally accompanied by a broadcast or private message, which will be recorded alongside the transfer on-chain | FireFly tracks a history of all token operations along with all current token balances | The blockchain backing each token connector may be the same or different from the one backing FireFly message pinning | . ",
    "url": "/firefly/tutorials/tokens/#quick-reference",
    "relUrl": "/tutorials/tokens/#quick-reference"
  },"301": {
    "doc": "Use tokens",
    "title": "What is a pool?",
    "content": "Token pools are a FireFly construct for describing a set of tokens. The exact definition of a token pool is dependent on the token connector implementation. Some examples of how pools might map to various well-defined Ethereum standards: . | ERC-1155: a single contract instance can efficiently allocate many isolated pools of fungible or non-fungible tokens | ERC-20 / ERC-777: each contract instance represents a single fungible pool of value, e.g. “a coin” | ERC-721: each contract instance represents a single pool of NFTs, each with unique identities within the pool | ERC-1400 / ERC-1410: partially supported in the same manner as ERC-20/ERC-777, but would require new features for working with partitions | . These are provided as examples only - a custom token connector could be backed by any token technology (Ethereum or otherwise) as long as it can support the basic operations described here (create pool, mint, burn, transfer). Other FireFly repos include a sample implementation of a token connector for ERC-20 and ERC-721 as well as ERC-1155. ",
    "url": "/firefly/tutorials/tokens/#what-is-a-pool",
    "relUrl": "/tutorials/tokens/#what-is-a-pool"
  },"302": {
    "doc": "Use tokens",
    "title": "Use tokens",
    "content": " ",
    "url": "/firefly/tutorials/tokens/",
    "relUrl": "/tutorials/tokens/"
  },"303": {
    "doc": "pages.tutorials",
    "title": "Tutorials",
    "content": " ",
    "url": "/firefly/tutorials/#tutorials",
    "relUrl": "/tutorials/#tutorials"
  },"304": {
    "doc": "pages.tutorials",
    "title": "pages.tutorials",
    "content": " ",
    "url": "/firefly/tutorials/",
    "relUrl": "/tutorials/"
  },"305": {
    "doc": "pages.contributors",
    "title": "Contributors’ Guide",
    "content": " ",
    "url": "/firefly/contributors/#contributors-guide",
    "relUrl": "/contributors/#contributors-guide"
  },"306": {
    "doc": "pages.contributors",
    "title": "Table of contents",
    "content": ". | 🚀 Connect with us on Discord | 📅 Join our Community Calls | 🔍 Find your first issue . | Any level of experience | Go experience | Little or no Go experience, but want to learn | TypeScript experience | React/TypeScript experience | Go and blockchain experience | . | 📝 Make changes | 📑 Commit with Developer Certificate of Origin | 📥 Open a Pull Request | . We welcome anyone to contribute to the FireFly project! If you’re interested, this is a guide on how to get started. You don’t have to be a blockchain expert to make valuable contributions! There are lots of places for developers of all experience levels to get involved. 🧑🏽‍💻 👩🏻‍💻 👩🏾‍💻 🧑🏻‍💻 🧑🏿‍💻 👨🏽‍💻 👩🏽‍💻 🧑🏾‍💻 👨🏿‍💻 👨🏾‍💻 👩🏿‍💻 👨🏻‍💻 . ",
    "url": "/firefly/contributors/#table-of-contents",
    "relUrl": "/contributors/#table-of-contents"
  },"307": {
    "doc": "pages.contributors",
    "title": "🚀 Connect with us on Discord",
    "content": "You can chat with maintainers and other contributors on Discord in the firefly channel: https://discord.gg/hyperledger . ",
    "url": "/firefly/contributors/#-connect-with-us-on-discord",
    "relUrl": "/contributors/#-connect-with-us-on-discord"
  },"308": {
    "doc": "pages.contributors",
    "title": "📅 Join our Community Calls",
    "content": "Community calls are a place to talk to other contributors, maintainers, and other people interested in FireFly. Maintainers often discuss upcoming changes and proposed new features on these calls. These calls are a great way for the community to give feedback on new ideas, ask questions about FireFly, and hear how others are using FireFly to solve real world problems. Please see the FireFly Calendar for the current meeting schedule, and the link to join. Everyone is welcome to join, regardless of background or experience level. ",
    "url": "/firefly/contributors/#-join-our-community-calls",
    "relUrl": "/contributors/#-join-our-community-calls"
  },"309": {
    "doc": "pages.contributors",
    "title": "🔍 Find your first issue",
    "content": "If you’re looking for somewhere to get started in the FireFly project and want something small and relatively easy, take a look at issues tagged with “Good first issue”. You can definitely work on other things if you want to. These are only suggestions for easy places to get started. Here are some other suggestions of places to get started, based on experience you may already have: . Any level of experience . If you looking to make your first open source contribution the FireFly documentation is a great place to make small, easy improvements. These improvements are also very valuable, because they help the next person that may want to know the same thing. Here are some detailed instructions on Contributing to Documentation . Go experience . If you have some experience in Go and really want to jump into FireFly, the FireFly Core is the heart of the project. Here are some detailed instructions on Setting up a FireFly Core Development Environment. Little or no Go experience, but want to learn . If you don’t have a lot of experience with Go, but are interested in learning, the FireFly CLI might be a good place to start. The FireFly CLI is a tool to set up local instances of FireFly for building apps that use FireFly, and for doing development on FireFly itself. TypeScript experience . If you have some experience in TypeScript, there are several FireFly microservices that are written in TypeScript. The Data Exchange is used for private messaging between FireFly nodes, and the Tokens Connector is used to abstract token contract specifics from the FireFly Core. React/TypeScript experience . If you want to do some frontend development, the FireFly UI is written in TypeScript and React. Go and blockchain experience . If you already have some experience with blockchain and want to work on some backend components, the blockchain connectors, firefly-ethconnect (for Ethereum) and firefly-fabconnect (for Fabric) are great places to get involved. ",
    "url": "/firefly/contributors/#-find-your-first-issue",
    "relUrl": "/contributors/#-find-your-first-issue"
  },"310": {
    "doc": "pages.contributors",
    "title": "📝 Make changes",
    "content": "To contribute to the repository, please fork the repository that you want to change. Then clone your fork locally on your machine and make your changes. As you commit your changes, push them to your fork. More information on making commits below. ",
    "url": "/firefly/contributors/#-make-changes",
    "relUrl": "/contributors/#-make-changes"
  },"311": {
    "doc": "pages.contributors",
    "title": "📑 Commit with Developer Certificate of Origin",
    "content": "As with all Hyperledger repositories, FireFly requires proper sign-off on every commit that is merged into the main branch. The sign-off indicates that you certify the changes you are submitting are in accordance with the Developer Certificate of Origin. To sign-off on your commit, you can use the -s flag when you commit changes. git commit -s -m \"Your commit message\" . This will add a string like this to the end of your commit message: . \"Signed-off-by: Your Name &lt;your-email@address&gt;\" . NOTE: Sign-off is not the same thing as signing your commits with a private key. Both operations use a similar flag, which can be confusing. The one you want is the lowercase -s 🙂 . ",
    "url": "/firefly/contributors/#-commit-with-developer-certificate-of-origin",
    "relUrl": "/contributors/#-commit-with-developer-certificate-of-origin"
  },"312": {
    "doc": "pages.contributors",
    "title": "📥 Open a Pull Request",
    "content": "When you’re ready to submit your changes for review, open a Pull Request back to the upstream repository. When you open your pull request, the maintainers will automatically be notified. Additionally, a series of automated checks will be performed on your code to make sure it passes certain repository specific requirements. Maintainers may have suggestions on things to improve in your pull request. It is our goal to get code that is beneficial to the project merged as quickly as possible, so we don’t like to leave pull requests hanging around for a long time. If the project maintainers are satisfied with the changes, they will approve and merge the pull request. Thanks for your interest in collaborating on this project! . ",
    "url": "/firefly/contributors/#-open-a-pull-request",
    "relUrl": "/contributors/#-open-a-pull-request"
  },"313": {
    "doc": "pages.contributors",
    "title": "pages.contributors",
    "content": " ",
    "url": "/firefly/contributors/",
    "relUrl": "/contributors/"
  },"314": {
    "doc": "pages.understanding_firefly",
    "title": "Understanding FireFly",
    "content": ". ",
    "url": "/firefly/overview/#understanding-firefly",
    "relUrl": "/overview/#understanding-firefly"
  },"315": {
    "doc": "pages.understanding_firefly",
    "title": "pages.understanding_firefly",
    "content": " ",
    "url": "/firefly/overview/",
    "relUrl": "/overview/"
  },"316": {
    "doc": "pages.getting_started",
    "title": "Getting Started",
    "content": "If you’re new to FireFly, this is the perfect place to start! With the FireFly CLI and the FireFly Sandbox it’s really easy to get started building powerful blockchain apps. Just follow along with the steps below and you’ll be up and running in no time! . What you will accomplish with this guide . With this easy-to-follow guide, you’ll go from “zero” to blockchain-hero in the time it takes to drink a single cup of coffee. It will walk you through setting up your machine, all the way through sending your first blockchain transactions using the FireFly Sandbox. We’re here to help! . We want to make it as easy as possible for anyone to get started with FireFly, and we don’t want anyone to feel like they’re stuck. If you’re having trouble, or are just curious about what else you can do with FireFly we encourage you to join the Hyperledger Discord server and come chat with us in the #firefly channel. ",
    "url": "/firefly/gettingstarted/#getting-started",
    "relUrl": "/gettingstarted/#getting-started"
  },"317": {
    "doc": "pages.getting_started",
    "title": "Get started: Install the FireFly CLI",
    "content": "Now that you’ve got the FireFly CLI set up on your machine, the next step is to create and start a FireFly stack. ① Install the FireFly CLI → . ",
    "url": "/firefly/gettingstarted/#get-started-install-the-firefly-cli",
    "relUrl": "/gettingstarted/#get-started-install-the-firefly-cli"
  },"318": {
    "doc": "pages.getting_started",
    "title": "pages.getting_started",
    "content": " ",
    "url": "/firefly/gettingstarted/",
    "relUrl": "/gettingstarted/"
  },"319": {
    "doc": "pages.home",
    "title": "Hyperledger FireFly",
    "content": ". Hyperledger FireFly is the first open source Supernode: a complete stack for enterprises to build and scale secure Web3 applications. The FireFly API for digital assets, data flows, and blockchain transactions makes it radically faster to build production-ready apps on popular chains and protocols. | Understanding FireFly | Reference | Architecture | Contributors | API Spec | . ",
    "url": "/firefly/#hyperledger-firefly",
    "relUrl": "/#hyperledger-firefly"
  },"320": {
    "doc": "pages.home",
    "title": "pages.home",
    "content": " ",
    "url": "/firefly/",
    "relUrl": "/"
  },"321": {
    "doc": "Internal Event Sequencing",
    "title": "Internal Event Sequencing",
    "content": " ",
    "url": "/firefly/architecture/internal_event_sequencing.html",
    "relUrl": "/architecture/internal_event_sequencing.html"
  },"322": {
    "doc": "Internal Event Sequencing",
    "title": "Table of contents",
    "content": ". | Overview | App Instances | Outbound Sequencers | Inbound Aggregator . | Events Table | . | Subscription Manager | Event Dispatcher | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#table-of-contents",
    "relUrl": "/architecture/internal_event_sequencing.html#table-of-contents"
  },"323": {
    "doc": "Internal Event Sequencing",
    "title": "Overview",
    "content": ". One of the most important roles FireFly has, is to take actions being performed by the local apps, process them, get them confirmed, and then deliver back as “stream of consciousness” to the application alongside all the other events that are coming into the application from other FireFly Nodes in the network. You might observe the problems solved in this architecture are similar to those in a message queuing system (like Apache Kafka, or a JMS/AMQP provider like ActiveMQ etc.). However, we cannot directly replace the internal logic with such a runtime - because FireFly’s job is to aggregate data from multiple runtimes that behave similarly to these: . | Private messaging in the Data Exchange | The blockchain ledger(s) themselves, which are a stream of sequenced events | The event dispatcher delivering messages to applications that have been sequenced by FireFly | . So FireFly provides the convenient REST based management interface to simplify the world for application developers, by aggregating the data from multiple locations, and delivering it to apps in a deterministic sequence. The sequence is made deterministic: . | Globally to all apps within the scope of the ledger, when a Blockchain ledger is used to pin events (see #10) | Locally for messages delivered through a single FireFly node into the network | Locally for all messages delivered to applications connected to a FireFly node, across blockchain | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#overview",
    "relUrl": "/architecture/internal_event_sequencing.html#overview"
  },"324": {
    "doc": "Internal Event Sequencing",
    "title": "App Instances",
    "content": ". | Broadcast messages to the network | Ingest ack when message persisted in local messages table | Consume events via Websocket connection into FireFly | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#app-instances",
    "relUrl": "/architecture/internal_event_sequencing.html#app-instances"
  },"325": {
    "doc": "Internal Event Sequencing",
    "title": "Outbound Sequencers",
    "content": ". | Broadcast or Private through IPFS or Private Data Storage | Long-running leader-elected jobs listening to the database (via event tables in SQL, etc.) | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#outbound-sequencers",
    "relUrl": "/architecture/internal_event_sequencing.html#outbound-sequencers"
  },"326": {
    "doc": "Internal Event Sequencing",
    "title": "Inbound Aggregator",
    "content": ". | Triggered each time an event is detected by the associated plugin. | It is the responsibility of the plugin to fire events sequentially. Can be workload managed but must be sequential. | . Events Table . | Deliberately lightweight persisted object, that is generated as a byproduct of other persistent actions. | Records the local sequence of a specific event within the local node. | The highest level event type is the confirmation of a message, however the table can be extended for more granularity on event types. | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#inbound-aggregator",
    "relUrl": "/architecture/internal_event_sequencing.html#inbound-aggregator"
  },"327": {
    "doc": "Internal Event Sequencing",
    "title": "Subscription Manager",
    "content": ". | Responsible for filtering and delivering batches of events to the active event dispatchers. | Records the latest offset confirmed by each dispatcher. | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#subscription-manager",
    "relUrl": "/architecture/internal_event_sequencing.html#subscription-manager"
  },"328": {
    "doc": "Internal Event Sequencing",
    "title": "Event Dispatcher",
    "content": ". | Created with leadership election when WebSocket connection is made from an app into FireFly. | Extensible to other dispatchers (AMQP, etc.). | . ",
    "url": "/firefly/architecture/internal_event_sequencing.html#event-dispatcher",
    "relUrl": "/architecture/internal_event_sequencing.html#event-dispatcher"
  },"329": {
    "doc": "Message",
    "title": "Message",
    "content": " ",
    "url": "/firefly/reference/types/message.html",
    "relUrl": "/reference/types/message.html"
  },"330": {
    "doc": "Message",
    "title": "Table of contents",
    "content": ". | Message . | Example | Field Descriptions | . | MessageHeader | . ",
    "url": "/firefly/reference/types/message.html#table-of-contents",
    "relUrl": "/reference/types/message.html#table-of-contents"
  },"331": {
    "doc": "Message",
    "title": "Message",
    "content": "Message is the envelope by which coordinated data exchange can happen between parties in the network. Data is passed by reference in these messages, and a chain of hashes covering the data and the details of the message, provides a verification against tampering. Example . { \"header\": { \"id\": \"4ea27cce-a103-4187-b318-f7b20fd87bf3\", \"type\": \"broadcast\", \"namespace\": \"default\" }, \"state\": \"confirmed\", \"data\": [ { \"id\": \"fdf9f118-eb81-4086-a63d-b06715b3bb4e\" } ] } . Field Descriptions . | Field Name | Description | Type | . | header | The message header contains all fields that are used to build the message hash | MessageHeader | . | hash | The hash of the message. Derived from the header, which includes the data hash | Bytes32 | . | batch | The UUID of the batch in which the message was pinned/transferred | UUID | . | state | The current state of the message | FFEnum | . | confirmed | The timestamp of when the message was confirmed/rejected | FFTime | . | data | The list of data elements attached to the message | DataRef[] | . | pins | For private messages, a unique pin hash:nonce is assigned for each topic | string[] | . ",
    "url": "/firefly/reference/types/message.html",
    "relUrl": "/reference/types/message.html"
  },"332": {
    "doc": "Message",
    "title": "MessageHeader",
    "content": "| Field Name | Description | Type | . | id | The UUID of the message. Unique to each message | UUID | . | cid | The correlation ID of the message. Set this when a message is a response to another message | UUID | . | type | The type of the message | FFEnum | . | txtype | The type of transaction used to order/deliver this message | FFEnum | . | created | The creation time of the message | FFTime | . | namespace | The namespace of the message | string | . | topics | A message topic associates this message with an ordered stream of data. A custom topic should be assigned - using the default topic is discouraged | string[] | . | tag | The message tag indicates the purpose of the message to the applications that process it | string | . | datahash | A single hash representing all data in the message. Derived from the array of data ids+hashes attached to this message | Bytes32 | . ",
    "url": "/firefly/reference/types/message.html#messageheader",
    "relUrl": "/reference/types/message.html#messageheader"
  },"333": {
    "doc": "Multi-party Systems",
    "title": "Enterprise multi-party systems",
    "content": " ",
    "url": "/firefly/overview/multiparty.html#enterprise-multi-party-systems",
    "relUrl": "/overview/multiparty.html#enterprise-multi-party-systems"
  },"334": {
    "doc": "Multi-party Systems",
    "title": "Table of contents",
    "content": ". | Introduction | Points of difference | . ",
    "url": "/firefly/overview/multiparty.html#table-of-contents",
    "relUrl": "/overview/multiparty.html#table-of-contents"
  },"335": {
    "doc": "Multi-party Systems",
    "title": "Introduction",
    "content": "Multi-party systems are a class of application empowered by the technology revolution of blockchain digital ledger technology (DLT), and emerging cryptographic proof technologies like zero-knowledge proofs (ZKPs) and trusted execution environments (TEEs). By combining these technologies with existing best practice technologies for data security in regulated industries, multi-party systems allow businesses to collaborate in ways previously impossible. Through agreement on a common source of truth, such as the completion of a step in a business process to proceed, or the existence and ownership of a unique asset, businesses can cut out huge inefficiencies in existing multi-party processes. New business and transaction models can be achieved, unlocking value in assets and data that were previously siloed within a single organization. Governance and incentive models can be created to enable secure collaboration in new ways, without compromising the integrity of an individual organization. The technology is most powerful in ecosystems of “coopetition”, where privacy and security requirements are high. Multi-party systems establish new models of trust, with easy to prove outcomes that minimize the need for third party arbitration, and costly investigation into disputes. ",
    "url": "/firefly/overview/multiparty.html#introduction",
    "relUrl": "/overview/multiparty.html#introduction"
  },"336": {
    "doc": "Multi-party Systems",
    "title": "Points of difference",
    "content": "Integration with existing systems of record is critical to unlock the potential of these new ecosystems. So multi-party systems embrace the existing investments of each party, rather than seeking to unify or replace them. Multi-party systems are different from centralized third-party systems, because each party retains sovereignty over: . | Their application instance | Their private data | Their business processes | Their proprietary business logic | Their internal business processes and IT controls | . ",
    "url": "/firefly/overview/multiparty.html#points-of-difference",
    "relUrl": "/overview/multiparty.html#points-of-difference"
  },"337": {
    "doc": "Multi-party Systems",
    "title": "Multi-party Systems",
    "content": " ",
    "url": "/firefly/overview/multiparty.html",
    "relUrl": "/overview/multiparty.html"
  },"338": {
    "doc": "Multiparty Event Sequencing",
    "title": "Multiparty Event Sequencing",
    "content": " ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html",
    "relUrl": "/architecture/multiparty_event_sequencing.html"
  },"339": {
    "doc": "Multiparty Event Sequencing",
    "title": "Table of contents",
    "content": ". | Transaction Submission | Blockchain Ordering | Message Assembly | Event Processing | . ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html#table-of-contents",
    "relUrl": "/architecture/multiparty_event_sequencing.html#table-of-contents"
  },"340": {
    "doc": "Multiparty Event Sequencing",
    "title": "Transaction Submission",
    "content": ". | An individual FireFly instance preserves the order that it received messages from application instances. | Where possible, batching is used to roll-up hundreds of transactions into a single blockchain transaction. | Blockchain allows these messages to be globally sequenced with messages submitted by other members of the network. | . ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html#transaction-submission",
    "relUrl": "/architecture/multiparty_event_sequencing.html#transaction-submission"
  },"341": {
    "doc": "Multiparty Event Sequencing",
    "title": "Blockchain Ordering",
    "content": ". | All member FireFly runtimes see every transaction in the same sequence. | This includes when transactions are being submitted by both sides concurrently. | . ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html#blockchain-ordering",
    "relUrl": "/architecture/multiparty_event_sequencing.html#blockchain-ordering"
  },"342": {
    "doc": "Multiparty Event Sequencing",
    "title": "Message Assembly",
    "content": ". | A queue of events is maintained for each matching app subscription. | The public/private payloads travel separately to the blockchain, and arrive at different times. FireFly assembles these together prior to delivery. | If data associated with a blockchain transaction is late, or does not arrive, all messages on the same “context” will be blocked. | It is good practice to send messages that don’t need to be processed in order, with different “context” fields. For example use the ID of your business transaction, or other long-running process / customer identifier. | . ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html#message-assembly",
    "relUrl": "/architecture/multiparty_event_sequencing.html#message-assembly"
  },"343": {
    "doc": "Multiparty Event Sequencing",
    "title": "Event Processing",
    "content": ". | Events are processed consistently by all parties. | All FireFly runtimes see every event that they are subscribed to, in the same sequence. | The submitter must also apply the logic only in the sequence ordered by the blockhain. It cannot assume the order even if it is the member that submitted it. | . ",
    "url": "/firefly/architecture/multiparty_event_sequencing.html#event-processing",
    "relUrl": "/architecture/multiparty_event_sequencing.html#event-processing"
  },"344": {
    "doc": "Multi-party process flow",
    "title": "Multi-party process flow",
    "content": " ",
    "url": "/firefly/overview/multiparty_process_flow.html",
    "relUrl": "/overview/multiparty_process_flow.html"
  },"345": {
    "doc": "Multi-party process flow",
    "title": "Table of contents",
    "content": ". | Building multi-party flows | Innovate fast | Consider the on-chain toolbox too | . ",
    "url": "/firefly/overview/multiparty_process_flow.html#table-of-contents",
    "relUrl": "/overview/multiparty_process_flow.html#table-of-contents"
  },"346": {
    "doc": "Multi-party process flow",
    "title": "Building multi-party flows",
    "content": "The ability to globally sequence events across parties is a game changing capability of multi-party systems. FireFly is designed to allow developers to harnesses that power in the application layer, to build sophisticated multi-party APIs and user experiences. | Build multi-party business processes where there is one agreed outcome: . | Agree the trigger, inputs, outputs of each step in the process | Agree any common “rules of the road” must be adhered to | . | Look back at your shared history, when deciding to commit to the next step: . | Fast rich-query cache, backed by a private database | Initiate the next step through automated or manual decision making | Only consider a step final once it’s multi-party sequence has been confirmed | . | Gain big efficiencies in how multi-party business processes work: . | Once locked in, a step is consider final - attested to by the party | If two parties submit conflicting actions, one wins, and one loses | Avoids complex compensation logic in the business orchestration layer | Provides one clear source of truth to quickly resolve multi-party disputes | . | Program multi-party apps using the tools you know: . | REST APIs for triggering the next step in a process, and querying history | WebSockets and Webhooks for events (pluggable to other event transports) | Remember - each party runs their own copy of the app, with their own private data | . | Allow each party to integrate into their existing core systems: . | Realtime or batch | Human workflows | Proprietary business logic that is unique to one party | . | Avoid sensitive data written to the blockchain: . | Works in bi-lateral and multi-lateral scenarios | Designed to limit leaking other “metadata” about the transaction as well | Share partial history with different participants in a | . | No requirement to write custom on-chain smart contract logic: . | Can be combined with rich custom on-chain logic as well | . | . ",
    "url": "/firefly/overview/multiparty_process_flow.html#building-multi-party-flows",
    "relUrl": "/overview/multiparty_process_flow.html#building-multi-party-flows"
  },"347": {
    "doc": "Multi-party process flow",
    "title": "Innovate fast",
    "content": "Building a successful multi-party system is often about business experimentation, and business results. Proving the efficiency gains, and new business models, made possible by working together in a new way under a new system of trust. Things that can get in the way of that innovation, can include concerns over data privacy, technology maturity, and constraints on autonomy of an individual party in the system. An easy to explain position on how new technology components are used, where data lives, and how business process independence is maintained can really help parties make the leap of faith necessary to take the step towards a new model. Keys to success often include building great user experiences that help digitize clunky decades old manual processes. Also easy to integrate with APIs, what embrace the existing core systems of record that are establish within each party. ",
    "url": "/firefly/overview/multiparty_process_flow.html#innovate-fast",
    "relUrl": "/overview/multiparty_process_flow.html#innovate-fast"
  },"348": {
    "doc": "Multi-party process flow",
    "title": "Consider the on-chain toolbox too",
    "content": "In the deterministic compute section we talked about the value that deterministic execution of multi-party logic can have. Either through on-chain execution, or advanced privacy preserving techniques. It’s important to state that almost every process can be enhanced with more sophisticated on-chain constructs like tokens. Maybe it’s to build a token economy that enhances the value parties get from the system, or encourages healthy participation (and discourages leaching value). Or maybe it’s to track exactly which party owns a document, asset, or action within a process using NFTs. There are also cases where the foundation constructs are insufficient to implement the level of automation or efficiency you need in your multi-party process. Here making the investment in building bespoke on-chain logic, or apply advanced cryptographic techniques, is the linchpin to a successful multi-party ecosystem. ",
    "url": "/firefly/overview/multiparty_process_flow.html#consider-the-on-chain-toolbox-too",
    "relUrl": "/overview/multiparty_process_flow.html#consider-the-on-chain-toolbox-too"
  },"349": {
    "doc": "Node Component Architecture",
    "title": "Node Component Architecture",
    "content": " ",
    "url": "/firefly/architecture/node_component_architecture.html",
    "relUrl": "/architecture/node_component_architecture.html"
  },"350": {
    "doc": "Node Component Architecture",
    "title": "Table of contents",
    "content": ". | What is a FireFly Node? | Runtimes | Responsibilities &amp; Pluggable Elements | Code Structure | . ",
    "url": "/firefly/architecture/node_component_architecture.html#table-of-contents",
    "relUrl": "/architecture/node_component_architecture.html#table-of-contents"
  },"351": {
    "doc": "Node Component Architecture",
    "title": "What is a FireFly Node?",
    "content": "The core architecture of a FireFly node can be broken down into the following three areas: . | The various runtimes encapsulating the node. | The core runtime responsibilities and pluggable elements. | The actual code running inside the node. | . ",
    "url": "/firefly/architecture/node_component_architecture.html#what-is-a-firefly-node",
    "relUrl": "/architecture/node_component_architecture.html#what-is-a-firefly-node"
  },"352": {
    "doc": "Node Component Architecture",
    "title": "Runtimes",
    "content": "What fundamentally is a node - left side of the above diagram. | It is a collection of multiple runtimes with a single unified HTTPS/Websocket API (exposed by the Core). | It has a private database, containing your private data, and data received from others in the network. | It has connectivity out to other parties in the network, through runtimes (Blockchain, Shared Filesystems, Messaging etc.). | . ",
    "url": "/firefly/architecture/node_component_architecture.html#runtimes",
    "relUrl": "/architecture/node_component_architecture.html#runtimes"
  },"353": {
    "doc": "Node Component Architecture",
    "title": "Responsibilities &amp; Pluggable Elements",
    "content": "What are the core runtime responsibilities, and pluggable elements - right side of the above diagram. | The core elements of function that FireFly performs, and which runtime is responsible. | This means some insight into core itself, and the jobs it performs, but not full code structure. | More importantly, what the split of responsibilities is between Connectors and Infrastructure Runtimes. | Connectors are the bridging runtimes, that know how to talk to a particular runtime. | They run separately to the core (like a microservice architecture of an app). | They can be written in any language (not just Go) - Java, TypeScript, Rust, Python, .NET etc. | They can use any network transport (not just HTTPS/Websockets) - GRPC, AMQP, UDP etc. | They connect to the core with a Golang shim - see separate Plugin Architecture discussion. | In some special cases (like the Database) the Golang shim does not need a connector runtime. | . | . | Infrastructure Runtimes are the core runtimes for multi-party system activities. | Blockchain nodes - Ethereum (Hyperledger Besu, Quorum, Geth), Hyperledger Fabric, Corda etc. | Shared strorage - IPFS etc. | Database - PostreSQL, CouchDB etc. | . | . | . | . ",
    "url": "/firefly/architecture/node_component_architecture.html#responsibilities--pluggable-elements",
    "relUrl": "/architecture/node_component_architecture.html#responsibilities--pluggable-elements"
  },"354": {
    "doc": "Node Component Architecture",
    "title": "Code Structure",
    "content": "What is the code structure inside the core. | The README.md is the reference for this. | Developers contributing to FireFly, on the core, or building new plugins, need this level of detail. | A reconciliation is underway to ensure the medium-level view correlates well with this code structure. | . | . ",
    "url": "/firefly/architecture/node_component_architecture.html#code-structure",
    "relUrl": "/architecture/node_component_architecture.html#code-structure"
  },"355": {
    "doc": "Example Transaction Flow",
    "title": "Example Transaction Flow (Ping Pong)",
    "content": " ",
    "url": "/firefly/architecture/ping_pong_txflow.html#example-transaction-flow-ping-pong",
    "relUrl": "/architecture/ping_pong_txflow.html#example-transaction-flow-ping-pong"
  },"356": {
    "doc": "Example Transaction Flow",
    "title": "Table of contents",
    "content": ". | Overview | Broadcast Public Description of Binary Data Asset (Member 1) | Receive Public Description &amp; Request Asset Data (Member 2) | Authorize &amp; Transfer Data (Member 1) | Receive Data Asset (Member 2) | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#table-of-contents",
    "relUrl": "/architecture/ping_pong_txflow.html#table-of-contents"
  },"357": {
    "doc": "Example Transaction Flow",
    "title": "Overview",
    "content": ". This demonstrates the problem that at its core FireFly is there to solve. The internal plumbing complexity of just a very simple set of Enterprise blockchain / multi-party system interactions. | Party A: Establish existence of a digital asset. | Nothing more than some binary data (an image, a document, a specification etc.). | . | Party A: Broadcast some information about that asset to everyone, using blockchain to record, sequence and propagate. | So people can find it, or part of a more sophisticated workflow. | . | Party B: Request the actual data - with evidence of that request tied to the blockchain. | Including some private data that’s sent to the Party A, reliably off-chain. | . | Party A: Authorize the request, and send the data privately to Party B. | In this example there’s no blockchain involved in this step. | . | . This is the kind of thing that enterprise projects have been solving ground-up since the dawn of enterprise blockchain, and the level of engineering required that is completely detached from business value, is very high. The “tramlines” view shows how FireFly’s pluggable model makes the job of the developer really simple: . | A few simple API calls from a modern web app. | Event triggered execution of application logic. | . This is deliberately a simple flow, and all kinds of additional layers might well layer on (and fit within the FireFly model): . | NFTs to track ownership etc. related to the digital asset. | Tokenized rewards/payments integrated with the authorization of the transfer of data. | Proof of deterministic execution of the logic to perform the authorization (on-chain, TEEs, ZKPs). | Human workflow, that is of course completely non-deterministic. | Multiple additional process steps, deterministic or not. | Inclusion of multiple additional parties (maybe it’s a request-for-tender, submit-tender flow for example). | etc. | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#overview",
    "relUrl": "/architecture/ping_pong_txflow.html#overview"
  },"358": {
    "doc": "Example Transaction Flow",
    "title": "Broadcast Public Description of Binary Data Asset (Member 1)",
    "content": ". | Upload Blob of the actual data . | Returns a hash of the payload | . | Upload JSON containing the public index data . | Includes the hash of the full payload | . | Send a broadcast message with the public index data . | Agree upon a primary key of the data as the “context” | . | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#broadcast-public-description-of-binary-data-asset-member-1",
    "relUrl": "/architecture/ping_pong_txflow.html#broadcast-public-description-of-binary-data-asset-member-1"
  },"359": {
    "doc": "Example Transaction Flow",
    "title": "Receive Public Description &amp; Request Asset Data (Member 2)",
    "content": ". | Store data in your own off-chain database for rich, efficient query | Run automated logic to decide if you want to request the full data | Upload JSON for data request | Send a private message . | Backed by blockchain in this flow | . | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#receive-public-description--request-asset-data-member-2",
    "relUrl": "/architecture/ping_pong_txflow.html#receive-public-description--request-asset-data-member-2"
  },"360": {
    "doc": "Example Transaction Flow",
    "title": "Authorize &amp; Transfer Data (Member 1)",
    "content": ". | Inpsect the request data | Retrieve data asset by hash | Send the private data in a private message . | No blockchain in this flow | . | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#authorize--transfer-data-member-1",
    "relUrl": "/architecture/ping_pong_txflow.html#authorize--transfer-data-member-1"
  },"361": {
    "doc": "Example Transaction Flow",
    "title": "Receive Data Asset (Member 2)",
    "content": ". | Receive a link to your local copy of the asset data | . ",
    "url": "/firefly/architecture/ping_pong_txflow.html#receive-data-asset-member-2",
    "relUrl": "/architecture/ping_pong_txflow.html#receive-data-asset-member-2"
  },"362": {
    "doc": "Example Transaction Flow",
    "title": "Example Transaction Flow",
    "content": " ",
    "url": "/firefly/architecture/ping_pong_txflow.html",
    "relUrl": "/architecture/ping_pong_txflow.html"
  },"363": {
    "doc": "Plugin Architecture",
    "title": "Plugin Architecture",
    "content": " ",
    "url": "/firefly/architecture/plugin_architecture.html",
    "relUrl": "/architecture/plugin_architecture.html"
  },"364": {
    "doc": "Plugin Architecture",
    "title": "Table of contents",
    "content": ". | Overview | FireFly Core | Plugin for Connector | Connector | Infrastructure Runtime | . This diagram shows the various plugins that are currently in the codebase and the layers in each plugin . This diagram shows the details of what goes into each layer of a FireFly plugin . ",
    "url": "/firefly/architecture/plugin_architecture.html#table-of-contents",
    "relUrl": "/architecture/plugin_architecture.html#table-of-contents"
  },"365": {
    "doc": "Plugin Architecture",
    "title": "Overview",
    "content": "The FireFly node is built for extensibility, with separate pluggable runtimes orchestrated into a common API for developers. The mechanics of that pluggability for developers of new connectors is explained below: . This architecture is designed to provide separations of concerns to account for: . | Differences in code language for the low-level connection to a backend (Java for Corda for example) | Differences in transports, particularly for delivery of events: . | Between FireFly Core and the Connector . | Different transports other than HTTPS/WebSockets (GRPC etc.), and different wire protocols (socket.io, etc.) | . | Between the Connector and the underlying Infrastructure Runtime . | Often this is heavy lifting engineering within the connector | . | . | Differences in High Availability (HA) / Scale architectures . | Between FireFly Core, and the Connector . | Often for event management, and active/passive connector runtime is sufficient | . | Between the Connector and the Infrastructure Runtime . | The infrastructure runtimes have all kinds of variation here… think of the potential landscape here from PostreSQL through Besu/Fabric/Corda, to Hyperledger Avalon and even Main-net ethereum | . | . | . ",
    "url": "/firefly/architecture/plugin_architecture.html#overview",
    "relUrl": "/architecture/plugin_architecture.html#overview"
  },"366": {
    "doc": "Plugin Architecture",
    "title": "FireFly Core",
    "content": ". | Golang | N-way scalable cluster . | Database is also pluggable via this architecture | . | No long lived in-memory processing . | All micro-batching must be recoverable | . | Driven by single configuration set . | Viper semantics - file, env var, cmdline flags | . | . ",
    "url": "/firefly/architecture/plugin_architecture.html#firefly-core",
    "relUrl": "/architecture/plugin_architecture.html#firefly-core"
  },"367": {
    "doc": "Plugin Architecture",
    "title": "Plugin for Connector",
    "content": ". | Golang | Statically compiled in support at runtime . | Go dynamic plugin support too immature | . | Must be 100% FLOSS code (no GPL/LGPL etc.) | Contributed via PR to FF Core | Intended to be lightweight binding/mapping | Must adhere to FF Core Coding Standards | Scrutiny on addition of new frameworks/transports | . ",
    "url": "/firefly/architecture/plugin_architecture.html#plugin-for-connector",
    "relUrl": "/architecture/plugin_architecture.html#plugin-for-connector"
  },"368": {
    "doc": "Plugin Architecture",
    "title": "Connector",
    "content": ". | Node.js / Java / Golang, etc. | Runs/scales independently from FF core | Coded in any language, OSS or proprietary | One runtime or multiple | HA model can be active/passive or active/active | Expectation is all plugins need a connector . | Some exceptions exist (e.g. database plugin) | . | . ",
    "url": "/firefly/architecture/plugin_architecture.html#connector",
    "relUrl": "/architecture/plugin_architecture.html#connector"
  },"369": {
    "doc": "Plugin Architecture",
    "title": "Infrastructure Runtime",
    "content": ". | Besu, Quorum, Corda, Fabric, IPFS, Kafka, etc. | Runs/scales independently from FF Core | Coded in any language, OSS or proprietary | Not specific to FireFly | HA model can be active/passive or active/active | . ",
    "url": "/firefly/architecture/plugin_architecture.html#infrastructure-runtime",
    "relUrl": "/architecture/plugin_architecture.html#infrastructure-runtime"
  },"370": {
    "doc": "Privately send data",
    "title": "Privately send data",
    "content": " ",
    "url": "/firefly/tutorials/private_send.html",
    "relUrl": "/tutorials/private_send.html"
  },"371": {
    "doc": "Privately send data",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info | Example 1: Pinned private send of in-line string data | Example message response | Example 2: Unpinned private send of in-line string data | Example 3: Inline object data to a topic (no datatype verification) | Notes on why setting a topic is important | Example 3: Upload a blob with metadata and send privately . | Multipart form post of a file | Example data response from Blob upload | Send the uploaded data privately | . | . ",
    "url": "/firefly/tutorials/private_send.html#table-of-contents",
    "relUrl": "/tutorials/private_send.html#table-of-contents"
  },"372": {
    "doc": "Privately send data",
    "title": "Quick reference",
    "content": ". | Sends a message to a restricted set of parties . | The message describes who sent it, to whom, and exactly what data was sent | . | A message has one or more attached pieces of business data . | Can be sent in-line, uploaded in advanced, or received from other parties | Can include smaller JSON payloads suitable for database storage . | These can be verified against a datatype | . | Can include references to large (multi megabyte/gigabyte) Blob data | . | A group specifies who has visibility to the data . | The author must be included in the group - auto-added if omitted | Can be specified in-line in the message by listing recipients directly | Can be referred to by hash | . | Private sends are optionally sequenced via pinning to the blockchain . | If the send is pinned: . | The blockchain does not contain any data, just a hash pin . | Even the ordering context (topic) is obscured in the on-chain data | This is true regardless of whether a restricted set of participants are maintaining the ledger, such as in the case of a Fabric Channel. | . | The message should not be considered confirmed (even by the sender) until it has been sequenced via the blockchain and a message_confirmed event occurs | Batched for efficiency . | One batch can pin hundreds of private message sends | The batch flows privately off-chain from the sender to each recipient | . | . | If the send is unpinned: . | No data is written to the blockchain at all | The message is marked confirmed immediately . | The sender receives a message_confirmed event immediately | . | The other parties in the group get message_confirmed events as soon as the data arrives | . | . | . ",
    "url": "/firefly/tutorials/private_send.html#quick-reference",
    "relUrl": "/tutorials/private_send.html#quick-reference"
  },"373": {
    "doc": "Privately send data",
    "title": "Additional info",
    "content": ". | Key Concepts: Private data exchange | Swagger: POST /api/v1/namespaces/{ns}/messages/private | . ",
    "url": "/firefly/tutorials/private_send.html#additional-info",
    "relUrl": "/tutorials/private_send.html#additional-info"
  },"374": {
    "doc": "Privately send data",
    "title": "Example 1: Pinned private send of in-line string data",
    "content": "POST /api/v1/namespaces/default/send/message . { \"data\": [ { \"value\": \"a string\" } ], \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] } } . ",
    "url": "/firefly/tutorials/private_send.html#example-1-pinned-private-send-of-in-line-string-data",
    "relUrl": "/tutorials/private_send.html#example-1-pinned-private-send-of-in-line-string-data"
  },"375": {
    "doc": "Privately send data",
    "title": "Example message response",
    "content": "Status: 202 Accepted - the message is on it’s way, but has not yet been confirmed. Issue #112 proposes adding an option to wait for the message to be confirmed by the blockchain before returning, with 200 OK. { \"header\": { \"id\": \"c387e9d2-bdac-44cc-9dd5-5e7f0b6b0e58\", // uniquely identifies this private message \"type\": \"private\", // set automatically \"txtype\": \"batch_pin\", // message will be batched, and sequenced via the blockchain \"author\": \"0x0a65365587a65ce44938eab5a765fe8bc6532bdf\", // set automatically in this example to the node org \"created\": \"2021-07-02T02:37:13.4642085Z\", // set automatically \"namespace\": \"default\", // the 'default' namespace was set in the URL // The group hash is calculated from the resolved list of group participants. // The first time a group is used, the participant list is sent privately along with the // batch of messages in a `groupinit` message. \"group\": \"2aa5297b5eed0c3a612a667c727ca38b54fb3b5cc245ebac4c2c7abe490bdf6c\", \"topics\": [ \"default\" // the default topic that the message is published on, if no topic is set ], // datahash is calculated from the data array below \"datahash\": \"24b2d583b87eda952fa00e02c6de4f78110df63218eddf568f0240be3d02c866\" }, \"hash\": \"423ad7d99fd30ff679270ad2b6b35cdd85d48db30bafb71464ca1527ce114a60\", // hash of the header \"state\": \"ready\", // this message is stored locally but not yet confirmed \"data\": [ // one item of data was stored { \"id\": \"8d8635e2-7c90-4963-99cc-794c98a68b1d\", // can be used to query the data in the future \"hash\": \"c95d6352f524a770a787c16509237baf7eb59967699fb9a6d825270e7ec0eacf\" // sha256 hash of `\"a string\"` } ] } . ",
    "url": "/firefly/tutorials/private_send.html#example-message-response",
    "relUrl": "/tutorials/private_send.html#example-message-response"
  },"376": {
    "doc": "Privately send data",
    "title": "Example 2: Unpinned private send of in-line string data",
    "content": "Set header.txtype: \"none\" to disable pinning of the private message send to the blockchain. The message is sent immediately (no batching) over the private data exchange. POST /api/v1/namespaces/default/send/message . { \"header\": { \"txtype\": \"none\" }, \"data\": [ { \"value\": \"a string\" } ], \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] } } . ",
    "url": "/firefly/tutorials/private_send.html#example-2-unpinned-private-send-of-in-line-string-data",
    "relUrl": "/tutorials/private_send.html#example-2-unpinned-private-send-of-in-line-string-data"
  },"377": {
    "doc": "Privately send data",
    "title": "Example 3: Inline object data to a topic (no datatype verification)",
    "content": "It is very good practice to set a tag and topic in each of your messages: . | tag should tell the apps receiving the private send (including the local app), what to do when it receives the message. Its the reason for the send - an application specific type for the message. | topic should be something like a well known identifier that relates to the information you are publishing. It is used as an ordering context, so all sends on a given topic are assured to be processed in order. | . POST /api/v1/namespaces/default/send/message . { \"header\": { \"tag\": \"new_widget_created\", \"topics\": [\"widget_id_12345\"] }, \"group\": { \"members\": [ { \"identity\": \"org_1\" } ] }, \"data\": [ { \"value\": { \"id\": \"widget_id_12345\", \"name\": \"superwidget\" } } ] } . ",
    "url": "/firefly/tutorials/private_send.html#example-3-inline-object-data-to-a-topic-no-datatype-verification",
    "relUrl": "/tutorials/private_send.html#example-3-inline-object-data-to-a-topic-no-datatype-verification"
  },"378": {
    "doc": "Privately send data",
    "title": "Notes on why setting a topic is important",
    "content": "The FireFly aggregator uses the topic (obfuscated on chain) to determine if a message is the next message in an in-flight sequence for any groups the node is involved in. If it is, then that message must receive all off-chain private data and be confirmed before any subsequent messages can be confirmed on the same sequence. So if you use the same topic in every message, then a single failed send on one topic blocks delivery of all messages between those parties, until the missing data arrives. Instead it is best practice to set the topic on your messages to value that identifies an ordered stream of business processing. Some examples: . | A long-running business process instance identifier assigned at initiation | A real-world business transaction identifier used off-chain | The agreed identifier of an asset you are attaching a stream of evidence to | An NFT identifier that is assigned to an asset (digital twin scenarios) | An agreed primary key for a data resource being reconciled between multiple parties | . The topic field is an array, because there are cases (such as merging two identifiers) where you need a message to be deterministically ordered across multiple sequences. However, this is an advanced use case and you are likely to set a single topic on the vast majority of your messages. ",
    "url": "/firefly/tutorials/private_send.html#notes-on-why-setting-a-topic-is-important",
    "relUrl": "/tutorials/private_send.html#notes-on-why-setting-a-topic-is-important"
  },"379": {
    "doc": "Privately send data",
    "title": "Example 3: Upload a blob with metadata and send privately",
    "content": "Here we make two API calls. | Create the data object explicitly, using a multi-party form upload | . | You can also just post JSON to this endpoint | . | Privately send a message referring to that data | . | The Blob is sent privately to each party | A pin goes to the blockchain | The metadata goes into a batch with the message | . Multipart form post of a file . Example curl command (Linux/Mac) to grab an image from the internet, and pipe it into a multi-part form post to FireFly. Note we use autometa to cause FireFly to automatically add the filename, and size, to the JSON part of the data object for us. curl -sLo - https://github.com/hyperledger/firefly/raw/main/docs/firefly_logo.png \\ | curl --form autometa=true --form file=@- \\ http://localhost:5000/api/v1/namespaces/default/data . Example data response from Blob upload . Status: 200 OK - your data is uploaded to your local FireFly node . At this point the data has not be shared with anyone else in the network . { // A uniquely generated ID, we can refer to when sending this data to other parties \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\", \"validator\": \"json\", // the \"value\" part is JSON \"namespace\": \"default\", // from the URL // The hash is a combination of the hash of the \"value\" metadata, and the // hash of the blob \"hash\": \"997af6a9a19f06cc8a46872617b8bf974b106f744b2e407e94cc6959aa8cf0b8\", \"created\": \"2021-07-01T20:20:35.5462306Z\", \"value\": { \"filename\": \"-\", // dash is how curl represents the filename for stdin \"size\": 31185 // the size of the blob data }, \"blob\": { // A hash reference to the blob \"hash\": \"86e6b39b04b605dd1b03f70932976775962509d29ae1ad2628e684faabe48136\" } } . Send the uploaded data privately . Just include a reference to the id returned from the upload. POST /api/v1/namespaces/default/send/message . { \"data\": [ { \"id\": \"97eb750f-0d0b-4c1d-9e37-1e92d1a22bb8\" } ], \"group\":{ \"members\": [ { \"identity\":\"org_1\" } ] } } . ",
    "url": "/firefly/tutorials/private_send.html#example-3-upload-a-blob-with-metadata-and-send-privately",
    "relUrl": "/tutorials/private_send.html#example-3-upload-a-blob-with-metadata-and-send-privately"
  },"380": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned Blockchain",
    "content": " ",
    "url": "/firefly/overview/public_vs_permissioned.html#public-and-permissioned-blockchain",
    "relUrl": "/overview/public_vs_permissioned.html#public-and-permissioned-blockchain"
  },"381": {
    "doc": "Public and Permissioned",
    "title": "Table of contents",
    "content": ". | Public and Permissioned Blockchain | Public blockchain variations | Common public considerations | FireFly architecture for public chains | . ",
    "url": "/firefly/overview/public_vs_permissioned.html#table-of-contents",
    "relUrl": "/overview/public_vs_permissioned.html#table-of-contents"
  },"382": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned Blockchain",
    "content": "A separate choice to the technology for your blockchain, is what combination of blockchain ecosystems you will integrate with. There are a huge variety of options, and increasingly you might find yourself integrating with multiple ecosystems in your solutions. A rough (and incomplete) high level classification of the blockchains available is as follows: . | Layer 1 public blockchains . | This is where most token ecosystems are rooted | . | Layer 2 public scaling solutions backed by a Layer 1 blockchain . | These are increasing where transaction execution takes place that needs to be reflected eventually back to a Layer 1 blockchain (due to cost/congestion in the Layer 1 chains) | . | Permissioned side-chains . | Historically this has been where the majority of production adoption of enterprise blockchain has focussed, due to the predictable cost, performance, and ability to manage the validator set and boundary API security alongside a business network governance policy | These might have their state check-pointed/rolled-up to a Layer 2 or Layer 1 chain | . | . The lines are blurring between these categorizations as the technologies and ecosystems evolve. ",
    "url": "/firefly/overview/public_vs_permissioned.html#public-and-permissioned-blockchain-1",
    "relUrl": "/overview/public_vs_permissioned.html#public-and-permissioned-blockchain-1"
  },"383": {
    "doc": "Public and Permissioned",
    "title": "Public blockchain variations",
    "content": "For the public Layer 1 and 2 solutions, there are too many subclassifications to go into in detail here: . | Whether ecosystems supports custom smart contract execution (EVM based is most common, where contracts are supported) | What types of token standards are supported, or other chain specific embedded smart contracts | Whether the chain follows an unspent transaction output (UTXO) or Account model | How value is bridged in-to / out-of the ecosystem | How the validator set of the chain is established - most common is Proof of Stake (PoS) | How data availability is maintained - to check the working of the validators ensure the historical state is not lost | The consensus algorithm, and how it interacts with the consensus of other blockchains | How state in a Layer 2 is provable in a parent Layer 1 chain (rollup technologies etc.) | . ",
    "url": "/firefly/overview/public_vs_permissioned.html#public-blockchain-variations",
    "relUrl": "/overview/public_vs_permissioned.html#public-blockchain-variations"
  },"384": {
    "doc": "Public and Permissioned",
    "title": "Common public considerations",
    "content": "The thing most consistent across public blockchain technologies, is that the technical decisions are backed by token economics. Put simply, creating a system where it’s more financially rewarding to behave honestly, than it is to subvert and cheat the system. This means that participation costs, and that the mechanisms needed to reliably get your transactions into these systems are complex. Also that the time it might take to get a transaction onto the chain can be much longer than for a permissioned blockchain, with the potential to have to make a number of adjustments/resubmissions. The choice of whether to run your own node, or use a managed API, to access these blockchain ecosystems is also a factor in the behavior of the transaction submission and event streaming. ",
    "url": "/firefly/overview/public_vs_permissioned.html#common-public-considerations",
    "relUrl": "/overview/public_vs_permissioned.html#common-public-considerations"
  },"385": {
    "doc": "Public and Permissioned",
    "title": "FireFly architecture for public chains",
    "content": "One of the fastest evolving aspects of the Hyperledger FireFly ecosystem, is how it facilitates enterprises to participate in these. The architecture is summarized as follows: . | New FireFly Transaction Manager runtime . | Operates as a microservice extension of the FireFly Core | Uses the operation resource within FireFly Core to store and update state | Runs as a singleton and is responsible for nonce assignment | Takes as much heavy lifting away from blockchain specific connectors as possible | . | Lightweight FireFly Connector API (ffcapi) . | Simple synchronous RPC operations that map to the most common operations supported across public blockchain technologies | Examples: . | Find the next nonce for a given signing key | Serialize a transaction from a set of JSON inputs and an interface definition | Submit an un-signed transaction with a given gas price to the blockchain, via a signing wallet | Establish a new block listener | Poll for new blocks | Establish a new event log listener | Poll for new events | . | . | Pluggable Policy Engine . | Invoked to make decisions on transaction submission | Responsible for gas price calculation | Able to intervene and adjust the characteristics of signing/submission | OSS reference implementation provided with Gas Station REST API integration | . | Confirmation Manager . | Extracted from the Ethconnect codebase | Coupled to both transaction submission and event confirmation | Embeds an efficient block cache | . | Event Streams . | Extracted from the Ethconnect codebase | Checkpoint restart based reliable at-least-once delivery of events | WebSockets interface upstream to FireFly Core | . | . This evolution involves a significant refactoring of components used for production solutions in the FireFly Ethconnect microservice since mid 2018. This was summarized in firefly-ethconnect#149, and cumulated in the creation of a new repository in 2022. You can follow the progress and contribute in this repo: https://github.com/hyperledger/firefly-transaction-manager . ",
    "url": "/firefly/overview/public_vs_permissioned.html#firefly-architecture-for-public-chains",
    "relUrl": "/overview/public_vs_permissioned.html#firefly-architecture-for-public-chains"
  },"386": {
    "doc": "Public and Permissioned",
    "title": "Public and Permissioned",
    "content": " ",
    "url": "/firefly/overview/public_vs_permissioned.html",
    "relUrl": "/overview/public_vs_permissioned.html"
  },"387": {
    "doc": "Explore messages",
    "title": "Explore messages",
    "content": " ",
    "url": "/firefly/tutorials/query_messages.html",
    "relUrl": "/tutorials/query_messages.html"
  },"388": {
    "doc": "Explore messages",
    "title": "Table of contents",
    "content": ". | Quick reference | Additional info . | Example 1: Query confirmed messages | . | Example response . | Example 2: Query all messages | . | . ",
    "url": "/firefly/tutorials/query_messages.html#table-of-contents",
    "relUrl": "/tutorials/query_messages.html#table-of-contents"
  },"389": {
    "doc": "Explore messages",
    "title": "Quick reference",
    "content": "The FireFly Explorer is a great way to view the messages sent and received by your node. Just open /ui on your FireFly node to access it. This builds on the APIs to query and filter messages, described below . ",
    "url": "/firefly/tutorials/query_messages.html#quick-reference",
    "relUrl": "/tutorials/query_messages.html#quick-reference"
  },"390": {
    "doc": "Explore messages",
    "title": "Additional info",
    "content": ". | Reference: API Query Syntax | Swagger: GET /api/v1/namespaces/{ns}/messages | . Example 1: Query confirmed messages . These are the messages ready to be processed in your application. All data associated with the message (including Blob attachments) is available, and if they are sequenced by the blockchain, then those blockchain transactions are complete. The order in which you process messages should be determined by absolute order of message_confirmed events - queryable via the events collection, or through event listeners (discussed next in the getting started guide). That is because messages are ordered by timestamp, which is potentially subject to adjustments of the clock. Whereas events are ordered by the insertion order into the database, and as such changes in the clock do not affect the order. GET /api/v1/namespaces/{ns}/messages?pending=false&amp;limit=100 . ",
    "url": "/firefly/tutorials/query_messages.html#additional-info",
    "relUrl": "/tutorials/query_messages.html#additional-info"
  },"391": {
    "doc": "Explore messages",
    "title": "Example response",
    "content": "[ { \"header\": { \"id\": \"423302bb-abfc-4d64-892d-38b2fdfe1549\", \"type\": \"private\", // this was a private send \"txtype\": \"batch_pin\", // pinned in a batch to the blockchain \"author\": \"0x1d14b65d2dd5c13f6cb6d3dc4aa13c795a8f3b28\", \"created\": \"2021-07-02T03:09:40.2606238Z\", \"namespace\": \"default\", \"group\": \"2aa5297b5eed0c3a612a667c727ca38b54fb3b5cc245ebac4c2c7abe490bdf6c\", // sent to this group \"topic\": [ \"widget_id_12345\" ], \"tag\": \"new_widget_created\", \"datahash\": \"551dd261e80ce76b1908c031cff8a707bd76376d6eddfdc1040c2ed6481ec8dd\" }, \"hash\": \"bf2ca94db8c31bae3cae974bb626fa822c6eee5f572d274d72281e72537b30b3\", \"batch\": \"f7ac773d-885a-4d73-ac6b-c09f5346a051\", // the batch ID that pinned this message to the chain \"state\": \"confirmed\", // message is now confirmed \"confirmed\": \"2021-07-02T03:09:49.9207211Z\", // timestamp when this node confirmed the message \"data\": [ { \"id\": \"914eed77-8789-451c-b55f-ba9570a71eba\", \"hash\": \"9541cabc750c692e553a421a6c5c07ebcae820774d2d8d0b88fac2a231c10bf2\" } ], \"pins\": [ // A \"pin\" is an identifier that is used by FireFly for sequencing messages. // // For private messages, it is an obfuscated representation of the sequence of this message, // on a topic, within this group, from this sender. There will be one pin per topic. You will find these // pins in the blockchain transaction, as well as the off-chain data. // Each one is unqiue, and without the group hash, very difficult to correlate - meaning // the data on-chain provides a high level of privacy. // // Note for broadcast (which does not require obfuscation), it is simply a hash of the topic. // So you will see the same pin for all messages on the same topic. \"ee56de6241522ab0ad8266faebf2c0f1dc11be7bd0c41d847998135b45685b77\" ] } ] . Example 2: Query all messages . The natural sort order the API will return for messages is: . | Pending messages first . | In descending created timestamp order | . | Confirmed messages . | In descending confirmed timestamp order | . | . GET /api/v1/namespaces/{ns}/messages . ",
    "url": "/firefly/tutorials/query_messages.html#example-response",
    "relUrl": "/tutorials/query_messages.html#example-response"
  },"392": {
    "doc": "Release Guide",
    "title": "Release Guide",
    "content": " ",
    "url": "/firefly/contributors/release_guide.html",
    "relUrl": "/contributors/release_guide.html"
  },"393": {
    "doc": "Release Guide",
    "title": "Table of contents",
    "content": ". | Release Guide . | Versioning scheme | The manifest.json file | Creating a new release . | 1) Navigate to the release page for the repo | 2) Click the Draft a new release button | 3) Fill out the form for your release | . | Automatic Docker builds | . | . This guide will walk you through creating a release. ",
    "url": "/firefly/contributors/release_guide.html#table-of-contents",
    "relUrl": "/contributors/release_guide.html#table-of-contents"
  },"394": {
    "doc": "Release Guide",
    "title": "Versioning scheme",
    "content": "FireFly follows semantic versioning. For more details on how we determine which version to use please see the Versioning Scheme guide. ",
    "url": "/firefly/contributors/release_guide.html#versioning-scheme",
    "relUrl": "/contributors/release_guide.html#versioning-scheme"
  },"395": {
    "doc": "Release Guide",
    "title": "The manifest.json file",
    "content": "FireFly has a manifest.json file in the root of the repo. This file contains a list of versions (both tag and sha) for each of the microservices that should be used with this specific commit. If you need FireFly to use a newer version of a microservice listed in this file, you should update the manifest.json file, commit it, and include it in your PR. This will trigger an end-to-end test run, using the specified versions. Here is an example of what the manifest.json looks like: . { \"ethconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-ethconnect\", \"tag\": \"v3.0.4\", \"sha\": \"0b7ce0fb175b5910f401ff576ced809fe6f0b83894277c1cc86a73a2d61c6f41\" }, \"fabconnect\": { \"image\": \"ghcr.io/hyperledger/firefly-fabconnect\", \"tag\": \"v0.9.0\", \"sha\": \"a79a4c66b0a2551d5122d019c15c6426e8cdadd6566ce3cbcb36e008fb7861ca\" }, \"dataexchange-https\": { \"image\": \"ghcr.io/hyperledger/firefly-dataexchange-https\", \"tag\": \"v0.9.0\", \"sha\": \"0de5b1db891a02871505ba5e0507821416d9fa93c96ccb4b1ba2fac45eb37214\" }, \"tokens-erc1155\": { \"image\": \"ghcr.io/hyperledger/firefly-tokens-erc1155\", \"tag\": \"v0.9.0-20211019-01\", \"sha\": \"aabc6c483db408896838329dab5f4b9e3c16d1e9fa9fffdb7e1ff05b7b2bbdd4\" } } . NOTE: You can run make manifest in the FireFly core source directory, and a script will run to automatically get the latests non-pre-release version of each of FireFly’s microservices. If you need to use a snapshot or pre-release version you should edit manifest.json file manually, as this script will not fetch those versions. ",
    "url": "/firefly/contributors/release_guide.html#the-manifestjson-file",
    "relUrl": "/contributors/release_guide.html#the-manifestjson-file"
  },"396": {
    "doc": "Release Guide",
    "title": "Creating a new release",
    "content": "Releases and builds are managed by GitHub. New binaries and/or Docker images will automatically be created when a new release is published. The easiest way to create a release is through the web UI for the repo that you wish to release. 1) Navigate to the release page for the repo . 2) Click the Draft a new release button . 3) Fill out the form for your release . It is recommended to start with the auto-generated release notes. Additional notes can be added as-needed. ",
    "url": "/firefly/contributors/release_guide.html#creating-a-new-release",
    "relUrl": "/contributors/release_guide.html#creating-a-new-release"
  },"397": {
    "doc": "Release Guide",
    "title": "Automatic Docker builds",
    "content": "After cutting a new release, a GitHub Action will automatically start a new Docker build, if the repo has a Docker image associated with it. You can check the status of the build by clicking the “Actions” tab along the top of the page, for that repo. ",
    "url": "/firefly/contributors/release_guide.html#automatic-docker-builds",
    "relUrl": "/contributors/release_guide.html#automatic-docker-builds"
  },"398": {
    "doc": "③ Use the Sandbox",
    "title": "Use the Sandbox",
    "content": " ",
    "url": "/firefly/gettingstarted/sandbox.html#use-the-sandbox",
    "relUrl": "/gettingstarted/sandbox.html#use-the-sandbox"
  },"399": {
    "doc": "③ Use the Sandbox",
    "title": "Table of contents",
    "content": ". | Previous steps: Start your environment | Video walkthrough | What is the FireFly Sandbox? | What is the FireFly Explorer? | Open the FireFly Sandbox for the first member | Sandbox Layout . | Left column: Prepare your request | Middle column: Preview server code and see response | Right column: Events received on the WebSocket | . | Messages . | Things to try out | . | Tokens . | Things to try out | . | Contracts . | Things to try out | . | Go forth and build! | . ",
    "url": "/firefly/gettingstarted/sandbox.html#table-of-contents",
    "relUrl": "/gettingstarted/sandbox.html#table-of-contents"
  },"400": {
    "doc": "③ Use the Sandbox",
    "title": "Previous steps: Start your environment",
    "content": "If you haven’t started a FireFly stack already, please go back to the previous step and read the guide on how to Start your environment. ← ② Start your environment . Now that you have a full network of three Supernodes running on your machine, let’s look at the first two components that you will interact with: the FireFly Sandbox and the FireFly Explorer. ",
    "url": "/firefly/gettingstarted/sandbox.html#previous-steps-start-your-environment",
    "relUrl": "/gettingstarted/sandbox.html#previous-steps-start-your-environment"
  },"401": {
    "doc": "③ Use the Sandbox",
    "title": "Video walkthrough",
    "content": "This video is a walkthrough of the FireFly Sandbox and FireFly Explorer from the FireFly 1.0 launch webinar. At this point you should be able to follow along and try all these same things on your own machine. ",
    "url": "/firefly/gettingstarted/sandbox.html#video-walkthrough",
    "relUrl": "/gettingstarted/sandbox.html#video-walkthrough"
  },"402": {
    "doc": "③ Use the Sandbox",
    "title": "What is the FireFly Sandbox?",
    "content": ". The FireFly Sandbox sits logically outside the Supernode, and it acts like an “end-user” application written to use FireFly’s API. In your setup, you have one Sandbox per member, each talking to their own FireFly API. The purpose of the Sandbox is to provide a quick and easy way to try out all of the fundamental building blocks that FireFly provides. It also shows developers, through example code snippets, how they would implement the same functionality in their own app’s backend. 🗒 Technical details: The FireFly Sandbox is an example “full-stack” web app. It has a backend written in TypeScript / Node.js, and a frontend in TypeScript / React. When you click a button in your browser, the frontend makes a request to the backend, which then uses the FireFly Node.js SDK to make requests to FireFly’s API. ",
    "url": "/firefly/gettingstarted/sandbox.html#what-is-the-firefly-sandbox",
    "relUrl": "/gettingstarted/sandbox.html#what-is-the-firefly-sandbox"
  },"403": {
    "doc": "③ Use the Sandbox",
    "title": "What is the FireFly Explorer?",
    "content": "The FireFly explorer is a part of FireFly Core itself. It is a view into the system that allows operators to monitor the current state of the system and investigate specific transactions, messages, and events. It is also a great way for developers to see the results of running their code against FireFly’s API. ",
    "url": "/firefly/gettingstarted/sandbox.html#what-is-the-firefly-explorer",
    "relUrl": "/gettingstarted/sandbox.html#what-is-the-firefly-explorer"
  },"404": {
    "doc": "③ Use the Sandbox",
    "title": "Open the FireFly Sandbox for the first member",
    "content": "When you set up your FireFly stack in the previous section, it should have printed some URLs like the following. Open the link in a browser for the `Sandbox UI for member ‘0’. It should be: http://127.0.0.1:5109 . ff start demo this will take a few seconds longer since this is the first time you're running this stack... done Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 Web UI for member '1': http://127.0.0.1:5001/ui Sandbox UI for member '1': http://127.0.0.1:5209 Web UI for member '2': http://127.0.0.1:5002/ui Sandbox UI for member '2': http://127.0.0.1:5309 To see logs for your stack run: ff logs demo . ",
    "url": "/firefly/gettingstarted/sandbox.html#open-the-firefly-sandbox-for-the-first-member",
    "relUrl": "/gettingstarted/sandbox.html#open-the-firefly-sandbox-for-the-first-member"
  },"405": {
    "doc": "③ Use the Sandbox",
    "title": "Sandbox Layout",
    "content": ". The Sandbox is split up into three columns: . Left column: Prepare your request . On the left-hand side of the page, you can fill out simple form fields to construct messages and more. Some tabs have more types of requests on them in sections that can be expanded or collapsed. Across the top of this column there are three tabs that switch between the three main sets of functionality in the Sandbox. The next three sections of this guide will walk you through each one of these. The first tab we will explore is the MESSAGING tab. This is where we can send broadcasts and private messages. Middle column: Preview server code and see response . As you type in the form on the left side of the page, you may notice that the source code in the top middle of the page updates automatically. If you were building a backend app, this is an example of code that your app could use to call the FireFly SDK. The middle column also contains a RUN button to actually send the request. Right column: Events received on the WebSocket . On the right-hand side of the page you can see a stream of events being received on a WebSocket connection that the backend has open to FireFly. For example, as you make requests to send messages, you can see when the messages are asynchronously confirmed. ",
    "url": "/firefly/gettingstarted/sandbox.html#sandbox-layout",
    "relUrl": "/gettingstarted/sandbox.html#sandbox-layout"
  },"406": {
    "doc": "③ Use the Sandbox",
    "title": "Messages",
    "content": "The Messages tab is where we can send broadcast and private messages to other members and nodes in the FireFly network. Messages can be a string, any arbitrary JSON object, or a binary file. For more details, please see the tutorial on Broadcasting data and Privately sending data. Things to try out . | Send a broadcast message and view the data payload in every member’s FireFly Explorer | Send a private message to one member, and verify that the data payload is not visible in the third member’s FireFly Explorer | Send an image file and download it from another member’s FireFly Explorer | . ",
    "url": "/firefly/gettingstarted/sandbox.html#messages",
    "relUrl": "/gettingstarted/sandbox.html#messages"
  },"407": {
    "doc": "③ Use the Sandbox",
    "title": "Tokens",
    "content": "The Tokens tab is where you can create token pools, and mint, burn, or transfer tokens. This works with both fungible and non-fungible tokens (NFTs). For more details, please see the Tokens tutorials. Things to try out . | Create a fungible token pool and mint some tokens and view your balance in the FireFly Explorer | Transfer some amount of those tokens to another member and view the transfer transaction in the FireFly Explorer | Burn some amount of tokens and view the transaction and updated balances in the FireFly Explorer | Create a non-fungible token pool and mint some NFTs | Transfer an NFT to another member and verify the account balances in the FireFly Explorer | . ",
    "url": "/firefly/gettingstarted/sandbox.html#tokens",
    "relUrl": "/gettingstarted/sandbox.html#tokens"
  },"408": {
    "doc": "③ Use the Sandbox",
    "title": "Contracts",
    "content": "The Contracts section of the Sandbox lets you interact with custom smart contracts, right from your web browser! The Sandbox also provides some helpful tips on deploying your smart contract to the blockchain. For more details, please see the tutorial on Working with custom smart contracts. Things to try out . | Create a contract interface and API, then view the Swagger UI for your new API | Create an event listener | Use the Swagger UI to call a smart contract function that emits an event. Verify that the event is received in the Sandbox and shows up in the FireFly Explorer. | . ",
    "url": "/firefly/gettingstarted/sandbox.html#contracts",
    "relUrl": "/gettingstarted/sandbox.html#contracts"
  },"409": {
    "doc": "③ Use the Sandbox",
    "title": "Go forth and build!",
    "content": "At this point you should have a pretty good understanding of some of the major features of Hyperledger FireFly. Now, using what you’ve learned, you can go and build your own Web3 app! Don’t forget to join the Hyperledger Discord server and come chat with us in the #firefly channel. ",
    "url": "/firefly/gettingstarted/sandbox.html#go-forth-and-build",
    "relUrl": "/gettingstarted/sandbox.html#go-forth-and-build"
  },"410": {
    "doc": "③ Use the Sandbox",
    "title": "③ Use the Sandbox",
    "content": " ",
    "url": "/firefly/gettingstarted/sandbox.html",
    "relUrl": "/gettingstarted/sandbox.html"
  },"411": {
    "doc": "② Start your environment",
    "title": "Start your environment",
    "content": " ",
    "url": "/firefly/gettingstarted/setup_env.html#start-your-environment",
    "relUrl": "/gettingstarted/setup_env.html#start-your-environment"
  },"412": {
    "doc": "② Start your environment",
    "title": "Table of contents",
    "content": ". | Previous steps: Install the FireFly CLI | A FireFly Stack | System Resources | Creating a new stack . | Stack initialization options | Start your stack | . | Next steps: Use in the Sandbox | . ",
    "url": "/firefly/gettingstarted/setup_env.html#table-of-contents",
    "relUrl": "/gettingstarted/setup_env.html#table-of-contents"
  },"413": {
    "doc": "② Start your environment",
    "title": "Previous steps: Install the FireFly CLI",
    "content": "If you haven’t set up the FireFly CLI already, please go back to the previous step and read the guide on how to Install the FireFly CLI. ← ① Install the FireFly CLI . Now that you have the FireFly CLI installed, you are ready to run some Supernodes on your machine! . ",
    "url": "/firefly/gettingstarted/setup_env.html#previous-steps-install-the-firefly-cli",
    "relUrl": "/gettingstarted/setup_env.html#previous-steps-install-the-firefly-cli"
  },"414": {
    "doc": "② Start your environment",
    "title": "A FireFly Stack",
    "content": "A FireFly stack is a collection of Supernodes with networking and configuration that are designed to work together on a single development machine. A stack has multiple members (also referred to organizations). Each member has their own Supernode within the stack. This allows developers to build and test data flows with a mix of public and private data between various parties, all within a single development environment. The stack also contains an instance of the FireFly Sandbox for each member. This is an example of an end-user application that uses FireFly’s API. It has a backend and a frontend which are designed to walk developers through the features of FireFly, and provides code snippets as examples of how to build those features into their own application. The next section in this guide will walk you through using the Sandbox. ",
    "url": "/firefly/gettingstarted/setup_env.html#a-firefly-stack",
    "relUrl": "/gettingstarted/setup_env.html#a-firefly-stack"
  },"415": {
    "doc": "② Start your environment",
    "title": "System Resources",
    "content": "The FireFly stack will run in a docker-compose project. For systems that run Docker containers inside a virtual machine, like macOS, you need to make sure that you’ve allocated enough memory to the Docker virtual machine. We recommend allocating 1GB per member. In this case, we’re going to set up a stack with 3 members, so please make sure you have at least 3 GB of RAM allocated in your Docker Desktop settings. ",
    "url": "/firefly/gettingstarted/setup_env.html#system-resources",
    "relUrl": "/gettingstarted/setup_env.html#system-resources"
  },"416": {
    "doc": "② Start your environment",
    "title": "Creating a new stack",
    "content": "It’s really easy to create a new FireFly stack. The ff init command can create a new stack for you, and will prompt you for a few details such as the name, and how many members you want in your stack. Run: . ff init . Choose a stack name. For this guide, I will choose the name dev, but you can pick whatever you want: . stack name: dev . Chose the number of members for your stack. For this guide, we should pick 3 members, so we can try out both public and private messaging use cases: . number of members: 3 . Stack initialization options . There are quite a few options that you can choose from when creating a new stack. For now, we’ll just stick with the defaults. To see the full list of options, just run ff init --help. $ ff init --help Create a new FireFly local dev stack Usage: ff init [stack_name] [member_count] [flags] Flags: --block-period int Block period in seconds. Default is variable based on selected blockchain provider. (default -1) -b, --blockchain-provider string Blockchain provider to use. Options are: [geth besu fabric corda] (default \"geth\") --contract-address string Do not automatically deploy a contract, instead use a pre-configured address --core-config string The path to a yaml file containing extra config for FireFly Core -d, --database string Database type to use. Options are: [postgres sqlite3] (default \"sqlite3\") --ethconnect-config string The path to a yaml file containing extra config for Ethconnect -e, --external int Manage a number of FireFly core processes outside of the docker-compose stack - useful for development and debugging -p, --firefly-base-port int Mapped port base of FireFly core API (1 added for each member) (default 5000) -h, --help help for init -m, --manifest string Path to a manifest.json file containing the versions of each FireFly microservice to use. Overrides the --release flag. --prometheus-enabled Enables Prometheus metrics exposition and aggregation to a shared Prometheus server --prometheus-port int Port for the shared Prometheus server (default 9090) --prompt-names Prompt for org and node names instead of using the defaults -r, --release string Select the FireFly release version to use (default \"latest\") --sandbox-enabled Enables the FireFly Sandbox to be started with your FireFly stack (default true) -s, --services-base-port int Mapped port base of services (100 added for each member) (default 5100) -t, --token-providers stringArray Token providers to use. Options are: [none erc1155 erc20_erc721] (default [erc1155]) Global Flags: --ansi string control when to print ANSI control characters (\"never\"|\"always\"|\"auto\") (default \"auto\") -v, --verbose verbose log output . Start your stack . To start your stack simply run: . ff start dev . This may take a minute or two and in the background the FireFly CLI will do the following for you: . | Download Docker images for all of the components of the Supernode | Initialize a new blockchain and blockchain node running inside a container | Set up configuration between all the components | Deploy FireFly’s BatchPin smart contract | Deploy an ERC-1155 token smart contract | Register an identity for each member and node | . After your stack finishes starting it will print out the links to each member’s UI and the Sandbox for that node: . ff start dev this will take a few seconds longer since this is the first time you're running this stack... done Web UI for member '0': http://127.0.0.1:5000/ui Sandbox UI for member '0': http://127.0.0.1:5109 Web UI for member '1': http://127.0.0.1:5001/ui Sandbox UI for member '1': http://127.0.0.1:5209 Web UI for member '2': http://127.0.0.1:5002/ui Sandbox UI for member '2': http://127.0.0.1:5309 To see logs for your stack run: ff logs dev . ",
    "url": "/firefly/gettingstarted/setup_env.html#creating-a-new-stack",
    "relUrl": "/gettingstarted/setup_env.html#creating-a-new-stack"
  },"417": {
    "doc": "② Start your environment",
    "title": "Next steps: Use in the Sandbox",
    "content": "Now that you have some Supernodes running, it’s time to start playing: in the Sandbox! . ③ Use the Sandbox → . ",
    "url": "/firefly/gettingstarted/setup_env.html#next-steps-use-in-the-sandbox",
    "relUrl": "/gettingstarted/setup_env.html#next-steps-use-in-the-sandbox"
  },"418": {
    "doc": "② Start your environment",
    "title": "② Start your environment",
    "content": " ",
    "url": "/firefly/gettingstarted/setup_env.html",
    "relUrl": "/gettingstarted/setup_env.html"
  },"419": {
    "doc": "Simple Types",
    "title": "Simple Types",
    "content": " ",
    "url": "/firefly/reference/types/simpletypes.html",
    "relUrl": "/reference/types/simpletypes.html"
  },"420": {
    "doc": "Simple Types",
    "title": "Table of contents",
    "content": ". | FFTime | FFBigInt | . ",
    "url": "/firefly/reference/types/simpletypes.html#table-of-contents",
    "relUrl": "/reference/types/simpletypes.html#table-of-contents"
  },"421": {
    "doc": "Simple Types",
    "title": "FFTime",
    "content": "FFTime is serialized to JSON on the API in RFC3339 nanosecond UTC time (noting that JavaScript can parse this format happily into millisecond time with Date.pase()). It is persisted as a nanosecond resolution timestamp in the database. It can be parsed from RFC3339, or unix timestamps (second, millisecond or nanosecond resolution). ",
    "url": "/firefly/reference/types/simpletypes.html#fftime",
    "relUrl": "/reference/types/simpletypes.html#fftime"
  },"422": {
    "doc": "Simple Types",
    "title": "FFBigInt",
    "content": "FFBigInt is a wrapper on a Go big.Int that standardizes JSON and DB serialization . ",
    "url": "/firefly/reference/types/simpletypes.html#ffbigint",
    "relUrl": "/reference/types/simpletypes.html#ffbigint"
  },"423": {
    "doc": "pages.api_spec",
    "title": "API Spec",
    "content": "This is the FireFly OpenAPI Specification document generated by FireFly . Note: The ‘Try it out’ buttons will not work on this page, because it’s not running against a live version of FireFly. To actually try it out, we recommend using the FireFly CLI to start an instance on your local machine, then have a look at the API spec there. | ",
    "url": "/firefly/swagger/swagger.html#api-spec",
    "relUrl": "/swagger/swagger.html#api-spec"
  },"424": {
    "doc": "pages.api_spec",
    "title": "pages.api_spec",
    "content": " ",
    "url": "/firefly/swagger/swagger.html",
    "relUrl": "/swagger/swagger.html"
  },"425": {
    "doc": "TokenTransfer",
    "title": "TokenTransfer",
    "content": " ",
    "url": "/firefly/reference/types/tokentransfer.html",
    "relUrl": "/reference/types/tokentransfer.html"
  },"426": {
    "doc": "TokenTransfer",
    "title": "Table of contents",
    "content": ". | TokenTransfer . | Example | Field Descriptions | . | TransactionRef | . ",
    "url": "/firefly/reference/types/tokentransfer.html#table-of-contents",
    "relUrl": "/reference/types/tokentransfer.html#table-of-contents"
  },"427": {
    "doc": "TokenTransfer",
    "title": "TokenTransfer",
    "content": "Example . { \"type\": \"transfer\", \"pool\": \"1244ecbe-5862-41c3-99ec-4666a18b9dd5\", \"from\": \"0x98151D8AB3af082A5DC07746C220Fb6C95Bc4a50\", \"to\": \"0x7b746b92869De61649d148823808653430682C0d\", \"amount\": \"0\", \"message\": \"855af8e7-2b02-4e05-ad7d-9ae0d4c409ba\", \"tx\": { \"type\": \"\" } } . Field Descriptions . | Field Name | Description | Type | . | type | The type of transfer such as mint/burn/transfer | FFEnum | . | localId | The UUID of this token transfer, in the local FireFly node | UUID | . | pool | The UUID the token pool this transfer applies to | UUID | . | tokenIndex | The index of the token within the pool that this transfer applies to | string | . | uri | The URI of the token this transfer applies to | string | . | connector | The name of the token connector, as specified in the FireFly core configuration file. Required on input when there are more than one token connectors configured | string | . | namespace | The namespace for the transfer, which must match the namespace of the token pool | string | . | key | The blockchain signing key for the transfer. On input defaults to the first signing key of the organization that operates the node | string | . | from | The source account for the transfer. On input defaults to the value of ‘key’ | string | . | to | The target account for the transfer. On input defaults to the value of ‘key’ | string | . | amount | The amount for the transfer. For non-fungible tokens will always be 1. For fungible tokens, the number of decimals for the token pool should be considered when inputting the amount. For example, with 18 decimals a fractional balance of 10.234 will be specified as 10,234,000,000,000,000,000 | FFBigInt | . | protocolId | An alphanumerically sortable string that represents this event uniquely with respect to the blockchain | string | . | message | The UUID of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector | UUID | . | messageHash | The hash of a message that has been correlated with this transfer using the data field of the transfer in a compatible token connector | Bytes32 | . | created | The creation time of the transfer | FFTime | . | tx | If submitted via FireFly, this will reference the UUID of the FireFly transaction (if the token connector in use supports attaching data) | TransactionRef | . | blockchainEvent | The UUID of the blockchain event | UUID | . ",
    "url": "/firefly/reference/types/tokentransfer.html",
    "relUrl": "/reference/types/tokentransfer.html"
  },"428": {
    "doc": "TokenTransfer",
    "title": "TransactionRef",
    "content": "| Field Name | Description | Type | . | type | The type of the FireFly transaction | FFEnum | . | id | The UUID of the FireFly transaction | UUID | . ",
    "url": "/firefly/reference/types/tokentransfer.html#transactionref",
    "relUrl": "/reference/types/tokentransfer.html#transactionref"
  },"429": {
    "doc": "Versioning Scheme",
    "title": "Versioning Scheme",
    "content": " ",
    "url": "/firefly/contributors/version_scheme.html",
    "relUrl": "/contributors/version_scheme.html"
  },"430": {
    "doc": "Versioning Scheme",
    "title": "Table of contents",
    "content": ". | Versioning Scheme . | Semantic versioning | Pre-release test versions | Candidate releases | . | . This page describes FireFly’s versioning scheme . ",
    "url": "/firefly/contributors/version_scheme.html#table-of-contents",
    "relUrl": "/contributors/version_scheme.html#table-of-contents"
  },"431": {
    "doc": "Versioning Scheme",
    "title": "Semantic versioning",
    "content": "FireFly follows semantic versioning. In summary, this means: . Given a version number MAJOR.MINOR.PATCH, increment the: . | MAJOR version when you make incompatible API changes, | MINOR version when you add functionality in a backwards compatible manner, and | PATCH version when you make backwards compatible bug fixes. | Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format. | . When creating a new release, the release name and tag should be the semantic version should be prefixed with a v . For example, a certain release name/tag could be v0.9.0. ",
    "url": "/firefly/contributors/version_scheme.html#semantic-versioning",
    "relUrl": "/contributors/version_scheme.html#semantic-versioning"
  },"432": {
    "doc": "Versioning Scheme",
    "title": "Pre-release test versions",
    "content": "For pre-release versions for testing, we append a date and index to the end of the most recently released version. For example, if we needed to create a pre-release based on v0.9.0 and today’s date is October 22, 2021, the version name/tag would be: v0.9.0-20211022-01. If for some reason you needed to create another pre-release version in the same day (hey, stuff happens), the name/tag for that one would be v0.9.0-20211022-02. ",
    "url": "/firefly/contributors/version_scheme.html#pre-release-test-versions",
    "relUrl": "/contributors/version_scheme.html#pre-release-test-versions"
  },"433": {
    "doc": "Versioning Scheme",
    "title": "Candidate releases",
    "content": "For pre-releases that are candidates to become a new major or minor release, the release name/tag will be based on the release that the candidate will become (as opposed to the test releases above, which are based on the previous release). For example, if the current latest release is v0.9.0 but we want to create an alpha release for 1.0, the release name/tag would be v1.0.0-alpha-01. ",
    "url": "/firefly/contributors/version_scheme.html#candidate-releases",
    "relUrl": "/contributors/version_scheme.html#candidate-releases"
  }
}

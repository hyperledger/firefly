// Code generated by mockery v1.0.0. DO NOT EDIT.

package databasemocks

import (
	context "context"

	config "github.com/hyperledger/firefly/internal/config"

	database "github.com/hyperledger/firefly/pkg/database"

	fftypes "github.com/hyperledger/firefly/pkg/fftypes"

	mock "github.com/stretchr/testify/mock"
)

// Plugin is an autogenerated mock type for the Plugin type
type Plugin struct {
	mock.Mock
}

// Capabilities provides a mock function with given fields:
func (_m *Plugin) Capabilities() *database.Capabilities {
	ret := _m.Called()

	var r0 *database.Capabilities
	if rf, ok := ret.Get(0).(func() *database.Capabilities); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Capabilities)
		}
	}

	return r0
}

// DeleteBlob provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeleteBlob(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteConfigRecord provides a mock function with given fields: ctx, key
func (_m *Plugin) DeleteConfigRecord(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteContractListenerByID provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteContractListenerByID(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNamespace provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteNamespace(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNextPin provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeleteNextPin(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) DeleteNonce(ctx context.Context, hash *fftypes.Bytes32) error {
	ret := _m.Called(ctx, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) error); ok {
		r0 = rf(ctx, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) DeleteOffset(ctx context.Context, t fftypes.FFEnum, name string) error {
	ret := _m.Called(ctx, t, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string) error); ok {
		r0 = rf(ctx, t, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePin provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeletePin(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSubscriptionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteSubscriptionByID(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBatchByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetBatchByID(ctx context.Context, id *fftypes.UUID) (*fftypes.BatchPersisted, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.BatchPersisted
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.BatchPersisted); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.BatchPersisted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatches provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBatches(ctx context.Context, filter database.Filter) ([]*fftypes.BatchPersisted, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.BatchPersisted
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.BatchPersisted); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.BatchPersisted)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlobMatchingHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetBlobMatchingHash(ctx context.Context, hash *fftypes.Bytes32) (*fftypes.Blob, error) {
	ret := _m.Called(ctx, hash)

	var r0 *fftypes.Blob
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *fftypes.Blob); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Blob)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlobs provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBlobs(ctx context.Context, filter database.Filter) ([]*fftypes.Blob, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Blob
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Blob); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Blob)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlockchainEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetBlockchainEventByID(ctx context.Context, id *fftypes.UUID) (*fftypes.BlockchainEvent, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.BlockchainEvent
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.BlockchainEvent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.BlockchainEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBlockchainEvents(ctx context.Context, filter database.Filter) ([]*fftypes.BlockchainEvent, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.BlockchainEvent
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.BlockchainEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.BlockchainEvent)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetChartHistogram provides a mock function with given fields: ctx, ns, intervals, collection
func (_m *Plugin) GetChartHistogram(ctx context.Context, ns string, intervals []fftypes.ChartHistogramInterval, collection database.CollectionName) ([]*fftypes.ChartHistogram, error) {
	ret := _m.Called(ctx, ns, intervals, collection)

	var r0 []*fftypes.ChartHistogram
	if rf, ok := ret.Get(0).(func(context.Context, string, []fftypes.ChartHistogramInterval, database.CollectionName) []*fftypes.ChartHistogram); ok {
		r0 = rf(ctx, ns, intervals, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.ChartHistogram)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []fftypes.ChartHistogramInterval, database.CollectionName) error); ok {
		r1 = rf(ctx, ns, intervals, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigRecord provides a mock function with given fields: ctx, key
func (_m *Plugin) GetConfigRecord(ctx context.Context, key string) (*fftypes.ConfigRecord, error) {
	ret := _m.Called(ctx, key)

	var r0 *fftypes.ConfigRecord
	if rf, ok := ret.Get(0).(func(context.Context, string) *fftypes.ConfigRecord); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ConfigRecord)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigRecords provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetConfigRecords(ctx context.Context, filter database.Filter) ([]*fftypes.ConfigRecord, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.ConfigRecord
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.ConfigRecord); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.ConfigRecord)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetContractAPIByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractAPIByID(ctx context.Context, id *fftypes.UUID) (*fftypes.ContractAPI, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.ContractAPI); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ContractAPI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIByName provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetContractAPIByName(ctx context.Context, ns string, name string) (*fftypes.ContractAPI, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *fftypes.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.ContractAPI); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ContractAPI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIs provides a mock function with given fields: ctx, ns, filter
func (_m *Plugin) GetContractAPIs(ctx context.Context, ns string, filter database.AndFilter) ([]*fftypes.ContractAPI, *database.FilterResult, error) {
	ret := _m.Called(ctx, ns, filter)

	var r0 []*fftypes.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, string, database.AndFilter) []*fftypes.ContractAPI); ok {
		r0 = rf(ctx, ns, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.ContractAPI)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.AndFilter) *database.FilterResult); ok {
		r1 = rf(ctx, ns, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.AndFilter) error); ok {
		r2 = rf(ctx, ns, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetContractListener provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetContractListener(ctx context.Context, ns string, name string) (*fftypes.ContractListener, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *fftypes.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.ContractListener); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractListenerByID(ctx context.Context, id *fftypes.UUID) (*fftypes.ContractListener, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.ContractListener); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByProtocolID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractListenerByProtocolID(ctx context.Context, id string) (*fftypes.ContractListener, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, string) *fftypes.ContractListener); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListeners provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetContractListeners(ctx context.Context, filter database.Filter) ([]*fftypes.ContractListener, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.ContractListener); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.ContractListener)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetData provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetData(ctx context.Context, filter database.Filter) (fftypes.DataArray, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 fftypes.DataArray
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) fftypes.DataArray); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fftypes.DataArray)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDataByID provides a mock function with given fields: ctx, id, withValue
func (_m *Plugin) GetDataByID(ctx context.Context, id *fftypes.UUID, withValue bool) (*fftypes.Data, error) {
	ret := _m.Called(ctx, id, withValue)

	var r0 *fftypes.Data
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, bool) *fftypes.Data); ok {
		r0 = rf(ctx, id, withValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Data)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, bool) error); ok {
		r1 = rf(ctx, id, withValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRefs provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetDataRefs(ctx context.Context, filter database.Filter) (fftypes.DataRefs, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 fftypes.DataRefs
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) fftypes.DataRefs); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fftypes.DataRefs)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDatatypeByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetDatatypeByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Datatype, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Datatype); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Datatype)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypeByName provides a mock function with given fields: ctx, ns, name, version
func (_m *Plugin) GetDatatypeByName(ctx context.Context, ns string, name string, version string) (*fftypes.Datatype, error) {
	ret := _m.Called(ctx, ns, name, version)

	var r0 *fftypes.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *fftypes.Datatype); ok {
		r0 = rf(ctx, ns, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Datatype)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, ns, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypes provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetDatatypes(ctx context.Context, filter database.Filter) ([]*fftypes.Datatype, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Datatype); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Datatype)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetEventByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Event, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Event
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Event); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Event)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetEvents(ctx context.Context, filter database.Filter) ([]*fftypes.Event, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Event
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Event); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Event)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFI provides a mock function with given fields: ctx, ns, name, version
func (_m *Plugin) GetFFI(ctx context.Context, ns string, name string, version string) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, ns, name, version)

	var r0 *fftypes.FFI
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *fftypes.FFI); ok {
		r0 = rf(ctx, ns, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, ns, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetFFIByID(ctx context.Context, id *fftypes.UUID) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.FFI
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.FFI); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEvent provides a mock function with given fields: ctx, ns, interfaceID, pathName
func (_m *Plugin) GetFFIEvent(ctx context.Context, ns string, interfaceID *fftypes.UUID, pathName string) (*fftypes.FFIEvent, error) {
	ret := _m.Called(ctx, ns, interfaceID, pathName)

	var r0 *fftypes.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *fftypes.FFIEvent); ok {
		r0 = rf(ctx, ns, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFIEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, ns, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetFFIEventByID(ctx context.Context, id *fftypes.UUID) (*fftypes.FFIEvent, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.FFIEvent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFIEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetFFIEvents(ctx context.Context, filter database.Filter) ([]*fftypes.FFIEvent, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.FFIEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFIEvent)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIMethod provides a mock function with given fields: ctx, ns, interfaceID, pathName
func (_m *Plugin) GetFFIMethod(ctx context.Context, ns string, interfaceID *fftypes.UUID, pathName string) (*fftypes.FFIMethod, error) {
	ret := _m.Called(ctx, ns, interfaceID, pathName)

	var r0 *fftypes.FFIMethod
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *fftypes.FFIMethod); ok {
		r0 = rf(ctx, ns, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFIMethod)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, ns, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIMethods provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetFFIMethods(ctx context.Context, filter database.Filter) ([]*fftypes.FFIMethod, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.FFIMethod
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.FFIMethod); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFIMethod)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIs provides a mock function with given fields: ctx, ns, filter
func (_m *Plugin) GetFFIs(ctx context.Context, ns string, filter database.Filter) ([]*fftypes.FFI, *database.FilterResult, error) {
	ret := _m.Called(ctx, ns, filter)

	var r0 []*fftypes.FFI
	if rf, ok := ret.Get(0).(func(context.Context, string, database.Filter) []*fftypes.FFI); ok {
		r0 = rf(ctx, ns, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFI)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, ns, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.Filter) error); ok {
		r2 = rf(ctx, ns, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetGroupByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetGroupByHash(ctx context.Context, hash *fftypes.Bytes32) (*fftypes.Group, error) {
	ret := _m.Called(ctx, hash)

	var r0 *fftypes.Group
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *fftypes.Group); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetGroups(ctx context.Context, filter database.Filter) ([]*fftypes.Group, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Group
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Group); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Group)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentities provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetIdentities(ctx context.Context, filter database.Filter) ([]*fftypes.Identity, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Identity
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Identity); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Identity)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentityByDID provides a mock function with given fields: ctx, did
func (_m *Plugin) GetIdentityByDID(ctx context.Context, did string) (*fftypes.Identity, error) {
	ret := _m.Called(ctx, did)

	var r0 *fftypes.Identity
	if rf, ok := ret.Get(0).(func(context.Context, string) *fftypes.Identity); ok {
		r0 = rf(ctx, did)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, did)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetIdentityByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Identity, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Identity
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Identity); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByName provides a mock function with given fields: ctx, iType, namespace, name
func (_m *Plugin) GetIdentityByName(ctx context.Context, iType fftypes.FFEnum, namespace string, name string) (*fftypes.Identity, error) {
	ret := _m.Called(ctx, iType, namespace, name)

	var r0 *fftypes.Identity
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) *fftypes.Identity); ok {
		r0 = rf(ctx, iType, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string, string) error); ok {
		r1 = rf(ctx, iType, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetMessageByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Message, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Message
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Message); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Message)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessages provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetMessages(ctx context.Context, filter database.Filter) ([]*fftypes.Message, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Message
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Message); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Message)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMessagesForData provides a mock function with given fields: ctx, dataID, filter
func (_m *Plugin) GetMessagesForData(ctx context.Context, dataID *fftypes.UUID, filter database.Filter) ([]*fftypes.Message, *database.FilterResult, error) {
	ret := _m.Called(ctx, dataID, filter)

	var r0 []*fftypes.Message
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Filter) []*fftypes.Message); ok {
		r0 = rf(ctx, dataID, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Message)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, dataID, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *fftypes.UUID, database.Filter) error); ok {
		r2 = rf(ctx, dataID, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNamespace provides a mock function with given fields: ctx, name
func (_m *Plugin) GetNamespace(ctx context.Context, name string) (*fftypes.Namespace, error) {
	ret := _m.Called(ctx, name)

	var r0 *fftypes.Namespace
	if rf, ok := ret.Get(0).(func(context.Context, string) *fftypes.Namespace); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Namespace)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamespaces provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNamespaces(ctx context.Context, filter database.Filter) ([]*fftypes.Namespace, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Namespace
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Namespace); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Namespace)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNextPinByContextAndIdentity provides a mock function with given fields: ctx, _a1, identity
func (_m *Plugin) GetNextPinByContextAndIdentity(ctx context.Context, _a1 *fftypes.Bytes32, identity string) (*fftypes.NextPin, error) {
	ret := _m.Called(ctx, _a1, identity)

	var r0 *fftypes.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, string) *fftypes.NextPin); ok {
		r0 = rf(ctx, _a1, identity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.NextPin)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32, string) error); ok {
		r1 = rf(ctx, _a1, identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextPinByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetNextPinByHash(ctx context.Context, hash *fftypes.Bytes32) (*fftypes.NextPin, error) {
	ret := _m.Called(ctx, hash)

	var r0 *fftypes.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *fftypes.NextPin); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.NextPin)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextPins provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNextPins(ctx context.Context, filter database.Filter) ([]*fftypes.NextPin, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.NextPin); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.NextPin)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetNonce(ctx context.Context, hash *fftypes.Bytes32) (*fftypes.Nonce, error) {
	ret := _m.Called(ctx, hash)

	var r0 *fftypes.Nonce
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *fftypes.Nonce); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Nonce)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonces provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNonces(ctx context.Context, filter database.Filter) ([]*fftypes.Nonce, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Nonce
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Nonce); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Nonce)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) GetOffset(ctx context.Context, t fftypes.FFEnum, name string) (*fftypes.Offset, error) {
	ret := _m.Called(ctx, t, name)

	var r0 *fftypes.Offset
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string) *fftypes.Offset); ok {
		r0 = rf(ctx, t, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Offset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string) error); ok {
		r1 = rf(ctx, t, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOffsets provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetOffsets(ctx context.Context, filter database.Filter) ([]*fftypes.Offset, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Offset
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Offset); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Offset)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOperationByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetOperationByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Operation, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Operation
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Operation); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Operation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOperations provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetOperations(ctx context.Context, filter database.Filter) ([]*fftypes.Operation, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Operation
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Operation); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Operation)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetPins provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetPins(ctx context.Context, filter database.Filter) ([]*fftypes.Pin, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Pin
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Pin); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Pin)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetSubscriptionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetSubscriptionByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Subscription, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Subscription); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptionByName provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetSubscriptionByName(ctx context.Context, ns string, name string) (*fftypes.Subscription, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *fftypes.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.Subscription); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptions provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetSubscriptions(ctx context.Context, filter database.Filter) ([]*fftypes.Subscription, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Subscription); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Subscription)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccountPools provides a mock function with given fields: ctx, key, filter
func (_m *Plugin) GetTokenAccountPools(ctx context.Context, key string, filter database.Filter) ([]*fftypes.TokenAccountPool, *database.FilterResult, error) {
	ret := _m.Called(ctx, key, filter)

	var r0 []*fftypes.TokenAccountPool
	if rf, ok := ret.Get(0).(func(context.Context, string, database.Filter) []*fftypes.TokenAccountPool); ok {
		r0 = rf(ctx, key, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenAccountPool)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, key, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.Filter) error); ok {
		r2 = rf(ctx, key, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccounts provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenAccounts(ctx context.Context, filter database.Filter) ([]*fftypes.TokenAccount, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.TokenAccount
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.TokenAccount); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenAccount)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenApproval provides a mock function with given fields: ctx, localID
func (_m *Plugin) GetTokenApproval(ctx context.Context, localID *fftypes.UUID) (*fftypes.TokenApproval, error) {
	ret := _m.Called(ctx, localID)

	var r0 *fftypes.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.TokenApproval); ok {
		r0 = rf(ctx, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenApproval)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovalByProtocolID provides a mock function with given fields: ctx, connector, protocolID
func (_m *Plugin) GetTokenApprovalByProtocolID(ctx context.Context, connector string, protocolID string) (*fftypes.TokenApproval, error) {
	ret := _m.Called(ctx, connector, protocolID)

	var r0 *fftypes.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.TokenApproval); ok {
		r0 = rf(ctx, connector, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenApproval)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovals provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenApprovals(ctx context.Context, filter database.Filter) ([]*fftypes.TokenApproval, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.TokenApproval); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenApproval)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenBalance provides a mock function with given fields: ctx, poolID, tokenIndex, identity
func (_m *Plugin) GetTokenBalance(ctx context.Context, poolID *fftypes.UUID, tokenIndex string, identity string) (*fftypes.TokenBalance, error) {
	ret := _m.Called(ctx, poolID, tokenIndex, identity)

	var r0 *fftypes.TokenBalance
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, string, string) *fftypes.TokenBalance); ok {
		r0 = rf(ctx, poolID, tokenIndex, identity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, string, string) error); ok {
		r1 = rf(ctx, poolID, tokenIndex, identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenBalances provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenBalances(ctx context.Context, filter database.Filter) ([]*fftypes.TokenBalance, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.TokenBalance
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.TokenBalance); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenBalance)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenPool provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetTokenPool(ctx context.Context, ns string, name string) (*fftypes.TokenPool, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *fftypes.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.TokenPool); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetTokenPoolByID(ctx context.Context, id *fftypes.UUID) (*fftypes.TokenPool, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.TokenPool); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByProtocolID provides a mock function with given fields: ctx, connector, protocolID
func (_m *Plugin) GetTokenPoolByProtocolID(ctx context.Context, connector string, protocolID string) (*fftypes.TokenPool, error) {
	ret := _m.Called(ctx, connector, protocolID)

	var r0 *fftypes.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.TokenPool); ok {
		r0 = rf(ctx, connector, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPools provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenPools(ctx context.Context, filter database.Filter) ([]*fftypes.TokenPool, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.TokenPool); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenPool)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenTransfer provides a mock function with given fields: ctx, localID
func (_m *Plugin) GetTokenTransfer(ctx context.Context, localID *fftypes.UUID) (*fftypes.TokenTransfer, error) {
	ret := _m.Called(ctx, localID)

	var r0 *fftypes.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.TokenTransfer); ok {
		r0 = rf(ctx, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenTransfer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransferByProtocolID provides a mock function with given fields: ctx, connector, protocolID
func (_m *Plugin) GetTokenTransferByProtocolID(ctx context.Context, connector string, protocolID string) (*fftypes.TokenTransfer, error) {
	ret := _m.Called(ctx, connector, protocolID)

	var r0 *fftypes.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *fftypes.TokenTransfer); ok {
		r0 = rf(ctx, connector, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.TokenTransfer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransfers provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenTransfers(ctx context.Context, filter database.Filter) ([]*fftypes.TokenTransfer, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.TokenTransfer); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.TokenTransfer)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTransactionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetTransactionByID(ctx context.Context, id *fftypes.UUID) (*fftypes.Transaction, error) {
	ret := _m.Called(ctx, id)

	var r0 *fftypes.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *fftypes.Transaction); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactions provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTransactions(ctx context.Context, filter database.Filter) ([]*fftypes.Transaction, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Transaction); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Transaction)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetVerifierByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetVerifierByHash(ctx context.Context, hash *fftypes.Bytes32) (*fftypes.Verifier, error) {
	ret := _m.Called(ctx, hash)

	var r0 *fftypes.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *fftypes.Verifier); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Verifier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifierByValue provides a mock function with given fields: ctx, vType, namespace, value
func (_m *Plugin) GetVerifierByValue(ctx context.Context, vType fftypes.FFEnum, namespace string, value string) (*fftypes.Verifier, error) {
	ret := _m.Called(ctx, vType, namespace, value)

	var r0 *fftypes.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) *fftypes.Verifier); ok {
		r0 = rf(ctx, vType, namespace, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.Verifier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string, string) error); ok {
		r1 = rf(ctx, vType, namespace, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiers provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetVerifiers(ctx context.Context, filter database.Filter) ([]*fftypes.Verifier, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.Verifier); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.Verifier)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Init provides a mock function with given fields: ctx, prefix, callbacks
func (_m *Plugin) Init(ctx context.Context, prefix config.Prefix, callbacks database.Callbacks) error {
	ret := _m.Called(ctx, prefix, callbacks)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, config.Prefix, database.Callbacks) error); ok {
		r0 = rf(ctx, prefix, callbacks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InitPrefix provides a mock function with given fields: prefix
func (_m *Plugin) InitPrefix(prefix config.Prefix) {
	_m.Called(prefix)
}

// InsertBlob provides a mock function with given fields: ctx, blob
func (_m *Plugin) InsertBlob(ctx context.Context, blob *fftypes.Blob) error {
	ret := _m.Called(ctx, blob)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Blob) error); ok {
		r0 = rf(ctx, blob)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertBlockchainEvent provides a mock function with given fields: ctx, event
func (_m *Plugin) InsertBlockchainEvent(ctx context.Context, event *fftypes.BlockchainEvent) error {
	ret := _m.Called(ctx, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.BlockchainEvent) error); ok {
		r0 = rf(ctx, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertDataArray provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertDataArray(ctx context.Context, data fftypes.DataArray) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.DataArray) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertEvent provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertEvent(ctx context.Context, data *fftypes.Event) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Event) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertMessages provides a mock function with given fields: ctx, messages
func (_m *Plugin) InsertMessages(ctx context.Context, messages []*fftypes.Message) error {
	ret := _m.Called(ctx, messages)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*fftypes.Message) error); ok {
		r0 = rf(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertNextPin provides a mock function with given fields: ctx, nextpin
func (_m *Plugin) InsertNextPin(ctx context.Context, nextpin *fftypes.NextPin) error {
	ret := _m.Called(ctx, nextpin)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.NextPin) error); ok {
		r0 = rf(ctx, nextpin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOperation provides a mock function with given fields: ctx, operation
func (_m *Plugin) InsertOperation(ctx context.Context, operation *fftypes.Operation) error {
	ret := _m.Called(ctx, operation)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Operation) error); ok {
		r0 = rf(ctx, operation)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertPins provides a mock function with given fields: ctx, pins
func (_m *Plugin) InsertPins(ctx context.Context, pins []*fftypes.Pin) error {
	ret := _m.Called(ctx, pins)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*fftypes.Pin) error); ok {
		r0 = rf(ctx, pins)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertTransaction provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertTransaction(ctx context.Context, data *fftypes.Transaction) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Transaction) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Plugin) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplaceMessage provides a mock function with given fields: ctx, message
func (_m *Plugin) ReplaceMessage(ctx context.Context, message *fftypes.Message) error {
	ret := _m.Called(ctx, message)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Message) error); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveOperation provides a mock function with given fields: ctx, id, status, errorMsg, output
func (_m *Plugin) ResolveOperation(ctx context.Context, id *fftypes.UUID, status fftypes.OpStatus, errorMsg string, output fftypes.JSONObject) error {
	ret := _m.Called(ctx, id, status, errorMsg, output)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, fftypes.OpStatus, string, fftypes.JSONObject) error); ok {
		r0 = rf(ctx, id, status, errorMsg, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunAsGroup provides a mock function with given fields: ctx, fn
func (_m *Plugin) RunAsGroup(ctx context.Context, fn func(context.Context) error) error {
	ret := _m.Called(ctx, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(context.Context) error) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateBatch provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateBatch(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateData provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateData(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateDatatype provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateDatatype(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateEvent provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateEvent(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateGroup provides a mock function with given fields: ctx, hash, update
func (_m *Plugin) UpdateGroup(ctx context.Context, hash *fftypes.Bytes32, update database.Update) error {
	ret := _m.Called(ctx, hash, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, database.Update) error); ok {
		r0 = rf(ctx, hash, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIdentity provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateIdentity(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessage provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateMessage(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessages provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdateMessages(ctx context.Context, filter database.Filter, update database.Update) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter, database.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNextPin provides a mock function with given fields: ctx, sequence, update
func (_m *Plugin) UpdateNextPin(ctx context.Context, sequence int64, update database.Update) error {
	ret := _m.Called(ctx, sequence, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, database.Update) error); ok {
		r0 = rf(ctx, sequence, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOffset provides a mock function with given fields: ctx, rowID, update
func (_m *Plugin) UpdateOffset(ctx context.Context, rowID int64, update database.Update) error {
	ret := _m.Called(ctx, rowID, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, database.Update) error); ok {
		r0 = rf(ctx, rowID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOperation provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateOperation(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePins provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdatePins(ctx context.Context, filter database.Filter, update database.Update) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter, database.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateSubscription provides a mock function with given fields: ctx, ns, name, update
func (_m *Plugin) UpdateSubscription(ctx context.Context, ns string, name string, update database.Update) error {
	ret := _m.Called(ctx, ns, name, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, database.Update) error); ok {
		r0 = rf(ctx, ns, name, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTokenBalances provides a mock function with given fields: ctx, transfer
func (_m *Plugin) UpdateTokenBalances(ctx context.Context, transfer *fftypes.TokenTransfer) error {
	ret := _m.Called(ctx, transfer)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.TokenTransfer) error); ok {
		r0 = rf(ctx, transfer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTransaction provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateTransaction(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateVerifier provides a mock function with given fields: ctx, hash, update
func (_m *Plugin) UpdateVerifier(ctx context.Context, hash *fftypes.Bytes32, update database.Update) error {
	ret := _m.Called(ctx, hash, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, database.Update) error); ok {
		r0 = rf(ctx, hash, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertBatch provides a mock function with given fields: ctx, data
func (_m *Plugin) UpsertBatch(ctx context.Context, data *fftypes.BatchPersisted) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.BatchPersisted) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertConfigRecord provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertConfigRecord(ctx context.Context, data *fftypes.ConfigRecord, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.ConfigRecord, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractAPI provides a mock function with given fields: ctx, cd
func (_m *Plugin) UpsertContractAPI(ctx context.Context, cd *fftypes.ContractAPI) error {
	ret := _m.Called(ctx, cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.ContractAPI) error); ok {
		r0 = rf(ctx, cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractListener provides a mock function with given fields: ctx, sub
func (_m *Plugin) UpsertContractListener(ctx context.Context, sub *fftypes.ContractListener) error {
	ret := _m.Called(ctx, sub)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.ContractListener) error); ok {
		r0 = rf(ctx, sub)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertData provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertData(ctx context.Context, data *fftypes.Data, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Data, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertDatatype provides a mock function with given fields: ctx, datadef, allowExisting
func (_m *Plugin) UpsertDatatype(ctx context.Context, datadef *fftypes.Datatype, allowExisting bool) error {
	ret := _m.Called(ctx, datadef, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Datatype, bool) error); ok {
		r0 = rf(ctx, datadef, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFI provides a mock function with given fields: ctx, cd
func (_m *Plugin) UpsertFFI(ctx context.Context, cd *fftypes.FFI) error {
	ret := _m.Called(ctx, cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFI) error); ok {
		r0 = rf(ctx, cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIEvent provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIEvent(ctx context.Context, method *fftypes.FFIEvent) error {
	ret := _m.Called(ctx, method)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFIEvent) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIMethod provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIMethod(ctx context.Context, method *fftypes.FFIMethod) error {
	ret := _m.Called(ctx, method)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFIMethod) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertGroup provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertGroup(ctx context.Context, data *fftypes.Group, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Group, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertIdentity provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertIdentity(ctx context.Context, data *fftypes.Identity, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Identity, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertMessage provides a mock function with given fields: ctx, message, optimization
func (_m *Plugin) UpsertMessage(ctx context.Context, message *fftypes.Message, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, message, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Message, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, message, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertNamespace provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertNamespace(ctx context.Context, data *fftypes.Namespace, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Namespace, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertNonceNext provides a mock function with given fields: ctx, _a1
func (_m *Plugin) UpsertNonceNext(ctx context.Context, _a1 *fftypes.Nonce) error {
	ret := _m.Called(ctx, _a1)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Nonce) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertOffset provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertOffset(ctx context.Context, data *fftypes.Offset, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Offset, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertPin provides a mock function with given fields: ctx, parked
func (_m *Plugin) UpsertPin(ctx context.Context, parked *fftypes.Pin) error {
	ret := _m.Called(ctx, parked)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Pin) error); ok {
		r0 = rf(ctx, parked)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertSubscription provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertSubscription(ctx context.Context, data *fftypes.Subscription, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Subscription, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenApproval provides a mock function with given fields: ctx, approval
func (_m *Plugin) UpsertTokenApproval(ctx context.Context, approval *fftypes.TokenApproval) error {
	ret := _m.Called(ctx, approval)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.TokenApproval) error); ok {
		r0 = rf(ctx, approval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenPool provides a mock function with given fields: ctx, pool
func (_m *Plugin) UpsertTokenPool(ctx context.Context, pool *fftypes.TokenPool) error {
	ret := _m.Called(ctx, pool)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.TokenPool) error); ok {
		r0 = rf(ctx, pool)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenTransfer provides a mock function with given fields: ctx, transfer
func (_m *Plugin) UpsertTokenTransfer(ctx context.Context, transfer *fftypes.TokenTransfer) error {
	ret := _m.Called(ctx, transfer)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.TokenTransfer) error); ok {
		r0 = rf(ctx, transfer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertVerifier provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertVerifier(ctx context.Context, data *fftypes.Verifier, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Verifier, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

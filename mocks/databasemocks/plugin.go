// Code generated by mockery v1.0.0. DO NOT EDIT.

package databasemocks

import (
	context "context"

	config "github.com/hyperledger/firefly-common/pkg/config"

	core "github.com/hyperledger/firefly/pkg/core"

	database "github.com/hyperledger/firefly/pkg/database"

	fftypes "github.com/hyperledger/firefly-common/pkg/fftypes"

	mock "github.com/stretchr/testify/mock"
)

// Plugin is an autogenerated mock type for the Plugin type
type Plugin struct {
	mock.Mock
}

// Capabilities provides a mock function with given fields:
func (_m *Plugin) Capabilities() *database.Capabilities {
	ret := _m.Called()

	var r0 *database.Capabilities
	if rf, ok := ret.Get(0).(func() *database.Capabilities); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Capabilities)
		}
	}

	return r0
}

// DeleteBlob provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeleteBlob(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteConfigRecord provides a mock function with given fields: ctx, key
func (_m *Plugin) DeleteConfigRecord(ctx context.Context, key string) error {
	ret := _m.Called(ctx, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteContractListenerByID provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteContractListenerByID(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNamespace provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteNamespace(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNextPin provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeleteNextPin(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) DeleteNonce(ctx context.Context, hash *fftypes.Bytes32) error {
	ret := _m.Called(ctx, hash)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) error); ok {
		r0 = rf(ctx, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) DeleteOffset(ctx context.Context, t core.FFEnum, name string) error {
	ret := _m.Called(ctx, t, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, core.FFEnum, string) error); ok {
		r0 = rf(ctx, t, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeletePin provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeletePin(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSubscriptionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) DeleteSubscriptionByID(ctx context.Context, id *fftypes.UUID) error {
	ret := _m.Called(ctx, id)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) error); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBatchByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetBatchByID(ctx context.Context, id *fftypes.UUID) (*core.BatchPersisted, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.BatchPersisted
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.BatchPersisted); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BatchPersisted)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchIDsForDataAttachments provides a mock function with given fields: ctx, dataIDs
func (_m *Plugin) GetBatchIDsForDataAttachments(ctx context.Context, dataIDs []*fftypes.UUID) ([]*fftypes.UUID, error) {
	ret := _m.Called(ctx, dataIDs)

	var r0 []*fftypes.UUID
	if rf, ok := ret.Get(0).(func(context.Context, []*fftypes.UUID) []*fftypes.UUID); ok {
		r0 = rf(ctx, dataIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.UUID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []*fftypes.UUID) error); ok {
		r1 = rf(ctx, dataIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchIDsForMessages provides a mock function with given fields: ctx, msgIDs
func (_m *Plugin) GetBatchIDsForMessages(ctx context.Context, msgIDs []*fftypes.UUID) ([]*fftypes.UUID, error) {
	ret := _m.Called(ctx, msgIDs)

	var r0 []*fftypes.UUID
	if rf, ok := ret.Get(0).(func(context.Context, []*fftypes.UUID) []*fftypes.UUID); ok {
		r0 = rf(ctx, msgIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.UUID)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, []*fftypes.UUID) error); ok {
		r1 = rf(ctx, msgIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatches provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBatches(ctx context.Context, filter database.Filter) ([]*core.BatchPersisted, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.BatchPersisted
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.BatchPersisted); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.BatchPersisted)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlobMatchingHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetBlobMatchingHash(ctx context.Context, hash *fftypes.Bytes32) (*core.Blob, error) {
	ret := _m.Called(ctx, hash)

	var r0 *core.Blob
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.Blob); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Blob)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlobs provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBlobs(ctx context.Context, filter database.Filter) ([]*core.Blob, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Blob
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Blob); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Blob)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlockchainEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetBlockchainEventByID(ctx context.Context, id *fftypes.UUID) (*core.BlockchainEvent, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.BlockchainEvent
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.BlockchainEvent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BlockchainEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainEventByProtocolID provides a mock function with given fields: ctx, ns, listener, protocolID
func (_m *Plugin) GetBlockchainEventByProtocolID(ctx context.Context, ns string, listener *fftypes.UUID, protocolID string) (*core.BlockchainEvent, error) {
	ret := _m.Called(ctx, ns, listener, protocolID)

	var r0 *core.BlockchainEvent
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.BlockchainEvent); ok {
		r0 = rf(ctx, ns, listener, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BlockchainEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, ns, listener, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetBlockchainEvents(ctx context.Context, filter database.Filter) ([]*core.BlockchainEvent, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.BlockchainEvent
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.BlockchainEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.BlockchainEvent)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetChartHistogram provides a mock function with given fields: ctx, ns, intervals, collection
func (_m *Plugin) GetChartHistogram(ctx context.Context, ns string, intervals []core.ChartHistogramInterval, collection database.CollectionName) ([]*core.ChartHistogram, error) {
	ret := _m.Called(ctx, ns, intervals, collection)

	var r0 []*core.ChartHistogram
	if rf, ok := ret.Get(0).(func(context.Context, string, []core.ChartHistogramInterval, database.CollectionName) []*core.ChartHistogram); ok {
		r0 = rf(ctx, ns, intervals, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ChartHistogram)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []core.ChartHistogramInterval, database.CollectionName) error); ok {
		r1 = rf(ctx, ns, intervals, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigRecord provides a mock function with given fields: ctx, key
func (_m *Plugin) GetConfigRecord(ctx context.Context, key string) (*fftypes.ConfigRecord, error) {
	ret := _m.Called(ctx, key)

	var r0 *fftypes.ConfigRecord
	if rf, ok := ret.Get(0).(func(context.Context, string) *fftypes.ConfigRecord); ok {
		r0 = rf(ctx, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.ConfigRecord)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfigRecords provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetConfigRecords(ctx context.Context, filter database.Filter) ([]*fftypes.ConfigRecord, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*fftypes.ConfigRecord
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*fftypes.ConfigRecord); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.ConfigRecord)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetContractAPIByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractAPIByID(ctx context.Context, id *fftypes.UUID) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.ContractAPI); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIByName provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetContractAPIByName(ctx context.Context, ns string, name string) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *core.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractAPI); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIs provides a mock function with given fields: ctx, ns, filter
func (_m *Plugin) GetContractAPIs(ctx context.Context, ns string, filter database.AndFilter) ([]*core.ContractAPI, *database.FilterResult, error) {
	ret := _m.Called(ctx, ns, filter)

	var r0 []*core.ContractAPI
	if rf, ok := ret.Get(0).(func(context.Context, string, database.AndFilter) []*core.ContractAPI); ok {
		r0 = rf(ctx, ns, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ContractAPI)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.AndFilter) *database.FilterResult); ok {
		r1 = rf(ctx, ns, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.AndFilter) error); ok {
		r2 = rf(ctx, ns, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetContractListener provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetContractListener(ctx context.Context, ns string, name string) (*core.ContractListener, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *core.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractListener); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByBackendID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractListenerByBackendID(ctx context.Context, id string) (*core.ContractListener, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, string) *core.ContractListener); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetContractListenerByID(ctx context.Context, id *fftypes.UUID) (*core.ContractListener, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.ContractListener); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListeners provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetContractListeners(ctx context.Context, filter database.Filter) ([]*core.ContractListener, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.ContractListener
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.ContractListener); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ContractListener)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetData provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetData(ctx context.Context, filter database.Filter) (core.DataArray, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 core.DataArray
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) core.DataArray); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.DataArray)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDataByID provides a mock function with given fields: ctx, id, withValue
func (_m *Plugin) GetDataByID(ctx context.Context, id *fftypes.UUID, withValue bool) (*core.Data, error) {
	ret := _m.Called(ctx, id, withValue)

	var r0 *core.Data
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, bool) *core.Data); ok {
		r0 = rf(ctx, id, withValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Data)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, bool) error); ok {
		r1 = rf(ctx, id, withValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRefs provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetDataRefs(ctx context.Context, filter database.Filter) (core.DataRefs, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 core.DataRefs
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) core.DataRefs); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.DataRefs)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDatatypeByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetDatatypeByID(ctx context.Context, id *fftypes.UUID) (*core.Datatype, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Datatype); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Datatype)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypeByName provides a mock function with given fields: ctx, ns, name, version
func (_m *Plugin) GetDatatypeByName(ctx context.Context, ns string, name string, version string) (*core.Datatype, error) {
	ret := _m.Called(ctx, ns, name, version)

	var r0 *core.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *core.Datatype); ok {
		r0 = rf(ctx, ns, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Datatype)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, ns, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypes provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetDatatypes(ctx context.Context, filter database.Filter) ([]*core.Datatype, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Datatype
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Datatype); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Datatype)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetEventByID(ctx context.Context, id *fftypes.UUID) (*core.Event, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Event
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Event); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Event)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetEvents(ctx context.Context, filter database.Filter) ([]*core.Event, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Event
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Event); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Event)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFI provides a mock function with given fields: ctx, ns, name, version
func (_m *Plugin) GetFFI(ctx context.Context, ns string, name string, version string) (*core.FFI, error) {
	ret := _m.Called(ctx, ns, name, version)

	var r0 *core.FFI
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *core.FFI); ok {
		r0 = rf(ctx, ns, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.FFI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, ns, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetFFIByID(ctx context.Context, id *fftypes.UUID) (*core.FFI, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.FFI
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.FFI); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.FFI)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEvent provides a mock function with given fields: ctx, ns, interfaceID, pathName
func (_m *Plugin) GetFFIEvent(ctx context.Context, ns string, interfaceID *fftypes.UUID, pathName string) (*core.FFIEvent, error) {
	ret := _m.Called(ctx, ns, interfaceID, pathName)

	var r0 *core.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.FFIEvent); ok {
		r0 = rf(ctx, ns, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.FFIEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, ns, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEventByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetFFIEventByID(ctx context.Context, id *fftypes.UUID) (*core.FFIEvent, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.FFIEvent); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.FFIEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEvents provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetFFIEvents(ctx context.Context, filter database.Filter) ([]*core.FFIEvent, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.FFIEvent
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.FFIEvent); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.FFIEvent)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIMethod provides a mock function with given fields: ctx, ns, interfaceID, pathName
func (_m *Plugin) GetFFIMethod(ctx context.Context, ns string, interfaceID *fftypes.UUID, pathName string) (*core.FFIMethod, error) {
	ret := _m.Called(ctx, ns, interfaceID, pathName)

	var r0 *core.FFIMethod
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.FFIMethod); ok {
		r0 = rf(ctx, ns, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.FFIMethod)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, ns, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIMethods provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetFFIMethods(ctx context.Context, filter database.Filter) ([]*core.FFIMethod, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.FFIMethod
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.FFIMethod); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.FFIMethod)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIs provides a mock function with given fields: ctx, ns, filter
func (_m *Plugin) GetFFIs(ctx context.Context, ns string, filter database.Filter) ([]*core.FFI, *database.FilterResult, error) {
	ret := _m.Called(ctx, ns, filter)

	var r0 []*core.FFI
	if rf, ok := ret.Get(0).(func(context.Context, string, database.Filter) []*core.FFI); ok {
		r0 = rf(ctx, ns, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.FFI)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, ns, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.Filter) error); ok {
		r2 = rf(ctx, ns, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetGroupByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetGroupByHash(ctx context.Context, hash *fftypes.Bytes32) (*core.Group, error) {
	ret := _m.Called(ctx, hash)

	var r0 *core.Group
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.Group); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Group)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetGroups(ctx context.Context, filter database.Filter) ([]*core.Group, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Group
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Group); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Group)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentities provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetIdentities(ctx context.Context, filter database.Filter) ([]*core.Identity, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Identity
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Identity); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Identity)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentityByDID provides a mock function with given fields: ctx, did
func (_m *Plugin) GetIdentityByDID(ctx context.Context, did string) (*core.Identity, error) {
	ret := _m.Called(ctx, did)

	var r0 *core.Identity
	if rf, ok := ret.Get(0).(func(context.Context, string) *core.Identity); ok {
		r0 = rf(ctx, did)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, did)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetIdentityByID(ctx context.Context, id *fftypes.UUID) (*core.Identity, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Identity
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Identity); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByName provides a mock function with given fields: ctx, iType, namespace, name
func (_m *Plugin) GetIdentityByName(ctx context.Context, iType core.FFEnum, namespace string, name string) (*core.Identity, error) {
	ret := _m.Called(ctx, iType, namespace, name)

	var r0 *core.Identity
	if rf, ok := ret.Get(0).(func(context.Context, core.FFEnum, string, string) *core.Identity); ok {
		r0 = rf(ctx, iType, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, core.FFEnum, string, string) error); ok {
		r1 = rf(ctx, iType, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetMessageByID(ctx context.Context, id *fftypes.UUID) (*core.Message, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Message
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Message); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Message)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageIDs provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetMessageIDs(ctx context.Context, filter database.Filter) ([]*core.IDAndSequence, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.IDAndSequence
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.IDAndSequence); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.IDAndSequence)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) error); ok {
		r1 = rf(ctx, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessages provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetMessages(ctx context.Context, filter database.Filter) ([]*core.Message, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Message
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Message); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Message)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMessagesForData provides a mock function with given fields: ctx, dataID, filter
func (_m *Plugin) GetMessagesForData(ctx context.Context, dataID *fftypes.UUID, filter database.Filter) ([]*core.Message, *database.FilterResult, error) {
	ret := _m.Called(ctx, dataID, filter)

	var r0 []*core.Message
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Filter) []*core.Message); ok {
		r0 = rf(ctx, dataID, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Message)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, dataID, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, *fftypes.UUID, database.Filter) error); ok {
		r2 = rf(ctx, dataID, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNamespace provides a mock function with given fields: ctx, name
func (_m *Plugin) GetNamespace(ctx context.Context, name string) (*core.Namespace, error) {
	ret := _m.Called(ctx, name)

	var r0 *core.Namespace
	if rf, ok := ret.Get(0).(func(context.Context, string) *core.Namespace); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Namespace)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamespaceByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetNamespaceByID(ctx context.Context, id *fftypes.UUID) (*core.Namespace, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Namespace
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Namespace); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Namespace)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNamespaces provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNamespaces(ctx context.Context, filter database.Filter) ([]*core.Namespace, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Namespace
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Namespace); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Namespace)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNextPinByContextAndIdentity provides a mock function with given fields: ctx, _a1, identity
func (_m *Plugin) GetNextPinByContextAndIdentity(ctx context.Context, _a1 *fftypes.Bytes32, identity string) (*core.NextPin, error) {
	ret := _m.Called(ctx, _a1, identity)

	var r0 *core.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, string) *core.NextPin); ok {
		r0 = rf(ctx, _a1, identity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.NextPin)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32, string) error); ok {
		r1 = rf(ctx, _a1, identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextPinByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetNextPinByHash(ctx context.Context, hash *fftypes.Bytes32) (*core.NextPin, error) {
	ret := _m.Called(ctx, hash)

	var r0 *core.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.NextPin); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.NextPin)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextPins provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNextPins(ctx context.Context, filter database.Filter) ([]*core.NextPin, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.NextPin
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.NextPin); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.NextPin)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetNonce(ctx context.Context, hash *fftypes.Bytes32) (*core.Nonce, error) {
	ret := _m.Called(ctx, hash)

	var r0 *core.Nonce
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.Nonce); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Nonce)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonces provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNonces(ctx context.Context, filter database.Filter) ([]*core.Nonce, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Nonce
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Nonce); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Nonce)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) GetOffset(ctx context.Context, t core.FFEnum, name string) (*core.Offset, error) {
	ret := _m.Called(ctx, t, name)

	var r0 *core.Offset
	if rf, ok := ret.Get(0).(func(context.Context, core.FFEnum, string) *core.Offset); ok {
		r0 = rf(ctx, t, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Offset)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, core.FFEnum, string) error); ok {
		r1 = rf(ctx, t, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOffsets provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetOffsets(ctx context.Context, filter database.Filter) ([]*core.Offset, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Offset
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Offset); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Offset)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOperationByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetOperationByID(ctx context.Context, id *fftypes.UUID) (*core.Operation, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Operation
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Operation); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Operation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOperations provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetOperations(ctx context.Context, filter database.Filter) ([]*core.Operation, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Operation
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Operation); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Operation)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetPins provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetPins(ctx context.Context, filter database.Filter) ([]*core.Pin, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Pin
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Pin); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Pin)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetSubscriptionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetSubscriptionByID(ctx context.Context, id *fftypes.UUID) (*core.Subscription, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Subscription); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptionByName provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetSubscriptionByName(ctx context.Context, ns string, name string) (*core.Subscription, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *core.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.Subscription); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptions provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetSubscriptions(ctx context.Context, filter database.Filter) ([]*core.Subscription, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Subscription
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Subscription); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Subscription)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccountPools provides a mock function with given fields: ctx, key, filter
func (_m *Plugin) GetTokenAccountPools(ctx context.Context, key string, filter database.Filter) ([]*core.TokenAccountPool, *database.FilterResult, error) {
	ret := _m.Called(ctx, key, filter)

	var r0 []*core.TokenAccountPool
	if rf, ok := ret.Get(0).(func(context.Context, string, database.Filter) []*core.TokenAccountPool); ok {
		r0 = rf(ctx, key, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenAccountPool)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, string, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, key, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, database.Filter) error); ok {
		r2 = rf(ctx, key, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccounts provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenAccounts(ctx context.Context, filter database.Filter) ([]*core.TokenAccount, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.TokenAccount
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.TokenAccount); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenAccount)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenApprovalByID provides a mock function with given fields: ctx, localID
func (_m *Plugin) GetTokenApprovalByID(ctx context.Context, localID *fftypes.UUID) (*core.TokenApproval, error) {
	ret := _m.Called(ctx, localID)

	var r0 *core.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.TokenApproval); ok {
		r0 = rf(ctx, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenApproval)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovalByProtocolID provides a mock function with given fields: ctx, connector, protocolID
func (_m *Plugin) GetTokenApprovalByProtocolID(ctx context.Context, connector string, protocolID string) (*core.TokenApproval, error) {
	ret := _m.Called(ctx, connector, protocolID)

	var r0 *core.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenApproval); ok {
		r0 = rf(ctx, connector, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenApproval)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovals provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenApprovals(ctx context.Context, filter database.Filter) ([]*core.TokenApproval, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.TokenApproval
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.TokenApproval); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenApproval)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenBalance provides a mock function with given fields: ctx, poolID, tokenIndex, identity
func (_m *Plugin) GetTokenBalance(ctx context.Context, poolID *fftypes.UUID, tokenIndex string, identity string) (*core.TokenBalance, error) {
	ret := _m.Called(ctx, poolID, tokenIndex, identity)

	var r0 *core.TokenBalance
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, string, string) *core.TokenBalance); ok {
		r0 = rf(ctx, poolID, tokenIndex, identity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenBalance)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID, string, string) error); ok {
		r1 = rf(ctx, poolID, tokenIndex, identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenBalances provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenBalances(ctx context.Context, filter database.Filter) ([]*core.TokenBalance, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.TokenBalance
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.TokenBalance); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenBalance)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenPool provides a mock function with given fields: ctx, ns, name
func (_m *Plugin) GetTokenPool(ctx context.Context, ns string, name string) (*core.TokenPool, error) {
	ret := _m.Called(ctx, ns, name)

	var r0 *core.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenPool); ok {
		r0 = rf(ctx, ns, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, ns, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetTokenPoolByID(ctx context.Context, id *fftypes.UUID) (*core.TokenPool, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.TokenPool); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByLocator provides a mock function with given fields: ctx, connector, locator
func (_m *Plugin) GetTokenPoolByLocator(ctx context.Context, connector string, locator string) (*core.TokenPool, error) {
	ret := _m.Called(ctx, connector, locator)

	var r0 *core.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenPool); ok {
		r0 = rf(ctx, connector, locator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, locator)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPools provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenPools(ctx context.Context, filter database.Filter) ([]*core.TokenPool, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.TokenPool
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.TokenPool); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenPool)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenTransferByID provides a mock function with given fields: ctx, localID
func (_m *Plugin) GetTokenTransferByID(ctx context.Context, localID *fftypes.UUID) (*core.TokenTransfer, error) {
	ret := _m.Called(ctx, localID)

	var r0 *core.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.TokenTransfer); ok {
		r0 = rf(ctx, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenTransfer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransferByProtocolID provides a mock function with given fields: ctx, connector, protocolID
func (_m *Plugin) GetTokenTransferByProtocolID(ctx context.Context, connector string, protocolID string) (*core.TokenTransfer, error) {
	ret := _m.Called(ctx, connector, protocolID)

	var r0 *core.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenTransfer); ok {
		r0 = rf(ctx, connector, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenTransfer)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, connector, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransfers provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTokenTransfers(ctx context.Context, filter database.Filter) ([]*core.TokenTransfer, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.TokenTransfer
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.TokenTransfer); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenTransfer)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTransactionByID provides a mock function with given fields: ctx, id
func (_m *Plugin) GetTransactionByID(ctx context.Context, id *fftypes.UUID) (*core.Transaction, error) {
	ret := _m.Called(ctx, id)

	var r0 *core.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID) *core.Transaction); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.UUID) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactions provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetTransactions(ctx context.Context, filter database.Filter) ([]*core.Transaction, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Transaction
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Transaction); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Transaction)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetVerifierByHash provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetVerifierByHash(ctx context.Context, hash *fftypes.Bytes32) (*core.Verifier, error) {
	ret := _m.Called(ctx, hash)

	var r0 *core.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.Verifier); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Verifier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifierByValue provides a mock function with given fields: ctx, vType, namespace, value
func (_m *Plugin) GetVerifierByValue(ctx context.Context, vType core.FFEnum, namespace string, value string) (*core.Verifier, error) {
	ret := _m.Called(ctx, vType, namespace, value)

	var r0 *core.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, core.FFEnum, string, string) *core.Verifier); ok {
		r0 = rf(ctx, vType, namespace, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Verifier)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, core.FFEnum, string, string) error); ok {
		r1 = rf(ctx, vType, namespace, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiers provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetVerifiers(ctx context.Context, filter database.Filter) ([]*core.Verifier, *database.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	var r0 []*core.Verifier
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter) []*core.Verifier); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Verifier)
		}
	}

	var r1 *database.FilterResult
	if rf, ok := ret.Get(1).(func(context.Context, database.Filter) *database.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*database.FilterResult)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, database.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Init provides a mock function with given fields: ctx, _a1, callbacks
func (_m *Plugin) Init(ctx context.Context, _a1 config.Section, callbacks database.Callbacks) error {
	ret := _m.Called(ctx, _a1, callbacks)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, config.Section, database.Callbacks) error); ok {
		r0 = rf(ctx, _a1, callbacks)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InitConfig provides a mock function with given fields: _a0
func (_m *Plugin) InitConfig(_a0 config.Section) {
	_m.Called(_a0)
}

// InsertBlob provides a mock function with given fields: ctx, blob
func (_m *Plugin) InsertBlob(ctx context.Context, blob *core.Blob) error {
	ret := _m.Called(ctx, blob)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Blob) error); ok {
		r0 = rf(ctx, blob)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertBlobs provides a mock function with given fields: ctx, blobs
func (_m *Plugin) InsertBlobs(ctx context.Context, blobs []*core.Blob) error {
	ret := _m.Called(ctx, blobs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Blob) error); ok {
		r0 = rf(ctx, blobs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertBlockchainEvent provides a mock function with given fields: ctx, event
func (_m *Plugin) InsertBlockchainEvent(ctx context.Context, event *core.BlockchainEvent) error {
	ret := _m.Called(ctx, event)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.BlockchainEvent) error); ok {
		r0 = rf(ctx, event)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertDataArray provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertDataArray(ctx context.Context, data core.DataArray) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, core.DataArray) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertEvent provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertEvent(ctx context.Context, data *core.Event) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Event) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertMessages provides a mock function with given fields: ctx, messages, hooks
func (_m *Plugin) InsertMessages(ctx context.Context, messages []*core.Message, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, messages)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Message, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, messages, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertNextPin provides a mock function with given fields: ctx, nextpin
func (_m *Plugin) InsertNextPin(ctx context.Context, nextpin *core.NextPin) error {
	ret := _m.Called(ctx, nextpin)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.NextPin) error); ok {
		r0 = rf(ctx, nextpin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertNonce provides a mock function with given fields: ctx, nonce
func (_m *Plugin) InsertNonce(ctx context.Context, nonce *core.Nonce) error {
	ret := _m.Called(ctx, nonce)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Nonce) error); ok {
		r0 = rf(ctx, nonce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOperation provides a mock function with given fields: ctx, operation, hooks
func (_m *Plugin) InsertOperation(ctx context.Context, operation *core.Operation, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, operation)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Operation, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, operation, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertPins provides a mock function with given fields: ctx, pins
func (_m *Plugin) InsertPins(ctx context.Context, pins []*core.Pin) error {
	ret := _m.Called(ctx, pins)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Pin) error); ok {
		r0 = rf(ctx, pins)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertTransaction provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertTransaction(ctx context.Context, data *core.Transaction) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Transaction) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Plugin) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplaceMessage provides a mock function with given fields: ctx, message
func (_m *Plugin) ReplaceMessage(ctx context.Context, message *core.Message) error {
	ret := _m.Called(ctx, message)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Message) error); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ResolveOperation provides a mock function with given fields: ctx, ns, id, status, errorMsg, output
func (_m *Plugin) ResolveOperation(ctx context.Context, ns string, id *fftypes.UUID, status core.OpStatus, errorMsg string, output fftypes.JSONObject) error {
	ret := _m.Called(ctx, ns, id, status, errorMsg, output)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, core.OpStatus, string, fftypes.JSONObject) error); ok {
		r0 = rf(ctx, ns, id, status, errorMsg, output)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunAsGroup provides a mock function with given fields: ctx, fn
func (_m *Plugin) RunAsGroup(ctx context.Context, fn func(context.Context) error) error {
	ret := _m.Called(ctx, fn)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(context.Context) error) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateBatch provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateBatch(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateData provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateData(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateDatatype provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateDatatype(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateEvent provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateEvent(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateGroup provides a mock function with given fields: ctx, hash, update
func (_m *Plugin) UpdateGroup(ctx context.Context, hash *fftypes.Bytes32, update database.Update) error {
	ret := _m.Called(ctx, hash, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, database.Update) error); ok {
		r0 = rf(ctx, hash, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateIdentity provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateIdentity(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessage provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateMessage(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessages provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdateMessages(ctx context.Context, filter database.Filter, update database.Update) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter, database.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNextPin provides a mock function with given fields: ctx, sequence, update
func (_m *Plugin) UpdateNextPin(ctx context.Context, sequence int64, update database.Update) error {
	ret := _m.Called(ctx, sequence, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, database.Update) error); ok {
		r0 = rf(ctx, sequence, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNonce provides a mock function with given fields: ctx, nonce
func (_m *Plugin) UpdateNonce(ctx context.Context, nonce *core.Nonce) error {
	ret := _m.Called(ctx, nonce)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Nonce) error); ok {
		r0 = rf(ctx, nonce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOffset provides a mock function with given fields: ctx, rowID, update
func (_m *Plugin) UpdateOffset(ctx context.Context, rowID int64, update database.Update) error {
	ret := _m.Called(ctx, rowID, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, database.Update) error); ok {
		r0 = rf(ctx, rowID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOperation provides a mock function with given fields: ctx, ns, id, update
func (_m *Plugin) UpdateOperation(ctx context.Context, ns string, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, ns, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, ns, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdatePins provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdatePins(ctx context.Context, filter database.Filter, update database.Update) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter, database.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateSubscription provides a mock function with given fields: ctx, ns, name, update
func (_m *Plugin) UpdateSubscription(ctx context.Context, ns string, name string, update database.Update) error {
	ret := _m.Called(ctx, ns, name, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, database.Update) error); ok {
		r0 = rf(ctx, ns, name, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTokenApprovals provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdateTokenApprovals(ctx context.Context, filter database.Filter, update database.Update) error {
	ret := _m.Called(ctx, filter, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, database.Filter, database.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTokenBalances provides a mock function with given fields: ctx, transfer
func (_m *Plugin) UpdateTokenBalances(ctx context.Context, transfer *core.TokenTransfer) error {
	ret := _m.Called(ctx, transfer)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenTransfer) error); ok {
		r0 = rf(ctx, transfer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTransaction provides a mock function with given fields: ctx, id, update
func (_m *Plugin) UpdateTransaction(ctx context.Context, id *fftypes.UUID, update database.Update) error {
	ret := _m.Called(ctx, id, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.UUID, database.Update) error); ok {
		r0 = rf(ctx, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateVerifier provides a mock function with given fields: ctx, hash, update
func (_m *Plugin) UpdateVerifier(ctx context.Context, hash *fftypes.Bytes32, update database.Update) error {
	ret := _m.Called(ctx, hash, update)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32, database.Update) error); ok {
		r0 = rf(ctx, hash, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertBatch provides a mock function with given fields: ctx, data
func (_m *Plugin) UpsertBatch(ctx context.Context, data *core.BatchPersisted) error {
	ret := _m.Called(ctx, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.BatchPersisted) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertConfigRecord provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertConfigRecord(ctx context.Context, data *fftypes.ConfigRecord, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.ConfigRecord, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractAPI provides a mock function with given fields: ctx, cd
func (_m *Plugin) UpsertContractAPI(ctx context.Context, cd *core.ContractAPI) error {
	ret := _m.Called(ctx, cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractAPI) error); ok {
		r0 = rf(ctx, cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractListener provides a mock function with given fields: ctx, sub
func (_m *Plugin) UpsertContractListener(ctx context.Context, sub *core.ContractListener) error {
	ret := _m.Called(ctx, sub)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractListener) error); ok {
		r0 = rf(ctx, sub)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertData provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertData(ctx context.Context, data *core.Data, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Data, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertDatatype provides a mock function with given fields: ctx, datadef, allowExisting
func (_m *Plugin) UpsertDatatype(ctx context.Context, datadef *core.Datatype, allowExisting bool) error {
	ret := _m.Called(ctx, datadef, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Datatype, bool) error); ok {
		r0 = rf(ctx, datadef, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFI provides a mock function with given fields: ctx, cd
func (_m *Plugin) UpsertFFI(ctx context.Context, cd *core.FFI) error {
	ret := _m.Called(ctx, cd)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.FFI) error); ok {
		r0 = rf(ctx, cd)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIEvent provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIEvent(ctx context.Context, method *core.FFIEvent) error {
	ret := _m.Called(ctx, method)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.FFIEvent) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIMethod provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIMethod(ctx context.Context, method *core.FFIMethod) error {
	ret := _m.Called(ctx, method)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.FFIMethod) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertGroup provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertGroup(ctx context.Context, data *core.Group, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Group, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertIdentity provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertIdentity(ctx context.Context, data *core.Identity, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Identity, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertMessage provides a mock function with given fields: ctx, message, optimization, hooks
func (_m *Plugin) UpsertMessage(ctx context.Context, message *core.Message, optimization database.UpsertOptimization, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, message, optimization)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Message, database.UpsertOptimization, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, message, optimization, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertNamespace provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertNamespace(ctx context.Context, data *core.Namespace, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Namespace, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertOffset provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertOffset(ctx context.Context, data *core.Offset, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Offset, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertPin provides a mock function with given fields: ctx, parked
func (_m *Plugin) UpsertPin(ctx context.Context, parked *core.Pin) error {
	ret := _m.Called(ctx, parked)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Pin) error); ok {
		r0 = rf(ctx, parked)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertSubscription provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertSubscription(ctx context.Context, data *core.Subscription, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Subscription, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenApproval provides a mock function with given fields: ctx, approval
func (_m *Plugin) UpsertTokenApproval(ctx context.Context, approval *core.TokenApproval) error {
	ret := _m.Called(ctx, approval)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenApproval) error); ok {
		r0 = rf(ctx, approval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenPool provides a mock function with given fields: ctx, pool
func (_m *Plugin) UpsertTokenPool(ctx context.Context, pool *core.TokenPool) error {
	ret := _m.Called(ctx, pool)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenPool) error); ok {
		r0 = rf(ctx, pool)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenTransfer provides a mock function with given fields: ctx, transfer
func (_m *Plugin) UpsertTokenTransfer(ctx context.Context, transfer *core.TokenTransfer) error {
	ret := _m.Called(ctx, transfer)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenTransfer) error); ok {
		r0 = rf(ctx, transfer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertVerifier provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertVerifier(ctx context.Context, data *core.Verifier, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Verifier, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

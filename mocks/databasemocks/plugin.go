// Code generated by mockery v2.40.2. DO NOT EDIT.

package databasemocks

import (
	context "context"

	config "github.com/hyperledger/firefly-common/pkg/config"

	core "github.com/hyperledger/firefly/pkg/core"

	database "github.com/hyperledger/firefly/pkg/database"

	ffapi "github.com/hyperledger/firefly-common/pkg/ffapi"

	fftypes "github.com/hyperledger/firefly-common/pkg/fftypes"

	mock "github.com/stretchr/testify/mock"
)

// Plugin is an autogenerated mock type for the Plugin type
type Plugin struct {
	mock.Mock
}

// Capabilities provides a mock function with given fields:
func (_m *Plugin) Capabilities() *database.Capabilities {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Capabilities")
	}

	var r0 *database.Capabilities
	if rf, ok := ret.Get(0).(func() *database.Capabilities); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*database.Capabilities)
		}
	}

	return r0
}

// DeleteBlob provides a mock function with given fields: ctx, sequence
func (_m *Plugin) DeleteBlob(ctx context.Context, sequence int64) error {
	ret := _m.Called(ctx, sequence)

	if len(ret) == 0 {
		panic("no return value specified for DeleteBlob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64) error); ok {
		r0 = rf(ctx, sequence)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteContractAPI provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteContractAPI(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContractAPI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteContractListenerByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteContractListenerByID(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteContractListenerByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteData provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteData(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteData")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteFFI provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteFFI(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteFFI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) DeleteNonce(ctx context.Context, hash *fftypes.Bytes32) error {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNonce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) error); ok {
		r0 = rf(ctx, hash)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) DeleteOffset(ctx context.Context, t fftypes.FFEnum, name string) error {
	ret := _m.Called(ctx, t, name)

	if len(ret) == 0 {
		panic("no return value specified for DeleteOffset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string) error); ok {
		r0 = rf(ctx, t, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSubscriptionByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteSubscriptionByID(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSubscriptionByID")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenApprovals provides a mock function with given fields: ctx, namespace, poolID
func (_m *Plugin) DeleteTokenApprovals(ctx context.Context, namespace string, poolID *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, poolID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTokenApprovals")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, poolID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenBalances provides a mock function with given fields: ctx, namespace, poolID
func (_m *Plugin) DeleteTokenBalances(ctx context.Context, namespace string, poolID *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, poolID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTokenBalances")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, poolID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenPool provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) DeleteTokenPool(ctx context.Context, namespace string, id *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTokenPool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTokenTransfers provides a mock function with given fields: ctx, namespace, poolID
func (_m *Plugin) DeleteTokenTransfers(ctx context.Context, namespace string, poolID *fftypes.UUID) error {
	ret := _m.Called(ctx, namespace, poolID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTokenTransfers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) error); ok {
		r0 = rf(ctx, namespace, poolID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetBatchByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetBatchByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.BatchPersisted, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchByID")
	}

	var r0 *core.BatchPersisted
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.BatchPersisted, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.BatchPersisted); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BatchPersisted)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchIDsForDataAttachments provides a mock function with given fields: ctx, namespace, dataIDs
func (_m *Plugin) GetBatchIDsForDataAttachments(ctx context.Context, namespace string, dataIDs []*fftypes.UUID) ([]*fftypes.UUID, error) {
	ret := _m.Called(ctx, namespace, dataIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchIDsForDataAttachments")
	}

	var r0 []*fftypes.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []*fftypes.UUID) ([]*fftypes.UUID, error)); ok {
		return rf(ctx, namespace, dataIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []*fftypes.UUID) []*fftypes.UUID); ok {
		r0 = rf(ctx, namespace, dataIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []*fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, dataIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatchIDsForMessages provides a mock function with given fields: ctx, namespace, msgIDs
func (_m *Plugin) GetBatchIDsForMessages(ctx context.Context, namespace string, msgIDs []*fftypes.UUID) ([]*fftypes.UUID, error) {
	ret := _m.Called(ctx, namespace, msgIDs)

	if len(ret) == 0 {
		panic("no return value specified for GetBatchIDsForMessages")
	}

	var r0 []*fftypes.UUID
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []*fftypes.UUID) ([]*fftypes.UUID, error)); ok {
		return rf(ctx, namespace, msgIDs)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []*fftypes.UUID) []*fftypes.UUID); ok {
		r0 = rf(ctx, namespace, msgIDs)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.UUID)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []*fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, msgIDs)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBatches provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetBatches(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.BatchPersisted, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetBatches")
	}

	var r0 []*core.BatchPersisted
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.BatchPersisted, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.BatchPersisted); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.BatchPersisted)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlobs provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetBlobs(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Blob, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetBlobs")
	}

	var r0 []*core.Blob
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Blob, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Blob); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Blob)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetBlockchainEventByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetBlockchainEventByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.BlockchainEvent, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockchainEventByID")
	}

	var r0 *core.BlockchainEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.BlockchainEvent, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.BlockchainEvent); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BlockchainEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainEventByProtocolID provides a mock function with given fields: ctx, namespace, listener, protocolID
func (_m *Plugin) GetBlockchainEventByProtocolID(ctx context.Context, namespace string, listener *fftypes.UUID, protocolID string) (*core.BlockchainEvent, error) {
	ret := _m.Called(ctx, namespace, listener, protocolID)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockchainEventByProtocolID")
	}

	var r0 *core.BlockchainEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) (*core.BlockchainEvent, error)); ok {
		return rf(ctx, namespace, listener, protocolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.BlockchainEvent); ok {
		r0 = rf(ctx, namespace, listener, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BlockchainEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, namespace, listener, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBlockchainEvents provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetBlockchainEvents(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.BlockchainEvent, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetBlockchainEvents")
	}

	var r0 []*core.BlockchainEvent
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.BlockchainEvent, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.BlockchainEvent); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.BlockchainEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetChartHistogram provides a mock function with given fields: ctx, namespace, intervals, collection
func (_m *Plugin) GetChartHistogram(ctx context.Context, namespace string, intervals []core.ChartHistogramInterval, collection database.CollectionName) ([]*core.ChartHistogram, error) {
	ret := _m.Called(ctx, namespace, intervals, collection)

	if len(ret) == 0 {
		panic("no return value specified for GetChartHistogram")
	}

	var r0 []*core.ChartHistogram
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []core.ChartHistogramInterval, database.CollectionName) ([]*core.ChartHistogram, error)); ok {
		return rf(ctx, namespace, intervals, collection)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []core.ChartHistogramInterval, database.CollectionName) []*core.ChartHistogram); ok {
		r0 = rf(ctx, namespace, intervals, collection)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ChartHistogram)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []core.ChartHistogramInterval, database.CollectionName) error); ok {
		r1 = rf(ctx, namespace, intervals, collection)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetContractAPIByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetContractAPIByID")
	}

	var r0 *core.ContractAPI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.ContractAPI, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.ContractAPI); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIByName provides a mock function with given fields: ctx, namespace, name
func (_m *Plugin) GetContractAPIByName(ctx context.Context, namespace string, name string) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetContractAPIByName")
	}

	var r0 *core.ContractAPI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.ContractAPI, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractAPI); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIByNetworkName provides a mock function with given fields: ctx, namespace, networkName
func (_m *Plugin) GetContractAPIByNetworkName(ctx context.Context, namespace string, networkName string) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, namespace, networkName)

	if len(ret) == 0 {
		panic("no return value specified for GetContractAPIByNetworkName")
	}

	var r0 *core.ContractAPI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.ContractAPI, error)); ok {
		return rf(ctx, namespace, networkName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractAPI); ok {
		r0 = rf(ctx, namespace, networkName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, networkName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractAPIs provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetContractAPIs(ctx context.Context, namespace string, filter ffapi.AndFilter) ([]*core.ContractAPI, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetContractAPIs")
	}

	var r0 []*core.ContractAPI
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.AndFilter) ([]*core.ContractAPI, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.AndFilter) []*core.ContractAPI); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ContractAPI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.AndFilter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.AndFilter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetContractListener provides a mock function with given fields: ctx, namespace, name
func (_m *Plugin) GetContractListener(ctx context.Context, namespace string, name string) (*core.ContractListener, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetContractListener")
	}

	var r0 *core.ContractListener
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.ContractListener, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractListener); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByBackendID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetContractListenerByBackendID(ctx context.Context, namespace string, id string) (*core.ContractListener, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetContractListenerByBackendID")
	}

	var r0 *core.ContractListener
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.ContractListener, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.ContractListener); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListenerByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetContractListenerByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.ContractListener, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetContractListenerByID")
	}

	var r0 *core.ContractListener
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.ContractListener, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.ContractListener); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractListener)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetContractListeners provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetContractListeners(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.ContractListener, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetContractListeners")
	}

	var r0 []*core.ContractListener
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.ContractListener, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.ContractListener); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.ContractListener)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetData provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetData(ctx context.Context, namespace string, filter ffapi.Filter) (core.DataArray, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetData")
	}

	var r0 core.DataArray
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) (core.DataArray, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) core.DataArray); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.DataArray)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDataByID provides a mock function with given fields: ctx, namespace, id, withValue
func (_m *Plugin) GetDataByID(ctx context.Context, namespace string, id *fftypes.UUID, withValue bool) (*core.Data, error) {
	ret := _m.Called(ctx, namespace, id, withValue)

	if len(ret) == 0 {
		panic("no return value specified for GetDataByID")
	}

	var r0 *core.Data
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, bool) (*core.Data, error)); ok {
		return rf(ctx, namespace, id, withValue)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, bool) *core.Data); ok {
		r0 = rf(ctx, namespace, id, withValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Data)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, bool) error); ok {
		r1 = rf(ctx, namespace, id, withValue)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDataRefs provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetDataRefs(ctx context.Context, namespace string, filter ffapi.Filter) (core.DataRefs, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetDataRefs")
	}

	var r0 core.DataRefs
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) (core.DataRefs, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) core.DataRefs); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(core.DataRefs)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDataSubPaths provides a mock function with given fields: ctx, namespace, path
func (_m *Plugin) GetDataSubPaths(ctx context.Context, namespace string, path string) ([]string, error) {
	ret := _m.Called(ctx, namespace, path)

	if len(ret) == 0 {
		panic("no return value specified for GetDataSubPaths")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]string, error)); ok {
		return rf(ctx, namespace, path)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []string); ok {
		r0 = rf(ctx, namespace, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypeByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetDatatypeByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Datatype, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetDatatypeByID")
	}

	var r0 *core.Datatype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Datatype, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Datatype); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Datatype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypeByName provides a mock function with given fields: ctx, namespace, name, version
func (_m *Plugin) GetDatatypeByName(ctx context.Context, namespace string, name string, version string) (*core.Datatype, error) {
	ret := _m.Called(ctx, namespace, name, version)

	if len(ret) == 0 {
		panic("no return value specified for GetDatatypeByName")
	}

	var r0 *core.Datatype
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*core.Datatype, error)); ok {
		return rf(ctx, namespace, name, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *core.Datatype); ok {
		r0 = rf(ctx, namespace, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Datatype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, namespace, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDatatypes provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetDatatypes(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Datatype, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetDatatypes")
	}

	var r0 []*core.Datatype
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Datatype, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Datatype); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Datatype)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetEventByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetEventByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Event, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetEventByID")
	}

	var r0 *core.Event
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Event, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Event); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvents provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetEvents(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Event, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetEvents")
	}

	var r0 []*core.Event
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Event, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Event); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetEventsInSequenceRange provides a mock function with given fields: ctx, namespace, filter, startSequence, endSequence
func (_m *Plugin) GetEventsInSequenceRange(ctx context.Context, namespace string, filter ffapi.Filter, startSequence int, endSequence int) ([]*core.Event, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter, startSequence, endSequence)

	if len(ret) == 0 {
		panic("no return value specified for GetEventsInSequenceRange")
	}

	var r0 []*core.Event
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter, int, int) ([]*core.Event, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter, startSequence, endSequence)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter, int, int) []*core.Event); ok {
		r0 = rf(ctx, namespace, filter, startSequence, endSequence)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Event)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter, int, int) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter, startSequence, endSequence)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter, int, int) error); ok {
		r2 = rf(ctx, namespace, filter, startSequence, endSequence)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFI provides a mock function with given fields: ctx, namespace, name, version
func (_m *Plugin) GetFFI(ctx context.Context, namespace string, name string, version string) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, namespace, name, version)

	if len(ret) == 0 {
		panic("no return value specified for GetFFI")
	}

	var r0 *fftypes.FFI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*fftypes.FFI, error)); ok {
		return rf(ctx, namespace, name, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *fftypes.FFI); ok {
		r0 = rf(ctx, namespace, name, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, namespace, name, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetFFIByID(ctx context.Context, namespace string, id *fftypes.UUID) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIByID")
	}

	var r0 *fftypes.FFI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*fftypes.FFI, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *fftypes.FFI); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIByNetworkName provides a mock function with given fields: ctx, namespace, networkName, version
func (_m *Plugin) GetFFIByNetworkName(ctx context.Context, namespace string, networkName string, version string) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, namespace, networkName, version)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIByNetworkName")
	}

	var r0 *fftypes.FFI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (*fftypes.FFI, error)); ok {
		return rf(ctx, namespace, networkName, version)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) *fftypes.FFI); ok {
		r0 = rf(ctx, namespace, networkName, version)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, namespace, networkName, version)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIErrors provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetFFIErrors(ctx context.Context, namespace string, filter ffapi.Filter) ([]*fftypes.FFIError, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIErrors")
	}

	var r0 []*fftypes.FFIError
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*fftypes.FFIError, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*fftypes.FFIError); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFIError)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIEvent provides a mock function with given fields: ctx, namespace, interfaceID, pathName
func (_m *Plugin) GetFFIEvent(ctx context.Context, namespace string, interfaceID *fftypes.UUID, pathName string) (*fftypes.FFIEvent, error) {
	ret := _m.Called(ctx, namespace, interfaceID, pathName)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIEvent")
	}

	var r0 *fftypes.FFIEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) (*fftypes.FFIEvent, error)); ok {
		return rf(ctx, namespace, interfaceID, pathName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *fftypes.FFIEvent); ok {
		r0 = rf(ctx, namespace, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFIEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, namespace, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIEvents provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetFFIEvents(ctx context.Context, namespace string, filter ffapi.Filter) ([]*fftypes.FFIEvent, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIEvents")
	}

	var r0 []*fftypes.FFIEvent
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*fftypes.FFIEvent, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*fftypes.FFIEvent); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFIEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIMethod provides a mock function with given fields: ctx, namespace, interfaceID, pathName
func (_m *Plugin) GetFFIMethod(ctx context.Context, namespace string, interfaceID *fftypes.UUID, pathName string) (*fftypes.FFIMethod, error) {
	ret := _m.Called(ctx, namespace, interfaceID, pathName)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIMethod")
	}

	var r0 *fftypes.FFIMethod
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) (*fftypes.FFIMethod, error)); ok {
		return rf(ctx, namespace, interfaceID, pathName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *fftypes.FFIMethod); ok {
		r0 = rf(ctx, namespace, interfaceID, pathName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFIMethod)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, namespace, interfaceID, pathName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFFIMethods provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetFFIMethods(ctx context.Context, namespace string, filter ffapi.Filter) ([]*fftypes.FFIMethod, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIMethods")
	}

	var r0 []*fftypes.FFIMethod
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*fftypes.FFIMethod, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*fftypes.FFIMethod); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFIMethod)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetFFIs provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetFFIs(ctx context.Context, namespace string, filter ffapi.Filter) ([]*fftypes.FFI, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetFFIs")
	}

	var r0 []*fftypes.FFI
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*fftypes.FFI, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*fftypes.FFI); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fftypes.FFI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetGroupByHash provides a mock function with given fields: ctx, namespace, hash
func (_m *Plugin) GetGroupByHash(ctx context.Context, namespace string, hash *fftypes.Bytes32) (*core.Group, error) {
	ret := _m.Called(ctx, namespace, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupByHash")
	}

	var r0 *core.Group
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) (*core.Group, error)); ok {
		return rf(ctx, namespace, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) *core.Group); ok {
		r0 = rf(ctx, namespace, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, namespace, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetGroups provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetGroups(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Group, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetGroups")
	}

	var r0 []*core.Group
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Group, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Group); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentities provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetIdentities(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Identity, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetIdentities")
	}

	var r0 []*core.Identity
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Identity, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Identity); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Identity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetIdentityByDID provides a mock function with given fields: ctx, namespace, did
func (_m *Plugin) GetIdentityByDID(ctx context.Context, namespace string, did string) (*core.Identity, error) {
	ret := _m.Called(ctx, namespace, did)

	if len(ret) == 0 {
		panic("no return value specified for GetIdentityByDID")
	}

	var r0 *core.Identity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.Identity, error)); ok {
		return rf(ctx, namespace, did)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.Identity); ok {
		r0 = rf(ctx, namespace, did)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, did)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetIdentityByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Identity, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetIdentityByID")
	}

	var r0 *core.Identity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Identity, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Identity); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByName provides a mock function with given fields: ctx, iType, namespace, name
func (_m *Plugin) GetIdentityByName(ctx context.Context, iType fftypes.FFEnum, namespace string, name string) (*core.Identity, error) {
	ret := _m.Called(ctx, iType, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetIdentityByName")
	}

	var r0 *core.Identity
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) (*core.Identity, error)); ok {
		return rf(ctx, iType, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) *core.Identity); ok {
		r0 = rf(ctx, iType, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Identity)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string, string) error); ok {
		r1 = rf(ctx, iType, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetMessageByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Message, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetMessageByID")
	}

	var r0 *core.Message
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Message, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Message); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessageIDs provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetMessageIDs(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.IDAndSequence, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetMessageIDs")
	}

	var r0 []*core.IDAndSequence
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.IDAndSequence, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.IDAndSequence); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.IDAndSequence)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) error); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMessages provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetMessages(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Message, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetMessages")
	}

	var r0 []*core.Message
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Message, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Message); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMessagesForData provides a mock function with given fields: ctx, namespace, dataID, filter
func (_m *Plugin) GetMessagesForData(ctx context.Context, namespace string, dataID *fftypes.UUID, filter ffapi.Filter) ([]*core.Message, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, dataID, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetMessagesForData")
	}

	var r0 []*core.Message
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Filter) ([]*core.Message, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, dataID, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Filter) []*core.Message); ok {
		r0 = rf(ctx, namespace, dataID, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Message)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, dataID, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, *fftypes.UUID, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, dataID, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNamespace provides a mock function with given fields: ctx, name
func (_m *Plugin) GetNamespace(ctx context.Context, name string) (*core.Namespace, error) {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for GetNamespace")
	}

	var r0 *core.Namespace
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*core.Namespace, error)); ok {
		return rf(ctx, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *core.Namespace); ok {
		r0 = rf(ctx, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Namespace)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNextPins provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetNextPins(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.NextPin, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetNextPins")
	}

	var r0 []*core.NextPin
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.NextPin, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.NextPin); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.NextPin)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetNextPinsForContext provides a mock function with given fields: ctx, namespace, _a2
func (_m *Plugin) GetNextPinsForContext(ctx context.Context, namespace string, _a2 *fftypes.Bytes32) ([]*core.NextPin, error) {
	ret := _m.Called(ctx, namespace, _a2)

	if len(ret) == 0 {
		panic("no return value specified for GetNextPinsForContext")
	}

	var r0 []*core.NextPin
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) ([]*core.NextPin, error)); ok {
		return rf(ctx, namespace, _a2)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) []*core.NextPin); ok {
		r0 = rf(ctx, namespace, _a2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.NextPin)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, namespace, _a2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonce provides a mock function with given fields: ctx, hash
func (_m *Plugin) GetNonce(ctx context.Context, hash *fftypes.Bytes32) (*core.Nonce, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetNonce")
	}

	var r0 *core.Nonce
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) (*core.Nonce, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.Bytes32) *core.Nonce); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Nonce)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonces provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetNonces(ctx context.Context, filter ffapi.Filter) ([]*core.Nonce, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetNonces")
	}

	var r0 []*core.Nonce
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) ([]*core.Nonce, *ffapi.FilterResult, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) []*core.Nonce); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Nonce)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, ffapi.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOffset provides a mock function with given fields: ctx, t, name
func (_m *Plugin) GetOffset(ctx context.Context, t fftypes.FFEnum, name string) (*core.Offset, error) {
	ret := _m.Called(ctx, t, name)

	if len(ret) == 0 {
		panic("no return value specified for GetOffset")
	}

	var r0 *core.Offset
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string) (*core.Offset, error)); ok {
		return rf(ctx, t, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string) *core.Offset); ok {
		r0 = rf(ctx, t, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Offset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string) error); ok {
		r1 = rf(ctx, t, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOffsets provides a mock function with given fields: ctx, filter
func (_m *Plugin) GetOffsets(ctx context.Context, filter ffapi.Filter) ([]*core.Offset, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetOffsets")
	}

	var r0 []*core.Offset
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) ([]*core.Offset, *ffapi.FilterResult, error)); ok {
		return rf(ctx, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter) []*core.Offset); ok {
		r0 = rf(ctx, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Offset)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, ffapi.Filter) error); ok {
		r2 = rf(ctx, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetOperationByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetOperationByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Operation, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetOperationByID")
	}

	var r0 *core.Operation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Operation, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Operation); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetOperations provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetOperations(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Operation, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetOperations")
	}

	var r0 []*core.Operation
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Operation, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Operation); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Operation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetPins provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetPins(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Pin, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetPins")
	}

	var r0 []*core.Pin
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Pin, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Pin); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Pin)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetSubscriptionByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetSubscriptionByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Subscription, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscriptionByID")
	}

	var r0 *core.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Subscription, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Subscription); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptionByName provides a mock function with given fields: ctx, namespace, name
func (_m *Plugin) GetSubscriptionByName(ctx context.Context, namespace string, name string) (*core.Subscription, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscriptionByName")
	}

	var r0 *core.Subscription
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.Subscription, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.Subscription); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSubscriptions provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetSubscriptions(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Subscription, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetSubscriptions")
	}

	var r0 []*core.Subscription
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Subscription, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Subscription); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Subscription)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccountPools provides a mock function with given fields: ctx, namespace, key, filter
func (_m *Plugin) GetTokenAccountPools(ctx context.Context, namespace string, key string, filter ffapi.Filter) ([]*core.TokenAccountPool, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, key, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenAccountPools")
	}

	var r0 []*core.TokenAccountPool
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ffapi.Filter) ([]*core.TokenAccountPool, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, key, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ffapi.Filter) []*core.TokenAccountPool); ok {
		r0 = rf(ctx, namespace, key, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenAccountPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, key, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, key, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenAccounts provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTokenAccounts(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.TokenAccount, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenAccounts")
	}

	var r0 []*core.TokenAccount
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.TokenAccount, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.TokenAccount); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenApprovalByID provides a mock function with given fields: ctx, namespace, localID
func (_m *Plugin) GetTokenApprovalByID(ctx context.Context, namespace string, localID *fftypes.UUID) (*core.TokenApproval, error) {
	ret := _m.Called(ctx, namespace, localID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenApprovalByID")
	}

	var r0 *core.TokenApproval
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.TokenApproval, error)); ok {
		return rf(ctx, namespace, localID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.TokenApproval); ok {
		r0 = rf(ctx, namespace, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenApproval)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovalByProtocolID provides a mock function with given fields: ctx, namespace, poolID, protocolID
func (_m *Plugin) GetTokenApprovalByProtocolID(ctx context.Context, namespace string, poolID *fftypes.UUID, protocolID string) (*core.TokenApproval, error) {
	ret := _m.Called(ctx, namespace, poolID, protocolID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenApprovalByProtocolID")
	}

	var r0 *core.TokenApproval
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) (*core.TokenApproval, error)); ok {
		return rf(ctx, namespace, poolID, protocolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.TokenApproval); ok {
		r0 = rf(ctx, namespace, poolID, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenApproval)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, namespace, poolID, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenApprovals provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTokenApprovals(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.TokenApproval, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenApprovals")
	}

	var r0 []*core.TokenApproval
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.TokenApproval, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.TokenApproval); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenApproval)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenBalance provides a mock function with given fields: ctx, namespace, poolID, tokenIndex, identity
func (_m *Plugin) GetTokenBalance(ctx context.Context, namespace string, poolID *fftypes.UUID, tokenIndex string, identity string) (*core.TokenBalance, error) {
	ret := _m.Called(ctx, namespace, poolID, tokenIndex, identity)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenBalance")
	}

	var r0 *core.TokenBalance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string, string) (*core.TokenBalance, error)); ok {
		return rf(ctx, namespace, poolID, tokenIndex, identity)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string, string) *core.TokenBalance); ok {
		r0 = rf(ctx, namespace, poolID, tokenIndex, identity)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenBalance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string, string) error); ok {
		r1 = rf(ctx, namespace, poolID, tokenIndex, identity)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenBalances provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTokenBalances(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.TokenBalance, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenBalances")
	}

	var r0 []*core.TokenBalance
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.TokenBalance, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.TokenBalance); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenBalance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenPool provides a mock function with given fields: ctx, namespace, name
func (_m *Plugin) GetTokenPool(ctx context.Context, namespace string, name string) (*core.TokenPool, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenPool")
	}

	var r0 *core.TokenPool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.TokenPool, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenPool); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetTokenPoolByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.TokenPool, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenPoolByID")
	}

	var r0 *core.TokenPool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.TokenPool, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.TokenPool); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPoolByNetworkName provides a mock function with given fields: ctx, namespace, networkName
func (_m *Plugin) GetTokenPoolByNetworkName(ctx context.Context, namespace string, networkName string) (*core.TokenPool, error) {
	ret := _m.Called(ctx, namespace, networkName)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenPoolByNetworkName")
	}

	var r0 *core.TokenPool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*core.TokenPool, error)); ok {
		return rf(ctx, namespace, networkName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *core.TokenPool); ok {
		r0 = rf(ctx, namespace, networkName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, networkName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenPools provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTokenPools(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.TokenPool, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenPools")
	}

	var r0 []*core.TokenPool
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.TokenPool, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.TokenPool); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTokenTransferByID provides a mock function with given fields: ctx, namespace, localID
func (_m *Plugin) GetTokenTransferByID(ctx context.Context, namespace string, localID *fftypes.UUID) (*core.TokenTransfer, error) {
	ret := _m.Called(ctx, namespace, localID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenTransferByID")
	}

	var r0 *core.TokenTransfer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.TokenTransfer, error)); ok {
		return rf(ctx, namespace, localID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.TokenTransfer); ok {
		r0 = rf(ctx, namespace, localID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, localID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransferByProtocolID provides a mock function with given fields: ctx, namespace, poolID, protocolID
func (_m *Plugin) GetTokenTransferByProtocolID(ctx context.Context, namespace string, poolID *fftypes.UUID, protocolID string) (*core.TokenTransfer, error) {
	ret := _m.Called(ctx, namespace, poolID, protocolID)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenTransferByProtocolID")
	}

	var r0 *core.TokenTransfer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) (*core.TokenTransfer, error)); ok {
		return rf(ctx, namespace, poolID, protocolID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, string) *core.TokenTransfer); ok {
		r0 = rf(ctx, namespace, poolID, protocolID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, string) error); ok {
		r1 = rf(ctx, namespace, poolID, protocolID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenTransfers provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTokenTransfers(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.TokenTransfer, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTokenTransfers")
	}

	var r0 []*core.TokenTransfer
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.TokenTransfer, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.TokenTransfer); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.TokenTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetTransactionByID provides a mock function with given fields: ctx, namespace, id
func (_m *Plugin) GetTransactionByID(ctx context.Context, namespace string, id *fftypes.UUID) (*core.Transaction, error) {
	ret := _m.Called(ctx, namespace, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactionByID")
	}

	var r0 *core.Transaction
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) (*core.Transaction, error)); ok {
		return rf(ctx, namespace, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID) *core.Transaction); ok {
		r0 = rf(ctx, namespace, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID) error); ok {
		r1 = rf(ctx, namespace, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactions provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetTransactions(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Transaction, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetTransactions")
	}

	var r0 []*core.Transaction
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Transaction, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Transaction); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Transaction)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetVerifierByHash provides a mock function with given fields: ctx, namespace, hash
func (_m *Plugin) GetVerifierByHash(ctx context.Context, namespace string, hash *fftypes.Bytes32) (*core.Verifier, error) {
	ret := _m.Called(ctx, namespace, hash)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifierByHash")
	}

	var r0 *core.Verifier
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) (*core.Verifier, error)); ok {
		return rf(ctx, namespace, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.Bytes32) *core.Verifier); ok {
		r0 = rf(ctx, namespace, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Verifier)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.Bytes32) error); ok {
		r1 = rf(ctx, namespace, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifierByValue provides a mock function with given fields: ctx, vType, namespace, value
func (_m *Plugin) GetVerifierByValue(ctx context.Context, vType fftypes.FFEnum, namespace string, value string) (*core.Verifier, error) {
	ret := _m.Called(ctx, vType, namespace, value)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifierByValue")
	}

	var r0 *core.Verifier
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) (*core.Verifier, error)); ok {
		return rf(ctx, vType, namespace, value)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fftypes.FFEnum, string, string) *core.Verifier); ok {
		r0 = rf(ctx, vType, namespace, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.Verifier)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fftypes.FFEnum, string, string) error); ok {
		r1 = rf(ctx, vType, namespace, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVerifiers provides a mock function with given fields: ctx, namespace, filter
func (_m *Plugin) GetVerifiers(ctx context.Context, namespace string, filter ffapi.Filter) ([]*core.Verifier, *ffapi.FilterResult, error) {
	ret := _m.Called(ctx, namespace, filter)

	if len(ret) == 0 {
		panic("no return value specified for GetVerifiers")
	}

	var r0 []*core.Verifier
	var r1 *ffapi.FilterResult
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) ([]*core.Verifier, *ffapi.FilterResult, error)); ok {
		return rf(ctx, namespace, filter)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter) []*core.Verifier); ok {
		r0 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*core.Verifier)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ffapi.Filter) *ffapi.FilterResult); ok {
		r1 = rf(ctx, namespace, filter)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*ffapi.FilterResult)
		}
	}

	if rf, ok := ret.Get(2).(func(context.Context, string, ffapi.Filter) error); ok {
		r2 = rf(ctx, namespace, filter)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// Init provides a mock function with given fields: ctx, _a1
func (_m *Plugin) Init(ctx context.Context, _a1 config.Section) error {
	ret := _m.Called(ctx, _a1)

	if len(ret) == 0 {
		panic("no return value specified for Init")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, config.Section) error); ok {
		r0 = rf(ctx, _a1)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InitConfig provides a mock function with given fields: _a0
func (_m *Plugin) InitConfig(_a0 config.Section) {
	_m.Called(_a0)
}

// InsertBlob provides a mock function with given fields: ctx, blob
func (_m *Plugin) InsertBlob(ctx context.Context, blob *core.Blob) error {
	ret := _m.Called(ctx, blob)

	if len(ret) == 0 {
		panic("no return value specified for InsertBlob")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Blob) error); ok {
		r0 = rf(ctx, blob)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertBlobs provides a mock function with given fields: ctx, blobs
func (_m *Plugin) InsertBlobs(ctx context.Context, blobs []*core.Blob) error {
	ret := _m.Called(ctx, blobs)

	if len(ret) == 0 {
		panic("no return value specified for InsertBlobs")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Blob) error); ok {
		r0 = rf(ctx, blobs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertBlockchainEvents provides a mock function with given fields: ctx, messages, hooks
func (_m *Plugin) InsertBlockchainEvents(ctx context.Context, messages []*core.BlockchainEvent, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, messages)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertBlockchainEvents")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.BlockchainEvent, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, messages, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertContractListener provides a mock function with given fields: ctx, sub
func (_m *Plugin) InsertContractListener(ctx context.Context, sub *core.ContractListener) error {
	ret := _m.Called(ctx, sub)

	if len(ret) == 0 {
		panic("no return value specified for InsertContractListener")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractListener) error); ok {
		r0 = rf(ctx, sub)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertDataArray provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertDataArray(ctx context.Context, data core.DataArray) error {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertDataArray")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, core.DataArray) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertEvent provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertEvent(ctx context.Context, data *core.Event) error {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Event) error); ok {
		r0 = rf(ctx, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertMessages provides a mock function with given fields: ctx, messages, hooks
func (_m *Plugin) InsertMessages(ctx context.Context, messages []*core.Message, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, messages)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Message, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, messages, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertNextPin provides a mock function with given fields: ctx, nextpin
func (_m *Plugin) InsertNextPin(ctx context.Context, nextpin *core.NextPin) error {
	ret := _m.Called(ctx, nextpin)

	if len(ret) == 0 {
		panic("no return value specified for InsertNextPin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.NextPin) error); ok {
		r0 = rf(ctx, nextpin)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertNonce provides a mock function with given fields: ctx, nonce
func (_m *Plugin) InsertNonce(ctx context.Context, nonce *core.Nonce) error {
	ret := _m.Called(ctx, nonce)

	if len(ret) == 0 {
		panic("no return value specified for InsertNonce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Nonce) error); ok {
		r0 = rf(ctx, nonce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOperation provides a mock function with given fields: ctx, operation, hooks
func (_m *Plugin) InsertOperation(ctx context.Context, operation *core.Operation, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, operation)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertOperation")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Operation, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, operation, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOperations provides a mock function with given fields: ctx, ops, hooks
func (_m *Plugin) InsertOperations(ctx context.Context, ops []*core.Operation, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, ops)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for InsertOperations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Operation, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, ops, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertOrGetBatch provides a mock function with given fields: ctx, data
func (_m *Plugin) InsertOrGetBatch(ctx context.Context, data *core.BatchPersisted) (*core.BatchPersisted, error) {
	ret := _m.Called(ctx, data)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetBatch")
	}

	var r0 *core.BatchPersisted
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.BatchPersisted) (*core.BatchPersisted, error)); ok {
		return rf(ctx, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *core.BatchPersisted) *core.BatchPersisted); ok {
		r0 = rf(ctx, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BatchPersisted)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *core.BatchPersisted) error); ok {
		r1 = rf(ctx, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertOrGetBlockchainEvent provides a mock function with given fields: ctx, event
func (_m *Plugin) InsertOrGetBlockchainEvent(ctx context.Context, event *core.BlockchainEvent) (*core.BlockchainEvent, error) {
	ret := _m.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetBlockchainEvent")
	}

	var r0 *core.BlockchainEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.BlockchainEvent) (*core.BlockchainEvent, error)); ok {
		return rf(ctx, event)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *core.BlockchainEvent) *core.BlockchainEvent); ok {
		r0 = rf(ctx, event)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.BlockchainEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *core.BlockchainEvent) error); ok {
		r1 = rf(ctx, event)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertOrGetContractAPI provides a mock function with given fields: ctx, api
func (_m *Plugin) InsertOrGetContractAPI(ctx context.Context, api *core.ContractAPI) (*core.ContractAPI, error) {
	ret := _m.Called(ctx, api)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetContractAPI")
	}

	var r0 *core.ContractAPI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractAPI) (*core.ContractAPI, error)); ok {
		return rf(ctx, api)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractAPI) *core.ContractAPI); ok {
		r0 = rf(ctx, api)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ContractAPI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *core.ContractAPI) error); ok {
		r1 = rf(ctx, api)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertOrGetFFI provides a mock function with given fields: ctx, ffi
func (_m *Plugin) InsertOrGetFFI(ctx context.Context, ffi *fftypes.FFI) (*fftypes.FFI, error) {
	ret := _m.Called(ctx, ffi)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetFFI")
	}

	var r0 *fftypes.FFI
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFI) (*fftypes.FFI, error)); ok {
		return rf(ctx, ffi)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFI) *fftypes.FFI); ok {
		r0 = rf(ctx, ffi)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fftypes.FFI)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *fftypes.FFI) error); ok {
		r1 = rf(ctx, ffi)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertOrGetTokenPool provides a mock function with given fields: ctx, pool
func (_m *Plugin) InsertOrGetTokenPool(ctx context.Context, pool *core.TokenPool) (*core.TokenPool, error) {
	ret := _m.Called(ctx, pool)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetTokenPool")
	}

	var r0 *core.TokenPool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenPool) (*core.TokenPool, error)); ok {
		return rf(ctx, pool)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenPool) *core.TokenPool); ok {
		r0 = rf(ctx, pool)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenPool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *core.TokenPool) error); ok {
		r1 = rf(ctx, pool)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertOrGetTokenTransfer provides a mock function with given fields: ctx, approval
func (_m *Plugin) InsertOrGetTokenTransfer(ctx context.Context, approval *core.TokenTransfer) (*core.TokenTransfer, error) {
	ret := _m.Called(ctx, approval)

	if len(ret) == 0 {
		panic("no return value specified for InsertOrGetTokenTransfer")
	}

	var r0 *core.TokenTransfer
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenTransfer) (*core.TokenTransfer, error)); ok {
		return rf(ctx, approval)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenTransfer) *core.TokenTransfer); ok {
		r0 = rf(ctx, approval)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.TokenTransfer)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *core.TokenTransfer) error); ok {
		r1 = rf(ctx, approval)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertPins provides a mock function with given fields: ctx, pins
func (_m *Plugin) InsertPins(ctx context.Context, pins []*core.Pin) error {
	ret := _m.Called(ctx, pins)

	if len(ret) == 0 {
		panic("no return value specified for InsertPins")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Pin) error); ok {
		r0 = rf(ctx, pins)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertTransaction provides a mock function with given fields: ctx, txn
func (_m *Plugin) InsertTransaction(ctx context.Context, txn *core.Transaction) error {
	ret := _m.Called(ctx, txn)

	if len(ret) == 0 {
		panic("no return value specified for InsertTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Transaction) error); ok {
		r0 = rf(ctx, txn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertTransactions provides a mock function with given fields: ctx, txns
func (_m *Plugin) InsertTransactions(ctx context.Context, txns []*core.Transaction) error {
	ret := _m.Called(ctx, txns)

	if len(ret) == 0 {
		panic("no return value specified for InsertTransactions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*core.Transaction) error); ok {
		r0 = rf(ctx, txns)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Name provides a mock function with given fields:
func (_m *Plugin) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplaceMessage provides a mock function with given fields: ctx, message
func (_m *Plugin) ReplaceMessage(ctx context.Context, message *core.Message) error {
	ret := _m.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for ReplaceMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Message) error); ok {
		r0 = rf(ctx, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunAsGroup provides a mock function with given fields: ctx, fn
func (_m *Plugin) RunAsGroup(ctx context.Context, fn func(context.Context) error) error {
	ret := _m.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for RunAsGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, func(context.Context) error) error); ok {
		r0 = rf(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetHandler provides a mock function with given fields: namespace, handler
func (_m *Plugin) SetHandler(namespace string, handler database.Callbacks) {
	_m.Called(namespace, handler)
}

// UpdateBatch provides a mock function with given fields: ctx, namespace, id, update
func (_m *Plugin) UpdateBatch(ctx context.Context, namespace string, id *fftypes.UUID, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, id, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateBatch")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateContractListener provides a mock function with given fields: ctx, namespace, id, update
func (_m *Plugin) UpdateContractListener(ctx context.Context, namespace string, id *fftypes.UUID, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, id, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateContractListener")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateData provides a mock function with given fields: ctx, namespace, id, update
func (_m *Plugin) UpdateData(ctx context.Context, namespace string, id *fftypes.UUID, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, id, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateData")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessage provides a mock function with given fields: ctx, namespace, id, update
func (_m *Plugin) UpdateMessage(ctx context.Context, namespace string, id *fftypes.UUID, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, id, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMessages provides a mock function with given fields: ctx, namespace, filter, update
func (_m *Plugin) UpdateMessages(ctx context.Context, namespace string, filter ffapi.Filter, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, filter, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNextPin provides a mock function with given fields: ctx, namespace, sequence, update
func (_m *Plugin) UpdateNextPin(ctx context.Context, namespace string, sequence int64, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, sequence, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNextPin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int64, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, sequence, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateNonce provides a mock function with given fields: ctx, nonce
func (_m *Plugin) UpdateNonce(ctx context.Context, nonce *core.Nonce) error {
	ret := _m.Called(ctx, nonce)

	if len(ret) == 0 {
		panic("no return value specified for UpdateNonce")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Nonce) error); ok {
		r0 = rf(ctx, nonce)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOffset provides a mock function with given fields: ctx, rowID, update
func (_m *Plugin) UpdateOffset(ctx context.Context, rowID int64, update ffapi.Update) error {
	ret := _m.Called(ctx, rowID, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOffset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, ffapi.Update) error); ok {
		r0 = rf(ctx, rowID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateOperation provides a mock function with given fields: ctx, namespace, id, filter, update
func (_m *Plugin) UpdateOperation(ctx context.Context, namespace string, id *fftypes.UUID, filter ffapi.Filter, update ffapi.Update) (bool, error) {
	ret := _m.Called(ctx, namespace, id, filter, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateOperation")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Filter, ffapi.Update) (bool, error)); ok {
		return rf(ctx, namespace, id, filter, update)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Filter, ffapi.Update) bool); ok {
		r0 = rf(ctx, namespace, id, filter, update)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *fftypes.UUID, ffapi.Filter, ffapi.Update) error); ok {
		r1 = rf(ctx, namespace, id, filter, update)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdatePins provides a mock function with given fields: ctx, namespace, filter, update
func (_m *Plugin) UpdatePins(ctx context.Context, namespace string, filter ffapi.Filter, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, filter, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePins")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ffapi.Filter, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateSubscription provides a mock function with given fields: ctx, namespace, name, update
func (_m *Plugin) UpdateSubscription(ctx context.Context, namespace string, name string, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, name, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSubscription")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, name, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTokenApprovals provides a mock function with given fields: ctx, filter, update
func (_m *Plugin) UpdateTokenApprovals(ctx context.Context, filter ffapi.Filter, update ffapi.Update) error {
	ret := _m.Called(ctx, filter, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTokenApprovals")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, ffapi.Filter, ffapi.Update) error); ok {
		r0 = rf(ctx, filter, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTokenBalances provides a mock function with given fields: ctx, transfer
func (_m *Plugin) UpdateTokenBalances(ctx context.Context, transfer *core.TokenTransfer) error {
	ret := _m.Called(ctx, transfer)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTokenBalances")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenTransfer) error); ok {
		r0 = rf(ctx, transfer)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateTransaction provides a mock function with given fields: ctx, namespace, id, update
func (_m *Plugin) UpdateTransaction(ctx context.Context, namespace string, id *fftypes.UUID, update ffapi.Update) error {
	ret := _m.Called(ctx, namespace, id, update)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTransaction")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *fftypes.UUID, ffapi.Update) error); ok {
		r0 = rf(ctx, namespace, id, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractAPI provides a mock function with given fields: ctx, api, optimization
func (_m *Plugin) UpsertContractAPI(ctx context.Context, api *core.ContractAPI, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, api, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertContractAPI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractAPI, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, api, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertContractListener provides a mock function with given fields: ctx, sub, allowExisting
func (_m *Plugin) UpsertContractListener(ctx context.Context, sub *core.ContractListener, allowExisting bool) error {
	ret := _m.Called(ctx, sub, allowExisting)

	if len(ret) == 0 {
		panic("no return value specified for UpsertContractListener")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.ContractListener, bool) error); ok {
		r0 = rf(ctx, sub, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertData provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertData(ctx context.Context, data *core.Data, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertData")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Data, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertDatatype provides a mock function with given fields: ctx, datadef, allowExisting
func (_m *Plugin) UpsertDatatype(ctx context.Context, datadef *core.Datatype, allowExisting bool) error {
	ret := _m.Called(ctx, datadef, allowExisting)

	if len(ret) == 0 {
		panic("no return value specified for UpsertDatatype")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Datatype, bool) error); ok {
		r0 = rf(ctx, datadef, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFI provides a mock function with given fields: ctx, ffi, optimization
func (_m *Plugin) UpsertFFI(ctx context.Context, ffi *fftypes.FFI, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, ffi, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertFFI")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFI, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, ffi, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIError provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIError(ctx context.Context, method *fftypes.FFIError) error {
	ret := _m.Called(ctx, method)

	if len(ret) == 0 {
		panic("no return value specified for UpsertFFIError")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFIError) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIEvent provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIEvent(ctx context.Context, method *fftypes.FFIEvent) error {
	ret := _m.Called(ctx, method)

	if len(ret) == 0 {
		panic("no return value specified for UpsertFFIEvent")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFIEvent) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertFFIMethod provides a mock function with given fields: ctx, method
func (_m *Plugin) UpsertFFIMethod(ctx context.Context, method *fftypes.FFIMethod) error {
	ret := _m.Called(ctx, method)

	if len(ret) == 0 {
		panic("no return value specified for UpsertFFIMethod")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *fftypes.FFIMethod) error); ok {
		r0 = rf(ctx, method)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertGroup provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertGroup(ctx context.Context, data *core.Group, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertGroup")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Group, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertIdentity provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertIdentity(ctx context.Context, data *core.Identity, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertIdentity")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Identity, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertMessage provides a mock function with given fields: ctx, message, optimization, hooks
func (_m *Plugin) UpsertMessage(ctx context.Context, message *core.Message, optimization database.UpsertOptimization, hooks ...database.PostCompletionHook) error {
	_va := make([]interface{}, len(hooks))
	for _i := range hooks {
		_va[_i] = hooks[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, message, optimization)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpsertMessage")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Message, database.UpsertOptimization, ...database.PostCompletionHook) error); ok {
		r0 = rf(ctx, message, optimization, hooks...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertNamespace provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertNamespace(ctx context.Context, data *core.Namespace, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	if len(ret) == 0 {
		panic("no return value specified for UpsertNamespace")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Namespace, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertOffset provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertOffset(ctx context.Context, data *core.Offset, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	if len(ret) == 0 {
		panic("no return value specified for UpsertOffset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Offset, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertPin provides a mock function with given fields: ctx, parked
func (_m *Plugin) UpsertPin(ctx context.Context, parked *core.Pin) error {
	ret := _m.Called(ctx, parked)

	if len(ret) == 0 {
		panic("no return value specified for UpsertPin")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Pin) error); ok {
		r0 = rf(ctx, parked)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertSubscription provides a mock function with given fields: ctx, data, allowExisting
func (_m *Plugin) UpsertSubscription(ctx context.Context, data *core.Subscription, allowExisting bool) error {
	ret := _m.Called(ctx, data, allowExisting)

	if len(ret) == 0 {
		panic("no return value specified for UpsertSubscription")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Subscription, bool) error); ok {
		r0 = rf(ctx, data, allowExisting)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenApproval provides a mock function with given fields: ctx, approval
func (_m *Plugin) UpsertTokenApproval(ctx context.Context, approval *core.TokenApproval) error {
	ret := _m.Called(ctx, approval)

	if len(ret) == 0 {
		panic("no return value specified for UpsertTokenApproval")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenApproval) error); ok {
		r0 = rf(ctx, approval)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertTokenPool provides a mock function with given fields: ctx, pool, optimization
func (_m *Plugin) UpsertTokenPool(ctx context.Context, pool *core.TokenPool, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, pool, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertTokenPool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.TokenPool, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, pool, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpsertVerifier provides a mock function with given fields: ctx, data, optimization
func (_m *Plugin) UpsertVerifier(ctx context.Context, data *core.Verifier, optimization database.UpsertOptimization) error {
	ret := _m.Called(ctx, data, optimization)

	if len(ret) == 0 {
		panic("no return value specified for UpsertVerifier")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *core.Verifier, database.UpsertOptimization) error); ok {
		r0 = rf(ctx, data, optimization)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewPlugin creates a new instance of Plugin. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPlugin(t interface {
	mock.TestingT
	Cleanup(func())
}) *Plugin {
	mock := &Plugin{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
